/*
 Copyright (c) 2006-2019 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

#if defined(VKTBD)

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

//#include <ucd-snmp/config.h>              /* For HAVE_STDLIB_H, etc.       */
//#include <ucd-snmp/mibincl.h>             /* Standard set of SNMP includes */
//#include <ucd-snmp/mibgroup/util_funcs.h> /* For header_generic() */

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_ieee8021PSFPMib.h"
#include "ieee8021PSFPMib.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021PSFPMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021PSFPMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021PSFPMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[IEEE8021PSFPMIB_STR_LEN_MAX + 1];
    struct counter64    c64_ret;
    u_long              ulong_ret;
} ieee8021PSFPMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ieee8021PSFPMib_var;
FindVarMethod ieee8021PSFPStreamFilterTable_var;
FindVarMethod ieee8021PSFPStreamGateTable_var;
FindVarMethod ieee8021PSFPFlowMeterTable_var;
FindVarMethod ieee8021PSFPStreamParameterTable_var;
WriteMethod ieee8021PSFPStreamHandleSpec_write;
WriteMethod ieee8021PSFPPrioritySpec_write;
WriteMethod ieee8021PSFPStreamGateInstanceID_write;
WriteMethod ieee8021PSFPFilterSpecificationList_write;
WriteMethod ieee8021PSFPStreamBlockedDueToOversizeFrameEnable_write;
WriteMethod ieee8021PSFPStreamBlockedDueToOversizeFrame_write;
WriteMethod ieee8021PSFPStreamFilterEntryRowStatus_write;
WriteMethod ieee8021PSFPGateEnabled_write;
WriteMethod ieee8021PSFPAdminGateStates_write;
WriteMethod ieee8021PSFPAdminControlListLength_write;
WriteMethod ieee8021PSFPAdminControlList_write;
WriteMethod ieee8021PSFPAdminCycleTimeNumerator_write;
WriteMethod ieee8021PSFPAdminCycleTimeDenominator_write;
WriteMethod ieee8021PSFPAdminCycleTimeExtension_write;
WriteMethod ieee8021PSFPAdminBaseTime_write;
WriteMethod ieee8021PSFPConfigChange_write;
WriteMethod ieee8021PSFPAdminIPV_write;
WriteMethod ieee8021PSFPOperIPV_write;
WriteMethod ieee8021PSFPGateClosedDueToInvalidRxEnable_write;
WriteMethod ieee8021PSFPGateClosedDueToInvalidRx_write;
WriteMethod ieee8021PSFPGateClosedDueToOctetsExceededEnable_write;
WriteMethod ieee8021PSFPGateClosedDueToOctetsExceeded_write;
WriteMethod ieee8021PSFPStreamGateEntryRowStatus_write;
WriteMethod ieee8021PSFPFlowMeterCIR_write;
WriteMethod ieee8021PSFPFlowMeterCBS_write;
WriteMethod ieee8021PSFPFlowMeterEIR_write;
WriteMethod ieee8021PSFPFlowMeterEBS_write;
WriteMethod ieee8021PSFPFlowMeterCF_write;
WriteMethod ieee8021PSFPFlowMeterCM_write;
WriteMethod ieee8021PSFPFlowMeterDropOnYellow_write;
WriteMethod ieee8021PSFPFlowMeterMarkAllFramesRedEnable_write;
WriteMethod ieee8021PSFPFlowMeterMarkAllFramesRed_write;
WriteMethod ieee8021PSFPFlowMeterEntryRowStatus_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ieee8021PSFPMib_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021PSFPMib_ret_t ieee8021PSFPMib_global_ret;

/*
 * ieee8021PSFPMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ieee8021PSFPMib_variables_oid[] = {1,3,111,2,802,1,1,31};



/*
 * variable ieee8021PSFPMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021PSFPMib mib section
 */

struct variable7 ieee8021PSFPMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IEEE8021PSFPSTREAMHANDLESPEC		1
    {IEEE8021PSFPSTREAMHANDLESPEC, ASN_INTEGER, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 2}},
#define IEEE8021PSFPPRIORITYSPEC		2
    {IEEE8021PSFPPRIORITYSPEC, ASN_INTEGER, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 3}},
#define IEEE8021PSFPSTREAMGATEINSTANCEID		3
    {IEEE8021PSFPSTREAMGATEINSTANCEID, ASN_UNSIGNED, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 4}},
#define IEEE8021PSFPFILTERSPECIFICATIONLIST		4
    {IEEE8021PSFPFILTERSPECIFICATIONLIST, ASN_OCTET_STR, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 5}},
#define IEEE8021PSFPMATCHINGFRAMESCOUNT		5
    {IEEE8021PSFPMATCHINGFRAMESCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 6}},
#define IEEE8021PSFPPASSINGFRAMESCOUNT		6
    {IEEE8021PSFPPASSINGFRAMESCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 7}},
#define IEEE8021PSFPNOTPASSINGFRAMESCOUNT		7
    {IEEE8021PSFPNOTPASSINGFRAMESCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 8}},
#define IEEE8021PSFPPASSINGSDUCOUNT		8
    {IEEE8021PSFPPASSINGSDUCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 9}},
#define IEEE8021PSFPNOTPASSINGSDUCOUNT		9
    {IEEE8021PSFPNOTPASSINGSDUCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 10}},
#define IEEE8021PSFPREDFRAMESCOUNT		10
    {IEEE8021PSFPREDFRAMESCOUNT, ASN_COUNTER64, RONLY, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 11}},
#define IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAMEENABLE		11
    {IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAMEENABLE, ASN_INTEGER, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 12}},
#define IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAME		12
    {IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAME, ASN_INTEGER, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 13}},
#define IEEE8021PSFPSTREAMFILTERENTRYROWSTATUS		13
    {IEEE8021PSFPSTREAMFILTERENTRYROWSTATUS, ASN_INTEGER, RWRITE, ieee8021PSFPStreamFilterTable_var, 5, {1,1,1, 1, 14}},
#define IEEE8021PSFPGATEENABLED		14
    {IEEE8021PSFPGATEENABLED, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 2}},
#define IEEE8021PSFPADMINGATESTATES		15
    {IEEE8021PSFPADMINGATESTATES, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 3}},
#define IEEE8021PSFPOPERGATESTATES		16
    {IEEE8021PSFPOPERGATESTATES, ASN_INTEGER, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 4}},
#define IEEE8021PSFPADMINCONTROLLISTLENGTH		17
    {IEEE8021PSFPADMINCONTROLLISTLENGTH, ASN_UNSIGNED, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 5}},
#define IEEE8021PSFPOPERCONTROLLISTLENGTH		18
    {IEEE8021PSFPOPERCONTROLLISTLENGTH, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 6}},
#define IEEE8021PSFPADMINCONTROLLIST		19
    {IEEE8021PSFPADMINCONTROLLIST, ASN_OCTET_STR, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 7}},
#define IEEE8021PSFPOPERCONTROLLIST		20
    {IEEE8021PSFPOPERCONTROLLIST, ASN_OCTET_STR, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 8}},
#define IEEE8021PSFPADMINCYCLETIMENUMERATOR		21
    {IEEE8021PSFPADMINCYCLETIMENUMERATOR, ASN_UNSIGNED, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 9}},
#define IEEE8021PSFPADMINCYCLETIMEDENOMINATOR		22
    {IEEE8021PSFPADMINCYCLETIMEDENOMINATOR, ASN_UNSIGNED, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 10}},
#define IEEE8021PSFPOPERCYCLETIMENUMERATOR		23
    {IEEE8021PSFPOPERCYCLETIMENUMERATOR, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 11}},
#define IEEE8021PSFPOPERCYCLETIMEDENOMINATOR		24
    {IEEE8021PSFPOPERCYCLETIMEDENOMINATOR, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 12}},
#define IEEE8021PSFPADMINCYCLETIMEEXTENSION		25
    {IEEE8021PSFPADMINCYCLETIMEEXTENSION, ASN_UNSIGNED, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 13}},
#define IEEE8021PSFPOPERCYCLETIMEEXTENSION		26
    {IEEE8021PSFPOPERCYCLETIMEEXTENSION, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 14}},
#define IEEE8021PSFPADMINBASETIME		27
    {IEEE8021PSFPADMINBASETIME, ASN_OCTET_STR, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 15}},
#define IEEE8021PSFPOPERBASETIME		28
    {IEEE8021PSFPOPERBASETIME, ASN_OCTET_STR, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 16}},
#define IEEE8021PSFPCONFIGCHANGE		29
    {IEEE8021PSFPCONFIGCHANGE, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 17}},
#define IEEE8021PSFPCONFIGCHANGETIME		30
    {IEEE8021PSFPCONFIGCHANGETIME, ASN_OCTET_STR, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 18}},
#define IEEE8021PSFPTICKGRANULARITY		31
    {IEEE8021PSFPTICKGRANULARITY, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 19}},
#define IEEE8021PSFPCURRENTTIME		32
    {IEEE8021PSFPCURRENTTIME, ASN_OCTET_STR, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 20}},
#define IEEE8021PSFPCONFIGPENDING		33
    {IEEE8021PSFPCONFIGPENDING, ASN_INTEGER, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 21}},
#define IEEE8021PSFPCONFIGCHANGEERROR		34
    {IEEE8021PSFPCONFIGCHANGEERROR, ASN_COUNTER64, RONLY, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 23}},
#define IEEE8021PSFPADMINIPV		35
    {IEEE8021PSFPADMINIPV, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 24}},
#define IEEE8021PSFPOPERIPV		36
    {IEEE8021PSFPOPERIPV, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 25}},
#define IEEE8021PSFPGATECLOSEDDUETOINVALIDRXENABLE		37
    {IEEE8021PSFPGATECLOSEDDUETOINVALIDRXENABLE, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 26}},
#define IEEE8021PSFPGATECLOSEDDUETOINVALIDRX		38
    {IEEE8021PSFPGATECLOSEDDUETOINVALIDRX, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 27}},
#define IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDEDENABLE		39
    {IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDEDENABLE, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 28}},
#define IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDED		40
    {IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDED, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 29}},
#define IEEE8021PSFPSTREAMGATEENTRYROWSTATUS		41
    {IEEE8021PSFPSTREAMGATEENTRYROWSTATUS, ASN_INTEGER, RWRITE, ieee8021PSFPStreamGateTable_var, 5, {1,2,1, 1, 30}},
#define IEEE8021PSFPFLOWMETERCIR		42
    {IEEE8021PSFPFLOWMETERCIR, ASN_UNSIGNED, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 2}},
#define IEEE8021PSFPFLOWMETERCBS		43
    {IEEE8021PSFPFLOWMETERCBS, ASN_UNSIGNED, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 3}},
#define IEEE8021PSFPFLOWMETEREIR		44
    {IEEE8021PSFPFLOWMETEREIR, ASN_UNSIGNED, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 4}},
#define IEEE8021PSFPFLOWMETEREBS		45
    {IEEE8021PSFPFLOWMETEREBS, ASN_UNSIGNED, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 5}},
#define IEEE8021PSFPFLOWMETERCF		46
    {IEEE8021PSFPFLOWMETERCF, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 6}},
#define IEEE8021PSFPFLOWMETERCM		47
    {IEEE8021PSFPFLOWMETERCM, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 7}},
#define IEEE8021PSFPFLOWMETERDROPONYELLOW		48
    {IEEE8021PSFPFLOWMETERDROPONYELLOW, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 8}},
#define IEEE8021PSFPFLOWMETERMARKALLFRAMESREDENABLE		49
    {IEEE8021PSFPFLOWMETERMARKALLFRAMESREDENABLE, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 9}},
#define IEEE8021PSFPFLOWMETERMARKALLFRAMESRED		50
    {IEEE8021PSFPFLOWMETERMARKALLFRAMESRED, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 10}},
#define IEEE8021PSFPFLOWMETERENTRYROWSTATUS		51
    {IEEE8021PSFPFLOWMETERENTRYROWSTATUS, ASN_INTEGER, RWRITE, ieee8021PSFPFlowMeterTable_var, 5, {1,3,1, 1, 11}},
#define IEEE8021PSFPMAXSTREAMFILTERINSTANCES		52
    {IEEE8021PSFPMAXSTREAMFILTERINSTANCES, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamParameterTable_var, 5, {1,4,1, 1, 1}},
#define IEEE8021PSFPMAXSTREAMGATEINSTANCES		53
    {IEEE8021PSFPMAXSTREAMGATEINSTANCES, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamParameterTable_var, 5, {1,4,1, 1, 2}},
#define IEEE8021PSFPMAXFLOWMETERINSTANCES		54
    {IEEE8021PSFPMAXFLOWMETERINSTANCES, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamParameterTable_var, 5, {1,4,1, 1, 3}},
#define IEEE8021PSFPSUPPORTEDLISTMAX		55
    {IEEE8021PSFPSUPPORTEDLISTMAX, ASN_UNSIGNED, RONLY, ieee8021PSFPStreamParameterTable_var, 5, {1,4,1, 1, 4}},
};


/******************************************************************************/
// ucd_snmp_init_ieee8021PSFPMib()
// Initializes the UCD-SNMP-part of the IEEE8021-PSFP-MIB:ieee8021PSFPMib.
/******************************************************************************/
void ucd_snmp_init_ieee8021PSFPMib(void)
{
    DEBUGMSGTL(("ieee8021PSFPMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021PSFPMib", ieee8021PSFPMib_variables, variable7, ieee8021PSFPMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021PSFPMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ieee8021PSFPMib_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021PSFPMib_var\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021PSFPStreamFilterTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PSFPStreamFilterTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PSFPStreamFilterTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PSFPStreamFilterTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021PSFPStreamFilterInstance = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PSFPStreamFilterTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PSFPStreamFilterTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PSFPStreamFilterTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021PSFPStreamFilterInstance;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PSFPStreamFilterTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PSFPMib_var above.
 */
u_char *
ieee8021PSFPStreamFilterTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PSFPStreamFilterTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PSFPStreamFilterTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PSFPStreamFilterTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021PSFPSTREAMFILTERENTRYROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ieee8021PSFPStreamFilterEntryRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021PSFPStreamFilterTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021PSFPSTREAMHANDLESPEC: {
        *write_method = ieee8021PSFPStreamHandleSpec_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPStreamHandleSpec;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPPRIORITYSPEC: {
        *write_method = ieee8021PSFPPrioritySpec_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPPrioritySpec;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPSTREAMGATEINSTANCEID: {
        *write_method = ieee8021PSFPStreamGateInstanceID_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPStreamGateInstanceID;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPFILTERSPECIFICATIONLIST: {
        *write_method = ieee8021PSFPFilterSpecificationList_write;
        *var_len = table_entry.ieee8021PSFPFilterSpecificationList_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPFilterSpecificationList, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPMATCHINGFRAMESCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPMatchingFramesCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPPASSINGFRAMESCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPPassingFramesCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPNOTPASSINGFRAMESCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPNotPassingFramesCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPPASSINGSDUCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPPassingSDUCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPNOTPASSINGSDUCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPNotPassingSDUCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPREDFRAMESCOUNT: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPREDFramesCount;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAMEENABLE: {
        *write_method = ieee8021PSFPStreamBlockedDueToOversizeFrameEnable_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPStreamBlockedDueToOversizeFrameEnable;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPSTREAMBLOCKEDDUETOOVERSIZEFRAME: {
        *write_method = ieee8021PSFPStreamBlockedDueToOversizeFrame_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPStreamBlockedDueToOversizeFrame;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPSTREAMFILTERENTRYROWSTATUS: {
        *write_method = ieee8021PSFPStreamFilterEntryRowStatus_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPStreamFilterEntryRowStatus;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PSFPStreamFilterTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021PSFPStreamGateTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PSFPStreamGateTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PSFPStreamGateTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PSFPStreamGateTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021PSFPStreamGateInstance = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PSFPStreamGateTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PSFPStreamGateTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PSFPStreamGateTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021PSFPStreamGateInstance;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PSFPStreamGateTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PSFPMib_var above.
 */
u_char *
ieee8021PSFPStreamGateTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PSFPStreamGateTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PSFPStreamGateTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PSFPStreamGateTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PSFPStreamGateTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021PSFPSTREAMGATEENTRYROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ieee8021PSFPStreamGateEntryRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021PSFPStreamGateTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021PSFPGATEENABLED: {
        *write_method = ieee8021PSFPGateEnabled_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPGateEnabled;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPADMINGATESTATES: {
        *write_method = ieee8021PSFPAdminGateStates_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPAdminGateStates;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPOPERGATESTATES: {
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPOperGateStates;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPADMINCONTROLLISTLENGTH: {
        *write_method = ieee8021PSFPAdminControlListLength_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPAdminControlListLength;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPOPERCONTROLLISTLENGTH: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPOperControlListLength;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPADMINCONTROLLIST: {
        *write_method = ieee8021PSFPAdminControlList_write;
        *var_len = table_entry.ieee8021PSFPAdminControlList_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPAdminControlList, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPOPERCONTROLLIST: {
        *var_len = table_entry.ieee8021PSFPOperControlList_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPOperControlList, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPADMINCYCLETIMENUMERATOR: {
        *write_method = ieee8021PSFPAdminCycleTimeNumerator_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPAdminCycleTimeNumerator;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPADMINCYCLETIMEDENOMINATOR: {
        *write_method = ieee8021PSFPAdminCycleTimeDenominator_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPAdminCycleTimeDenominator;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPOPERCYCLETIMENUMERATOR: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPOperCycleTimeNumerator;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPOPERCYCLETIMEDENOMINATOR: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPOperCycleTimeDenominator;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPADMINCYCLETIMEEXTENSION: {
        *write_method = ieee8021PSFPAdminCycleTimeExtension_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPAdminCycleTimeExtension;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPOPERCYCLETIMEEXTENSION: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPOperCycleTimeExtension;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPADMINBASETIME: {
        *write_method = ieee8021PSFPAdminBaseTime_write;
        *var_len = table_entry.ieee8021PSFPAdminBaseTime_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPAdminBaseTime, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPOPERBASETIME: {
        *var_len = table_entry.ieee8021PSFPOperBaseTime_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPOperBaseTime, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPCONFIGCHANGE: {
        *write_method = ieee8021PSFPConfigChange_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPConfigChange;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPCONFIGCHANGETIME: {
        *var_len = table_entry.ieee8021PSFPConfigChangeTime_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPConfigChangeTime, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPTICKGRANULARITY: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPTickGranularity;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPCURRENTTIME: {
        *var_len = table_entry.ieee8021PSFPCurrentTime_len;
        memcpy(ieee8021PSFPMib_global_ret.string_ret, table_entry.ieee8021PSFPCurrentTime, *var_len);
        ieee8021PSFPMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021PSFPMib_global_ret.string_ret;
    }
    case IEEE8021PSFPCONFIGPENDING: {
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPConfigPending;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPCONFIGCHANGEERROR: {
        ieee8021PSFPMib_global_ret.c64_ret = table_entry.ieee8021PSFPConfigChangeError;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.c64_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.c64_ret;
    }
    case IEEE8021PSFPADMINIPV: {
        *write_method = ieee8021PSFPAdminIPV_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPAdminIPV;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPOPERIPV: {
        *write_method = ieee8021PSFPOperIPV_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPOperIPV;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPGATECLOSEDDUETOINVALIDRXENABLE: {
        *write_method = ieee8021PSFPGateClosedDueToInvalidRxEnable_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPGateClosedDueToInvalidRxEnable;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPGATECLOSEDDUETOINVALIDRX: {
        *write_method = ieee8021PSFPGateClosedDueToInvalidRx_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPGateClosedDueToInvalidRx;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDEDENABLE: {
        *write_method = ieee8021PSFPGateClosedDueToOctetsExceededEnable_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPGateClosedDueToOctetsExceededEnable;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPGATECLOSEDDUETOOCTETSEXCEEDED: {
        *write_method = ieee8021PSFPGateClosedDueToOctetsExceeded_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPGateClosedDueToOctetsExceeded;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPSTREAMGATEENTRYROWSTATUS: {
        *write_method = ieee8021PSFPStreamGateEntryRowStatus_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPStreamGateEntryRowStatus;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PSFPStreamGateTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021PSFPFlowMeterTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PSFPFlowMeterTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PSFPFlowMeterTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PSFPFlowMeterTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021PSFPFlowMeterInstance = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PSFPFlowMeterTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PSFPFlowMeterTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021PSFPFlowMeterInstance;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PSFPFlowMeterTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PSFPMib_var above.
 */
u_char *
ieee8021PSFPFlowMeterTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PSFPFlowMeterTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PSFPFlowMeterTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PSFPFlowMeterTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021PSFPFLOWMETERENTRYROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ieee8021PSFPFlowMeterEntryRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021PSFPFlowMeterTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021PSFPFLOWMETERCIR: {
        *write_method = ieee8021PSFPFlowMeterCIR_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPFlowMeterCIR;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPFLOWMETERCBS: {
        *write_method = ieee8021PSFPFlowMeterCBS_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPFlowMeterCBS;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPFLOWMETEREIR: {
        *write_method = ieee8021PSFPFlowMeterEIR_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPFlowMeterEIR;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPFLOWMETEREBS: {
        *write_method = ieee8021PSFPFlowMeterEBS_write;
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPFlowMeterEBS;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPFLOWMETERCF: {
        *write_method = ieee8021PSFPFlowMeterCF_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterCF;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPFLOWMETERCM: {
        *write_method = ieee8021PSFPFlowMeterCM_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterCM;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPFLOWMETERDROPONYELLOW: {
        *write_method = ieee8021PSFPFlowMeterDropOnYellow_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterDropOnYellow;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPFLOWMETERMARKALLFRAMESREDENABLE: {
        *write_method = ieee8021PSFPFlowMeterMarkAllFramesRedEnable_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterMarkAllFramesRedEnable;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPFLOWMETERMARKALLFRAMESRED: {
        *write_method = ieee8021PSFPFlowMeterMarkAllFramesRed_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterMarkAllFramesRed;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    case IEEE8021PSFPFLOWMETERENTRYROWSTATUS: {
        *write_method = ieee8021PSFPFlowMeterEntryRowStatus_write;
        ieee8021PSFPMib_global_ret.long_ret = table_entry.ieee8021PSFPFlowMeterEntryRowStatus;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.long_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PSFPFlowMeterTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021PSFPStreamParameterTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PSFPStreamParameterTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PSFPStreamParameterTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PSFPStreamParameterTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PSFPStreamParameterTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PSFPStreamParameterTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PSFPStreamParameterTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PSFPStreamParameterTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PSFPMib_var above.
 */
u_char *
ieee8021PSFPStreamParameterTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PSFPStreamParameterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PSFPStreamParameterTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PSFPStreamParameterTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PSFPStreamParameterTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021PSFPStreamParameterTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021PSFPMAXSTREAMFILTERINSTANCES: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPMaxStreamFilterInstances;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPMAXSTREAMGATEINSTANCES: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPMaxStreamGateInstances;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPMAXFLOWMETERINSTANCES: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPMaxFlowMeterInstances;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    case IEEE8021PSFPSUPPORTEDLISTMAX: {
        ieee8021PSFPMib_global_ret.ulong_ret = table_entry.ieee8021PSFPSupportedListMax;
        *var_len = sizeof(ieee8021PSFPMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PSFPMib_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PSFPStreamParameterTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021PSFPStreamHandleSpec_write()
/******************************************************************************/
int
ieee8021PSFPStreamHandleSpec_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamHandleSpec: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamHandleSpec: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            /* The range is from -1 to 2147483647 according to IEEE8021-PSFP-MIB definition,
               but MSCC change it from 0 to 143 */
            if (set_value < 0 || set_value > 143) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamHandleSpec = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPPrioritySpec_write()
/******************************************************************************/
int
ieee8021PSFPPrioritySpec_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPPrioritySpec: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPPrioritySpec: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            /* The range is from -1 to 2147483647 according to IEEE8021-PSFP-MIB definition,
               but MSCC change it from 0 to 143 */
            if (set_value < 0 || set_value > 7) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPPrioritySpec = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPStreamGateInstanceID_write()
/******************************************************************************/
int
ieee8021PSFPStreamGateInstanceID_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamGateInstanceID: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamGateInstanceID: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamGateInstanceID = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFilterSpecificationList_write()
/******************************************************************************/
int
ieee8021PSFPFilterSpecificationList_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFilterSpecificationList: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021PSFPMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFilterSpecificationList: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021PSFPFilterSpecificationList, var_val, var_val_len);
            table_entry.ieee8021PSFPFilterSpecificationList_len = var_val_len;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPStreamBlockedDueToOversizeFrameEnable_write()
/******************************************************************************/
int
ieee8021PSFPStreamBlockedDueToOversizeFrameEnable_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrameEnable: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrameEnable: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrameEnable: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamBlockedDueToOversizeFrameEnable = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPStreamBlockedDueToOversizeFrame_write()
/******************************************************************************/
int
ieee8021PSFPStreamBlockedDueToOversizeFrame_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrame: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrame: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamBlockedDueToOversizeFrame: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamBlockedDueToOversizeFrame = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPStreamFilterEntryRowStatus_write()
/******************************************************************************/
int
ieee8021PSFPStreamFilterEntryRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamFilterTable_entry_t table_entry;
    static ieee8021PSFPStreamFilterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamFilterEntryRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamFilterEntryRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamFilterEntryRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamFilterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamFilterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021PSFPStreamFilterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamFilterEntryRowStatus = set_value;
            if (ieee8021PSFPStreamFilterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamFilterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPGateEnabled_write()
/******************************************************************************/
int
ieee8021PSFPGateEnabled_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPGateEnabled = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminGateStates_write()
/******************************************************************************/
int
ieee8021PSFPAdminGateStates_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminGateStates: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminGateStates: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminGateStates: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminGateStates = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminControlListLength_write()
/******************************************************************************/
int
ieee8021PSFPAdminControlListLength_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminControlListLength: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminControlListLength: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminControlListLength = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminControlList_write()
/******************************************************************************/
int
ieee8021PSFPAdminControlList_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminControlList: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021PSFPMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminControlList: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021PSFPAdminControlList, var_val, var_val_len);
            table_entry.ieee8021PSFPAdminControlList_len = var_val_len;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminCycleTimeNumerator_write()
/******************************************************************************/
int
ieee8021PSFPAdminCycleTimeNumerator_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeNumerator: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeNumerator: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminCycleTimeNumerator = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminCycleTimeDenominator_write()
/******************************************************************************/
int
ieee8021PSFPAdminCycleTimeDenominator_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeDenominator: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeDenominator: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminCycleTimeDenominator = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminCycleTimeExtension_write()
/******************************************************************************/
int
ieee8021PSFPAdminCycleTimeExtension_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeExtension: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminCycleTimeExtension: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminCycleTimeExtension = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminBaseTime_write()
/******************************************************************************/
int
ieee8021PSFPAdminBaseTime_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminBaseTime: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021PSFPMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminBaseTime: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 10) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021PSFPAdminBaseTime, var_val, var_val_len);
            table_entry.ieee8021PSFPAdminBaseTime_len = var_val_len;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPConfigChange_write()
/******************************************************************************/
int
ieee8021PSFPConfigChange_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPConfigChange: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPConfigChange: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPConfigChange: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPConfigChange = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPAdminIPV_write()
/******************************************************************************/
int
ieee8021PSFPAdminIPV_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminIPV: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPAdminIPV: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -1 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPAdminIPV = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPOperIPV_write()
/******************************************************************************/
int
ieee8021PSFPOperIPV_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPOperIPV: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPOperIPV: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -1 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPOperIPV = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPGateClosedDueToInvalidRxEnable_write()
/******************************************************************************/
int
ieee8021PSFPGateClosedDueToInvalidRxEnable_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRxEnable: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRxEnable: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRxEnable: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPGateClosedDueToInvalidRxEnable = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPGateClosedDueToInvalidRx_write()
/******************************************************************************/
int
ieee8021PSFPGateClosedDueToInvalidRx_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRx: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRx: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToInvalidRx: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPGateClosedDueToInvalidRx = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPGateClosedDueToOctetsExceededEnable_write()
/******************************************************************************/
int
ieee8021PSFPGateClosedDueToOctetsExceededEnable_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceededEnable: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceededEnable: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceededEnable: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPGateClosedDueToOctetsExceededEnable = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPGateClosedDueToOctetsExceeded_write()
/******************************************************************************/
int
ieee8021PSFPGateClosedDueToOctetsExceeded_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceeded: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceeded: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPGateClosedDueToOctetsExceeded: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPGateClosedDueToOctetsExceeded = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPStreamGateEntryRowStatus_write()
/******************************************************************************/
int
ieee8021PSFPStreamGateEntryRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPStreamGateTable_entry_t table_entry;
    static ieee8021PSFPStreamGateTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamGateEntryRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamGateEntryRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPStreamGateEntryRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPStreamGateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPStreamGateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021PSFPStreamGateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPStreamGateEntryRowStatus = set_value;
            if (ieee8021PSFPStreamGateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPStreamGateTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterCIR_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterCIR_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCIR: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCIR: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterCIR = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterCBS_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterCBS_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCBS: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCBS: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterCBS = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterEIR_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterEIR_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEIR: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEIR: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterEIR = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterEBS_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterEBS_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEBS: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEBS: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterEBS = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterCF_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterCF_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCF: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCF: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 1) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterCF = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterCM_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterCM_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCM: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCM: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterCM: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterCM = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterDropOnYellow_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterDropOnYellow_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterDropOnYellow: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterDropOnYellow: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterDropOnYellow: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterDropOnYellow = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterMarkAllFramesRedEnable_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterMarkAllFramesRedEnable_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRedEnable: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRedEnable: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRedEnable: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterMarkAllFramesRedEnable = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterMarkAllFramesRed_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterMarkAllFramesRed_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRed: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRed: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterMarkAllFramesRed: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterMarkAllFramesRed = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021PSFPFlowMeterEntryRowStatus_write()
/******************************************************************************/
int
ieee8021PSFPFlowMeterEntryRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PSFPFlowMeterTable_entry_t table_entry;
    static ieee8021PSFPFlowMeterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEntryRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEntryRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021PSFPFlowMeterEntryRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PSFPFlowMeterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PSFPFlowMeterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021PSFPFlowMeterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021PSFPFlowMeterEntryRowStatus = set_value;
            if (ieee8021PSFPFlowMeterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PSFPFlowMeterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

#endif /* defined(VKTBD) */

