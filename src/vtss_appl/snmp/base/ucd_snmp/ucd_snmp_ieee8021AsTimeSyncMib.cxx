/*
 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 Microchip is aware that some terminology used in this technical document is
 antiquated and inappropriate. As a result of the complex nature of software
 where seemingly simple changes have unpredictable, and often far-reaching
 negative results on the software's functionality (requiring extensive retesting
 and revalidation) we are unable to make the desired changes in all legacy
 systems without compromising our product or our clients' products.
*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ieee8021AsTimeSyncMib.h"
#include "ucd_snmp_ieee8021AsTimeSyncMib.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021ASTIMESYNCMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021ASTIMESYNCMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021ASTIMESYNCMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[IEEE8021ASTIMESYNCMIB_STR_LEN_MAX + 1];
    u_long              ulong_ret;
} ieee8021AsTimeSyncMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ieee8021AsTimeSyncMib_var;
FindVarMethod ieee8021AsPortDSIfTable_var;
FindVarMethod ieee8021AsPortStatIfTable_var;
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
FindVarMethod ieee8021AsAcceptableMasterTableDSMasterTable_var;
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
WriteMethod ieee8021AsDefaultDSPriority1_write;
WriteMethod ieee8021AsDefaultDSPriority2_write;
WriteMethod ieee8021AsParentDSGrandmasterPriority1_write;
WriteMethod ieee8021AsParentDSGrandmasterPriority2_write;
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
WriteMethod ieee8021AsAcceptableMasterTableDSActualTableSize_write;
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
WriteMethod ieee8021AsPortDSPttPortEnabled_write;
WriteMethod ieee8021AsPortDSNeighborPropDelayThreshHs_write;
WriteMethod ieee8021AsPortDSNeighborPropDelayThreshMs_write;
WriteMethod ieee8021AsPortDSNeighborPropDelayThreshLs_write;
WriteMethod ieee8021AsPortDSDelayAsymmetryHs_write;
WriteMethod ieee8021AsPortDSDelayAsymmetryMs_write;
WriteMethod ieee8021AsPortDSDelayAsymmetryLs_write;
WriteMethod ieee8021AsPortDSInitialLogAnnounceInterval_write;
WriteMethod ieee8021AsPortDSAnnounceReceiptTimeout_write;
WriteMethod ieee8021AsPortDSInitialLogSyncInterval_write;
WriteMethod ieee8021AsPortDSSyncReceiptTimeout_write;
WriteMethod ieee8021AsPortDSInitialLogPdelayReqInterval_write;
WriteMethod ieee8021AsPortDSAllowedLostResponses_write;
WriteMethod ieee8021AsPortDSNupMs_write;
WriteMethod ieee8021AsPortDSNupLs_write;
WriteMethod ieee8021AsPortDSNdownMs_write;
WriteMethod ieee8021AsPortDSNdownLs_write;
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
WriteMethod ieee8021AsPortDSAcceptableMasterTableEnabled_write;
WriteMethod ieee8021AsAcceptableMasterClockIdentity_write;
WriteMethod ieee8021AsAcceptableMasterPortNumber_write;
WriteMethod ieee8021AsAcceptableMasterAlternatePriority1_write;
WriteMethod ieee8021AsAcceptableMasterRowStatus_write;
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */

/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ieee8021AsTimeSyncMib_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021AsTimeSyncMib_ret_t ieee8021AsTimeSyncMib_global_ret;

/*
 * ieee8021AsTimeSyncMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ieee8021AsTimeSyncMib_variables_oid[] = {1,3,111,2,802,1,1,20};



/*
 * variable ieee8021AsTimeSyncMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021AsTimeSyncMib mib section
 */

struct variable7 ieee8021AsTimeSyncMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define IEEE8021ASDEFAULTDSCLOCKIDENTITY		1
    {IEEE8021ASDEFAULTDSCLOCKIDENTITY, ASN_OCTET_STR, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,1}},
#define IEEE8021ASDEFAULTDSNUMBERPORTS		2
    {IEEE8021ASDEFAULTDSNUMBERPORTS, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,2}},
#define IEEE8021ASDEFAULTDSCLOCKCLASS		3
    {IEEE8021ASDEFAULTDSCLOCKCLASS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,3}},
#define IEEE8021ASDEFAULTDSCLOCKACCURACY		4
    {IEEE8021ASDEFAULTDSCLOCKACCURACY, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,4}},
#define IEEE8021ASDEFAULTDSOFFSETSCALEDLOGVARIANCE		5
    {IEEE8021ASDEFAULTDSOFFSETSCALEDLOGVARIANCE, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,5}},
#define IEEE8021ASDEFAULTDSPRIORITY1		6
    {IEEE8021ASDEFAULTDSPRIORITY1, ASN_UNSIGNED, RWRITE, ieee8021AsTimeSyncMib_var, 3, {1,1,6}},
#define IEEE8021ASDEFAULTDSPRIORITY2		7
    {IEEE8021ASDEFAULTDSPRIORITY2, ASN_UNSIGNED, RWRITE, ieee8021AsTimeSyncMib_var, 3, {1,1,7}},
#define IEEE8021ASDEFAULTDSGMCAPABLE		8
    {IEEE8021ASDEFAULTDSGMCAPABLE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,8}},
#define IEEE8021ASDEFAULTDSCURRENTUTCOFFSET		9
    {IEEE8021ASDEFAULTDSCURRENTUTCOFFSET, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,9}},
#define IEEE8021ASDEFAULTDSCURRENTUTCOFFSETVALID		10
    {IEEE8021ASDEFAULTDSCURRENTUTCOFFSETVALID, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,10}},
#define IEEE8021ASDEFAULTDSLEAP59		11
    {IEEE8021ASDEFAULTDSLEAP59, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,11}},
#define IEEE8021ASDEFAULTDSLEAP61		12
    {IEEE8021ASDEFAULTDSLEAP61, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,12}},
#define IEEE8021ASDEFAULTDSTIMETRACEABLE		13
    {IEEE8021ASDEFAULTDSTIMETRACEABLE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,13}},
#define IEEE8021ASDEFAULTDSFREQUENCYTRACEABLE		14
    {IEEE8021ASDEFAULTDSFREQUENCYTRACEABLE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,14}},
#define IEEE8021ASDEFAULTDSTIMESOURCE		15
    {IEEE8021ASDEFAULTDSTIMESOURCE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,1,15}},
#define IEEE8021ASCURRENTDSSTEPSREMOVED		16
    {IEEE8021ASCURRENTDSSTEPSREMOVED, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,1}},
#define IEEE8021ASCURRENTDSOFFSETFROMMASTERHS		17
    {IEEE8021ASCURRENTDSOFFSETFROMMASTERHS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,2}},
#define IEEE8021ASCURRENTDSOFFSETFROMMASTERMS		18
    {IEEE8021ASCURRENTDSOFFSETFROMMASTERMS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,3}},
#define IEEE8021ASCURRENTDSOFFSETFROMMASTERLS		19
    {IEEE8021ASCURRENTDSOFFSETFROMMASTERLS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,4}},
#define IEEE8021ASCURRENTDSLASTGMPHASECHANGEHS		20
    {IEEE8021ASCURRENTDSLASTGMPHASECHANGEHS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,5}},
#define IEEE8021ASCURRENTDSLASTGMPHASECHANGEMS		21
    {IEEE8021ASCURRENTDSLASTGMPHASECHANGEMS, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,6}},
#define IEEE8021ASCURRENTDSLASTGMPHASECHANGELS		22
    {IEEE8021ASCURRENTDSLASTGMPHASECHANGELS, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,7}},
#define IEEE8021ASCURRENTDSLASTGMFREQCHANGEMS		23
    {IEEE8021ASCURRENTDSLASTGMFREQCHANGEMS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,8}},
#define IEEE8021ASCURRENTDSLASTGMFREQCHANGELS		24
    {IEEE8021ASCURRENTDSLASTGMFREQCHANGELS, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,9}},
#define IEEE8021ASCURRENTDSGMTIMEBASEINDICATOR		25
    {IEEE8021ASCURRENTDSGMTIMEBASEINDICATOR, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,10}},
#define IEEE8021ASCURRENTDSGMCHANGECOUNT		26
    {IEEE8021ASCURRENTDSGMCHANGECOUNT, ASN_COUNTER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,11}},
#define IEEE8021ASCURRENTDSTIMEOFLASTGMCHANGEEVENT		27
    {IEEE8021ASCURRENTDSTIMEOFLASTGMCHANGEEVENT, ASN_TIMETICKS, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,12}},
#define IEEE8021ASCURRENTDSTIMEOFLASTGMFREQCHANGEEVENT		28
    {IEEE8021ASCURRENTDSTIMEOFLASTGMFREQCHANGEEVENT, ASN_TIMETICKS, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,13}},
#define IEEE8021ASCURRENTDSTIMEOFLASTGMPHASECHANGEEVENT		29
    {IEEE8021ASCURRENTDSTIMEOFLASTGMPHASECHANGEEVENT, ASN_TIMETICKS, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,2,14}},
#define IEEE8021ASPARENTDSPARENTCLOCKIDENTITY		30
    {IEEE8021ASPARENTDSPARENTCLOCKIDENTITY, ASN_OCTET_STR, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,1}},
#define IEEE8021ASPARENTDSPARENTPORTNUMBER		31
    {IEEE8021ASPARENTDSPARENTPORTNUMBER, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,2}},
#define IEEE8021ASPARENTDSCUMLATIVERATERATIO		32
    {IEEE8021ASPARENTDSCUMLATIVERATERATIO, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,3}},
#define IEEE8021ASPARENTDSGRANDMASTERIDENTITY		33
    {IEEE8021ASPARENTDSGRANDMASTERIDENTITY, ASN_OCTET_STR, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,4}},
#define IEEE8021ASPARENTDSGRANDMASTERCLOCKCLASS		34
    {IEEE8021ASPARENTDSGRANDMASTERCLOCKCLASS, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,5}},
#define IEEE8021ASPARENTDSGRANDMASTERCLOCKACCURACY		35
    {IEEE8021ASPARENTDSGRANDMASTERCLOCKACCURACY, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,6}},
#define IEEE8021ASPARENTDSGRANDMASTEROFFSETSCALEDLOGVARIANCE		36
    {IEEE8021ASPARENTDSGRANDMASTEROFFSETSCALEDLOGVARIANCE, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,3,7}},
#define IEEE8021ASPARENTDSGRANDMASTERPRIORITY1		37
    {IEEE8021ASPARENTDSGRANDMASTERPRIORITY1, ASN_UNSIGNED, RWRITE, ieee8021AsTimeSyncMib_var, 3, {1,3,8}},
#define IEEE8021ASPARENTDSGRANDMASTERPRIORITY2		38
    {IEEE8021ASPARENTDSGRANDMASTERPRIORITY2, ASN_UNSIGNED, RWRITE, ieee8021AsTimeSyncMib_var, 3, {1,3,9}},
#define IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSET		39
    {IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSET, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,1}},
#define IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSETVALID		40
    {IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSETVALID, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,2}},
#define IEEE8021ASTIMEPROPERTIESDSLEAP59		41
    {IEEE8021ASTIMEPROPERTIESDSLEAP59, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,3}},
#define IEEE8021ASTIMEPROPERTIESDSLEAP61		42
    {IEEE8021ASTIMEPROPERTIESDSLEAP61, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,4}},
#define IEEE8021ASTIMEPROPERTIESDSTIMETRACEABLE		43
    {IEEE8021ASTIMEPROPERTIESDSTIMETRACEABLE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,5}},
#define IEEE8021ASTIMEPROPERTIESDSFREQUENCYTRACEABLE		44
    {IEEE8021ASTIMEPROPERTIESDSFREQUENCYTRACEABLE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,6}},
#define IEEE8021ASTIMEPROPERTIESDSTIMESOURCE		45
    {IEEE8021ASTIMEPROPERTIESDSTIMESOURCE, ASN_INTEGER, RONLY, ieee8021AsTimeSyncMib_var, 3, {1,4,7}},
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
#define IEEE8021ASACCEPTABLEMASTERTABLEDSMAXTABLESIZE		46
    {IEEE8021ASACCEPTABLEMASTERTABLEDSMAXTABLESIZE, ASN_UNSIGNED, RONLY, ieee8021AsTimeSyncMib_var, 4, {1,7,1,1}},
#define IEEE8021ASACCEPTABLEMASTERTABLEDSACTUALTABLESIZE		47
    {IEEE8021ASACCEPTABLEMASTERTABLEDSACTUALTABLESIZE, ASN_UNSIGNED, RWRITE, ieee8021AsTimeSyncMib_var, 4, {1,7,1,2}},
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
#define IEEE8021ASPORTDSCLOCKIDENTITY		48
    {IEEE8021ASPORTDSCLOCKIDENTITY, ASN_OCTET_STR, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 3}},
#define IEEE8021ASPORTDSPORTNUMBER		49
    {IEEE8021ASPORTDSPORTNUMBER, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 4}},
#define IEEE8021ASPORTDSPORTROLE		50
    {IEEE8021ASPORTDSPORTROLE, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 5}},
#define IEEE8021ASPORTDSPTTPORTENABLED		51
    {IEEE8021ASPORTDSPTTPORTENABLED, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 6}},
#define IEEE8021ASPORTDSISMEASURINGDELAY		52
    {IEEE8021ASPORTDSISMEASURINGDELAY, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 7}},
#define IEEE8021ASPORTDSASCAPABLE		53
    {IEEE8021ASPORTDSASCAPABLE, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 8}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYHS		54
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYHS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 9}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYMS		55
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYMS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 10}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYLS		56
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYLS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 11}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHHS		57
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHHS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 12}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHMS		58
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHMS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 13}},
#define IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHLS		59
    {IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHLS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 14}},
#define IEEE8021ASPORTDSDELAYASYMMETRYHS		60
    {IEEE8021ASPORTDSDELAYASYMMETRYHS, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 15}},
#define IEEE8021ASPORTDSDELAYASYMMETRYMS		61
    {IEEE8021ASPORTDSDELAYASYMMETRYMS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 16}},
#define IEEE8021ASPORTDSDELAYASYMMETRYLS		62
    {IEEE8021ASPORTDSDELAYASYMMETRYLS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 17}},
#define IEEE8021ASPORTDSNEIGHBORRATERATIO		63
    {IEEE8021ASPORTDSNEIGHBORRATERATIO, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 18}},
#define IEEE8021ASPORTDSINITIALLOGANNOUNCEINTERVAL		64
    {IEEE8021ASPORTDSINITIALLOGANNOUNCEINTERVAL, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 19}},
#define IEEE8021ASPORTDSCURRENTLOGANNOUNCEINTERVAL		65
    {IEEE8021ASPORTDSCURRENTLOGANNOUNCEINTERVAL, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 20}},
#define IEEE8021ASPORTDSANNOUNCERECEIPTTIMEOUT		66
    {IEEE8021ASPORTDSANNOUNCERECEIPTTIMEOUT, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 21}},
#define IEEE8021ASPORTDSINITIALLOGSYNCINTERVAL		67
    {IEEE8021ASPORTDSINITIALLOGSYNCINTERVAL, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 22}},
#define IEEE8021ASPORTDSCURRENTLOGSYNCINTERVAL		68
    {IEEE8021ASPORTDSCURRENTLOGSYNCINTERVAL, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 23}},
#define IEEE8021ASPORTDSSYNCRECEIPTTIMEOUT		69
    {IEEE8021ASPORTDSSYNCRECEIPTTIMEOUT, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 24}},
#define IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALHS		70
    {IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALHS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 25}},
#define IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALMS		71
    {IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALMS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 26}},
#define IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALLS		72
    {IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALLS, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 27}},
#define IEEE8021ASPORTDSINITIALLOGPDELAYREQINTERVAL		73
    {IEEE8021ASPORTDSINITIALLOGPDELAYREQINTERVAL, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 28}},
#define IEEE8021ASPORTDSCURRENTLOGPDELAYREQINTERVAL		74
    {IEEE8021ASPORTDSCURRENTLOGPDELAYREQINTERVAL, ASN_INTEGER, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 29}},
#define IEEE8021ASPORTDSALLOWEDLOSTRESPONSES		75
    {IEEE8021ASPORTDSALLOWEDLOSTRESPONSES, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 30}},
#define IEEE8021ASPORTDSVERSIONNUMBER		76
    {IEEE8021ASPORTDSVERSIONNUMBER, ASN_UNSIGNED, RONLY, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 31}},
#define IEEE8021ASPORTDSNUPMS		77
    {IEEE8021ASPORTDSNUPMS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 32}},
#define IEEE8021ASPORTDSNUPLS		78
    {IEEE8021ASPORTDSNUPLS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 33}},
#define IEEE8021ASPORTDSNDOWNMS		79
    {IEEE8021ASPORTDSNDOWNMS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 34}},
#define IEEE8021ASPORTDSNDOWNLS		80
    {IEEE8021ASPORTDSNDOWNLS, ASN_UNSIGNED, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 35}},
#define IEEE8021ASPORTDSACCEPTABLEMASTERTABLEENABLED		81
    {IEEE8021ASPORTDSACCEPTABLEMASTERTABLEENABLED, ASN_INTEGER, RWRITE, ieee8021AsPortDSIfTable_var, 4, {1,5, 1, 36}},
#define IEEE8021ASPORTSTATRXSYNCCOUNT		82
    {IEEE8021ASPORTSTATRXSYNCCOUNT, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 1}},
#define IEEE8021ASPORTSTATRXFOLLOWUPCOUNT		83
    {IEEE8021ASPORTSTATRXFOLLOWUPCOUNT, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 2}},
#define IEEE8021ASPORTSTATRXPDELAYREQUEST		84
    {IEEE8021ASPORTSTATRXPDELAYREQUEST, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 3}},
#define IEEE8021ASPORTSTATRXPDELAYRESPONSE		85
    {IEEE8021ASPORTSTATRXPDELAYRESPONSE, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 4}},
#define IEEE8021ASPORTSTATRXPDELAYRESPONSEFOLLOWUP		86
    {IEEE8021ASPORTSTATRXPDELAYRESPONSEFOLLOWUP, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 5}},
#define IEEE8021ASPORTSTATRXANNOUNCE		87
    {IEEE8021ASPORTSTATRXANNOUNCE, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 6}},
#define IEEE8021ASPORTSTATRXPTPPACKETDISCARD		88
    {IEEE8021ASPORTSTATRXPTPPACKETDISCARD, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 7}},
#define IEEE8021ASPORTSTATRXSYNCRECEIPTTIMEOUTS		89
    {IEEE8021ASPORTSTATRXSYNCRECEIPTTIMEOUTS, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 8}},
#define IEEE8021ASPORTSTATANNOUNCERECEIPTTIMEOUTS		90
    {IEEE8021ASPORTSTATANNOUNCERECEIPTTIMEOUTS, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 9}},
#define IEEE8021ASPORTSTATPDELAYALLOWEDLOSTRESPONSESEXCEEDED		91
    {IEEE8021ASPORTSTATPDELAYALLOWEDLOSTRESPONSESEXCEEDED, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 10}},
#define IEEE8021ASPORTSTATTXSYNCCOUNT		92
    {IEEE8021ASPORTSTATTXSYNCCOUNT, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 11}},
#define IEEE8021ASPORTSTATTXFOLLOWUPCOUNT		93
    {IEEE8021ASPORTSTATTXFOLLOWUPCOUNT, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 12}},
#define IEEE8021ASPORTSTATTXPDELAYREQUEST		94
    {IEEE8021ASPORTSTATTXPDELAYREQUEST, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 13}},
#define IEEE8021ASPORTSTATTXPDELAYRESPONSE		95
    {IEEE8021ASPORTSTATTXPDELAYRESPONSE, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 14}},
#define IEEE8021ASPORTSTATTXPDELAYRESPONSEFOLLOWUP		96
    {IEEE8021ASPORTSTATTXPDELAYRESPONSEFOLLOWUP, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 15}},
#define IEEE8021ASPORTSTATTXANNOUNCE		97
    {IEEE8021ASPORTSTATTXANNOUNCE, ASN_COUNTER, RONLY, ieee8021AsPortStatIfTable_var, 4, {1,6, 1, 16}},
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
#define IEEE8021ASACCEPTABLEMASTERCLOCKIDENTITY		98
    {IEEE8021ASACCEPTABLEMASTERCLOCKIDENTITY, ASN_OCTET_STR, RWRITE, ieee8021AsAcceptableMasterTableDSMasterTable_var, 6, {1,7,2,1, 1, 2}},
#define IEEE8021ASACCEPTABLEMASTERPORTNUMBER		99
    {IEEE8021ASACCEPTABLEMASTERPORTNUMBER, ASN_UNSIGNED, RWRITE, ieee8021AsAcceptableMasterTableDSMasterTable_var, 6, {1,7,2,1, 1, 3}},
#define IEEE8021ASACCEPTABLEMASTERALTERNATEPRIORITY1		100
    {IEEE8021ASACCEPTABLEMASTERALTERNATEPRIORITY1, ASN_UNSIGNED, RWRITE, ieee8021AsAcceptableMasterTableDSMasterTable_var, 6, {1,7,2,1, 1, 4}},
#define IEEE8021ASACCEPTABLEMASTERROWSTATUS		101
    {IEEE8021ASACCEPTABLEMASTERROWSTATUS, ASN_INTEGER, RWRITE, ieee8021AsAcceptableMasterTableDSMasterTable_var, 6, {1,7,2,1, 1, 5}},
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
};


/******************************************************************************/
// ucd_snmp_init_ieee8021AsTimeSyncMib()
// Initializes the UCD-SNMP-part of the IEEE8021-AS-MIB:ieee8021AsTimeSyncMib.
/******************************************************************************/
void ucd_snmp_init_ieee8021AsTimeSyncMib(void)
{
    DEBUGMSGTL(("ieee8021AsTimeSyncMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021AsTimeSyncMib", ieee8021AsTimeSyncMib_variables, variable7, ieee8021AsTimeSyncMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021AsTimeSyncMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ieee8021AsTimeSyncMib_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{
    ieee8021AsDefaultDS_scalar_t ieee8021AsDefaultDS_scalar_entry;
    ieee8021AsCurrentDS_scalar_t ieee8021AsCurrentDS_scalar_entry;
    ieee8021AsParentDS_scalar_t ieee8021AsParentDS_scalar_entry;
    ieee8021AsTimePropertiesDS_scalar_t ieee8021AsTimePropertiesDS_scalar_entry;
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    ieee8021AsAcceptableMasterTableDSBase_scalar_t ieee8021AsAcceptableMasterTableDSBase_scalar_entry;
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (ieee8021AsDefaultDSScalar_get(&ieee8021AsDefaultDS_scalar_entry)) {
        return NULL;
    }
    if (ieee8021AsCurrentDSScalar_get(&ieee8021AsCurrentDS_scalar_entry)) {
        return NULL;
    }
    if (ieee8021AsParentDSScalar_get(&ieee8021AsParentDS_scalar_entry)) {
        return NULL;
    }
    if (ieee8021AsTimePropertiesDSScalar_get(&ieee8021AsTimePropertiesDS_scalar_entry)) {
        return NULL;
    }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    if (ieee8021AsAcceptableMasterTableDSBaseScalar_get(&ieee8021AsAcceptableMasterTableDSBase_scalar_entry)) {
        return NULL;
    }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021ASDEFAULTDSCLOCKIDENTITY: {
        *var_len = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSClockIdentity_len;
        memcpy(ieee8021AsTimeSyncMib_global_ret.string_ret, ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSClockIdentity, *var_len);
        ieee8021AsTimeSyncMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021AsTimeSyncMib_global_ret.string_ret;
    }
    case IEEE8021ASDEFAULTDSNUMBERPORTS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSNumberPorts;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASDEFAULTDSCLOCKCLASS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSClockClass;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSCLOCKACCURACY: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSClockAccuracy;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSOFFSETSCALEDLOGVARIANCE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSOffsetScaledLogVariance;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASDEFAULTDSPRIORITY1: {
        *write_method = ieee8021AsDefaultDSPriority1_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSPriority1;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASDEFAULTDSPRIORITY2: {
        *write_method = ieee8021AsDefaultDSPriority2_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSPriority2;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASDEFAULTDSGMCAPABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSGmCapable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSCURRENTUTCOFFSET: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSCurrentUTCOffset;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSCURRENTUTCOFFSETVALID: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSCurrentUTCOffsetValid;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSLEAP59: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSLeap59;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSLEAP61: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSLeap61;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSTIMETRACEABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSTimeTraceable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSFREQUENCYTRACEABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSFrequencyTraceable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASDEFAULTDSTIMESOURCE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsDefaultDS_scalar_entry.ieee8021AsDefaultDSTimeSource;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSSTEPSREMOVED: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSStepsRemoved;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSOFFSETFROMMASTERHS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSOffsetFromMasterHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSOFFSETFROMMASTERMS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSOffsetFromMasterMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSOFFSETFROMMASTERLS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSOffsetFromMasterLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSLASTGMPHASECHANGEHS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSLastGmPhaseChangeHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSLASTGMPHASECHANGEMS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSLastGmPhaseChangeMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSLASTGMPHASECHANGELS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSLastGmPhaseChangeLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSLASTGMFREQCHANGEMS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSLastGmFreqChangeMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASCURRENTDSLASTGMFREQCHANGELS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSLastGmFreqChangeLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSGMTIMEBASEINDICATOR: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSGmTimebaseIndicator;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSGMCHANGECOUNT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSGmChangeCount;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSTIMEOFLASTGMCHANGEEVENT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSTimeOfLastGmChangeEvent;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSTIMEOFLASTGMFREQCHANGEEVENT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASCURRENTDSTIMEOFLASTGMPHASECHANGEEVENT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsCurrentDS_scalar_entry.ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPARENTDSPARENTCLOCKIDENTITY: {
        *var_len = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSParentClockIdentity_len;
        memcpy(ieee8021AsTimeSyncMib_global_ret.string_ret, ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSParentClockIdentity, *var_len);
        ieee8021AsTimeSyncMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021AsTimeSyncMib_global_ret.string_ret;
    }
    case IEEE8021ASPARENTDSPARENTPORTNUMBER: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSParentPortNumber;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPARENTDSCUMLATIVERATERATIO: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSCumlativeRateRatio;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTERIDENTITY: {
        *var_len = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterIdentity_len;
        memcpy(ieee8021AsTimeSyncMib_global_ret.string_ret, ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterIdentity, *var_len);
        ieee8021AsTimeSyncMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021AsTimeSyncMib_global_ret.string_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTERCLOCKCLASS: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterClockClass;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTERCLOCKACCURACY: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterClockAccuracy;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTEROFFSETSCALEDLOGVARIANCE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterOffsetScaledLogVariance;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTERPRIORITY1: {
        *write_method = ieee8021AsParentDSGrandmasterPriority1_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterPriority1;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPARENTDSGRANDMASTERPRIORITY2: {
        *write_method = ieee8021AsParentDSGrandmasterPriority2_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsParentDS_scalar_entry.ieee8021AsParentDSGrandmasterPriority2;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSET: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSCurrentUtcOffset;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSCURRENTUTCOFFSETVALID: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSCurrentUtcOffsetValid;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSLEAP59: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSLeap59;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSLEAP61: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSLeap61;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSTIMETRACEABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSTimeTraceable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSFREQUENCYTRACEABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSFrequencyTraceable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASTIMEPROPERTIESDSTIMESOURCE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = ieee8021AsTimePropertiesDS_scalar_entry.ieee8021AsTimePropertiesDSTimeSource;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    case IEEE8021ASACCEPTABLEMASTERTABLEDSMAXTABLESIZE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsAcceptableMasterTableDSBase_scalar_entry.ieee8021AsAcceptableMasterTableDSMaxTableSize;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASACCEPTABLEMASTERTABLEDSACTUALTABLESIZE: {
        *write_method = ieee8021AsAcceptableMasterTableDSActualTableSize_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = ieee8021AsAcceptableMasterTableDSBase_scalar_entry.ieee8021AsAcceptableMasterTableDSActualTableSize;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021AsTimeSyncMib_var\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021AsPortDSIfTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021AsPortDSIfTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021AsPortDSIfTable_entry_t *table_entry)
{
    size_t  op_pos = 10 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021AsPortDSIfTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021AsBridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021AsPortDSAsIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021AsPortDSIfTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021AsPortDSIfTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021AsPortDSIfTable_entry_t *table_entry)
{
    int     name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021AsBridgeBasePort;
    name[name_pos++] = (oid) table_entry->ieee8021AsPortDSAsIfIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021AsPortDSIfTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021AsTimeSyncMib_var above.
 */
u_char *
ieee8021AsPortDSIfTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021AsPortDSIfTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021AsPortDSIfTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021AsPortDSIfTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021AsPortDSIfTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021AsPortDSIfTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021ASPORTDSCLOCKIDENTITY: {
        *var_len = table_entry.ieee8021AsPortDSClockIdentity_len;
        memcpy(ieee8021AsTimeSyncMib_global_ret.string_ret, table_entry.ieee8021AsPortDSClockIdentity, *var_len);
        ieee8021AsTimeSyncMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021AsTimeSyncMib_global_ret.string_ret;
    }
    case IEEE8021ASPORTDSPORTNUMBER: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSPortNumber;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSPORTROLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSPortRole;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSPTTPORTENABLED: {
        *write_method = ieee8021AsPortDSPttPortEnabled_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSPttPortEnabled;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSISMEASURINGDELAY: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSIsMeasuringDelay;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSASCAPABLE: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSAsCapable;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYHS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYMS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYLS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHHS: {
        *write_method = ieee8021AsPortDSNeighborPropDelayThreshHs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayThreshHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHMS: {
        *write_method = ieee8021AsPortDSNeighborPropDelayThreshMs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayThreshMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORPROPDELAYTHRESHLS: {
        *write_method = ieee8021AsPortDSNeighborPropDelayThreshLs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNeighborPropDelayThreshLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSDELAYASYMMETRYHS: {
        *write_method = ieee8021AsPortDSDelayAsymmetryHs_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSDelayAsymmetryHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSDELAYASYMMETRYMS: {
        *write_method = ieee8021AsPortDSDelayAsymmetryMs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSDelayAsymmetryMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSDELAYASYMMETRYLS: {
        *write_method = ieee8021AsPortDSDelayAsymmetryLs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSDelayAsymmetryLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNEIGHBORRATERATIO: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSNeighborRateRatio;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSINITIALLOGANNOUNCEINTERVAL: {
        *write_method = ieee8021AsPortDSInitialLogAnnounceInterval_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSInitialLogAnnounceInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSCURRENTLOGANNOUNCEINTERVAL: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSCurrentLogAnnounceInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSANNOUNCERECEIPTTIMEOUT: {
        *write_method = ieee8021AsPortDSAnnounceReceiptTimeout_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSAnnounceReceiptTimeout;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSINITIALLOGSYNCINTERVAL: {
        *write_method = ieee8021AsPortDSInitialLogSyncInterval_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSInitialLogSyncInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSCURRENTLOGSYNCINTERVAL: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSCurrentLogSyncInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSSYNCRECEIPTTIMEOUT: {
        *write_method = ieee8021AsPortDSSyncReceiptTimeout_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSSyncReceiptTimeout;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALHS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALMS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSSYNCRECEIPTTIMEOUTTIMEINTERVALLS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSINITIALLOGPDELAYREQINTERVAL: {
        *write_method = ieee8021AsPortDSInitialLogPdelayReqInterval_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSInitialLogPdelayReqInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSCURRENTLOGPDELAYREQINTERVAL: {
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSCurrentLogPdelayReqInterval;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    case IEEE8021ASPORTDSALLOWEDLOSTRESPONSES: {
        *write_method = ieee8021AsPortDSAllowedLostResponses_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSAllowedLostResponses;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSVERSIONNUMBER: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSVersionNumber;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNUPMS: {
        *write_method = ieee8021AsPortDSNupMs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNupMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNUPLS: {
        *write_method = ieee8021AsPortDSNupLs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNupLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNDOWNMS: {
        *write_method = ieee8021AsPortDSNdownMs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNdownMs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTDSNDOWNLS: {
        *write_method = ieee8021AsPortDSNdownLs_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortDSNdownLs;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    case IEEE8021ASPORTDSACCEPTABLEMASTERTABLEENABLED: {
        *write_method = ieee8021AsPortDSAcceptableMasterTableEnabled_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsPortDSAcceptableMasterTableEnabled;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021AsPortDSIfTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021AsPortStatIfTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021AsPortStatIfTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021AsPortStatIfTable_entry_t *table_entry)
{
    size_t  op_pos = 10 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021AsPortStatIfTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021AsBridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021AsPortDSAsIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021AsPortStatIfTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021AsPortStatIfTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021AsPortStatIfTable_entry_t *table_entry)
{
    int     name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021AsBridgeBasePort;
    name[name_pos++] = (oid) table_entry->ieee8021AsPortDSAsIfIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021AsPortStatIfTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021AsTimeSyncMib_var above.
 */
u_char *
ieee8021AsPortStatIfTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021AsPortStatIfTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021AsPortStatIfTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021AsPortStatIfTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021AsPortStatIfTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021AsPortStatIfTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021ASPORTSTATRXSYNCCOUNT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxSyncCount;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXFOLLOWUPCOUNT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxFollowUpCount;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXPDELAYREQUEST: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxPdelayRequest;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXPDELAYRESPONSE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxPdelayResponse;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXPDELAYRESPONSEFOLLOWUP: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxPdelayResponseFollowUp;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXANNOUNCE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxAnnounce;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXPTPPACKETDISCARD: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxPTPPacketDiscard;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATRXSYNCRECEIPTTIMEOUTS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatRxSyncReceiptTimeouts;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATANNOUNCERECEIPTTIMEOUTS: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatAnnounceReceiptTimeouts;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATPDELAYALLOWEDLOSTRESPONSESEXCEEDED: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatPdelayAllowedLostResponsesExceeded;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXSYNCCOUNT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxSyncCount;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXFOLLOWUPCOUNT: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxFollowUpCount;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXPDELAYREQUEST: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxPdelayRequest;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXPDELAYRESPONSE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxPdelayResponse;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXPDELAYRESPONSEFOLLOWUP: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxPdelayResponseFollowUp;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASPORTSTATTXANNOUNCE: {
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsPortStatTxAnnounce;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021AsPortStatIfTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021AsAcceptableMasterTableDSMasterTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
static int
ieee8021AsAcceptableMasterTableDSMasterTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *table_entry)
{
    size_t  op_pos = 12 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (12 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021AsAcceptableMasterTableDSMasterId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}


/******************************************************************************/
// ieee8021AsAcceptableMasterTableDSMasterTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021AsAcceptableMasterTableDSMasterTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *table_entry)
{
    int     name_pos = 12 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021AsAcceptableMasterTableDSMasterId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021AsAcceptableMasterTableDSMasterTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021AsTimeSyncMib_var above.
 */
u_char *
ieee8021AsAcceptableMasterTableDSMasterTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021AsAcceptableMasterTableDSMasterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021AsAcceptableMasterTableDSMasterTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021AsAcceptableMasterTableDSMasterTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021ASACCEPTABLEMASTERROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ieee8021AsAcceptableMasterRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021ASACCEPTABLEMASTERCLOCKIDENTITY: {
        *write_method = ieee8021AsAcceptableMasterClockIdentity_write;
        *var_len = table_entry.ieee8021AsAcceptableMasterClockIdentity_len;
        memcpy(ieee8021AsTimeSyncMib_global_ret.string_ret, table_entry.ieee8021AsAcceptableMasterClockIdentity, *var_len);
        ieee8021AsTimeSyncMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021AsTimeSyncMib_global_ret.string_ret;
    }
    case IEEE8021ASACCEPTABLEMASTERPORTNUMBER: {
        *write_method = ieee8021AsAcceptableMasterPortNumber_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsAcceptableMasterPortNumber;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASACCEPTABLEMASTERALTERNATEPRIORITY1: {
        *write_method = ieee8021AsAcceptableMasterAlternatePriority1_write;
        ieee8021AsTimeSyncMib_global_ret.ulong_ret = table_entry.ieee8021AsAcceptableMasterAlternatePriority1;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.ulong_ret;
    }
    case IEEE8021ASACCEPTABLEMASTERROWSTATUS: {
        *write_method = ieee8021AsAcceptableMasterRowStatus_write;
        ieee8021AsTimeSyncMib_global_ret.long_ret = table_entry.ieee8021AsAcceptableMasterRowStatus;
        *var_len = sizeof(ieee8021AsTimeSyncMib_global_ret.long_ret);
        return (u_char *) &ieee8021AsTimeSyncMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021AsAcceptableMasterTableDSMasterTable\n", vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */

/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021AsDefaultDSPriority1_write()
/******************************************************************************/
int
ieee8021AsDefaultDSPriority1_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsDefaultDS_scalar_t scalar_entry;
#endif
    static ieee8021AsDefaultDS_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsDefaultDSPriority1: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsDefaultDSPriority1: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if (((old_scalar_entry_p = (ieee8021AsDefaultDS_scalar_t*)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ieee8021AsDefaultDSScalar_get(old_scalar_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case ACTION: {
            // Set new configuration
            scalar_entry.ieee8021AsDefaultDSPriority1 = set_value;
            if (ieee8021AsDefaultDSScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsDefaultDSScalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsDefaultDSPriority2_write()
/******************************************************************************/
int
ieee8021AsDefaultDSPriority2_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsDefaultDS_scalar_t scalar_entry;
#endif
    static ieee8021AsDefaultDS_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsDefaultDSPriority2: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsDefaultDSPriority2: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if (((old_scalar_entry_p = (ieee8021AsDefaultDS_scalar_t*)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ieee8021AsDefaultDSScalar_get(old_scalar_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case ACTION: {
            // Set new configuration
            scalar_entry.ieee8021AsDefaultDSPriority2 = set_value;
            if (ieee8021AsDefaultDSScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsDefaultDSScalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsParentDSGrandmasterPriority1_write()
/******************************************************************************/
int
ieee8021AsParentDSGrandmasterPriority1_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsParentDS_scalar_t scalar_entry;
#endif
    static ieee8021AsParentDS_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsParentDSGrandmasterPriority1: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsParentDSGrandmasterPriority1: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if (((old_scalar_entry_p = (ieee8021AsParentDS_scalar_t*)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ieee8021AsParentDSScalar_get(old_scalar_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case ACTION: {
            // Set new configuration
            scalar_entry.ieee8021AsParentDSGrandmasterPriority1 = set_value;
            if (ieee8021AsParentDSScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsParentDSScalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsParentDSGrandmasterPriority2_write()
/******************************************************************************/
int
ieee8021AsParentDSGrandmasterPriority2_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsParentDS_scalar_t scalar_entry;
#endif
    static ieee8021AsParentDS_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsParentDSGrandmasterPriority2: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsParentDSGrandmasterPriority2: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if (((old_scalar_entry_p = (ieee8021AsParentDS_scalar_t*)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ieee8021AsParentDSScalar_get(old_scalar_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case ACTION: {
            // Set new configuration
            scalar_entry.ieee8021AsParentDSGrandmasterPriority2 = set_value;
            if (ieee8021AsParentDSScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsParentDSScalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021AsAcceptableMasterTableDSActualTableSize_write()
/******************************************************************************/
int
ieee8021AsAcceptableMasterTableDSActualTableSize_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsAcceptableMasterTableDSBase_scalar_t scalar_entry;
    static ieee8021AsAcceptableMasterTableDSBase_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterTableDSActualTableSize: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterTableDSActualTableSize: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 65535) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if (((old_scalar_entry_p = (ieee8021AsAcceptableMasterTableDSBase_scalar_t*)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ieee8021AsAcceptableMasterTableDSBaseScalar_get(old_scalar_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
# endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
            }
            break;
        }
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
        case ACTION: {
            // Set new configuration
            scalar_entry.ieee8021AsAcceptableMasterTableDSActualTableSize = set_value;
            if (ieee8021AsAcceptableMasterTableDSBaseScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsAcceptableMasterTableDSBaseScalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */

/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021AsPortDSPttPortEnabled_write()
/******************************************************************************/
int
ieee8021AsPortDSPttPortEnabled_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSPttPortEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSPttPortEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSPttPortEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSPttPortEnabled = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNeighborPropDelayThreshHs_write()
/******************************************************************************/
int
ieee8021AsPortDSNeighborPropDelayThreshHs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshHs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshHs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNeighborPropDelayThreshHs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNeighborPropDelayThreshMs_write()
/******************************************************************************/
int
ieee8021AsPortDSNeighborPropDelayThreshMs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshMs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshMs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNeighborPropDelayThreshMs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNeighborPropDelayThreshLs_write()
/******************************************************************************/
int
ieee8021AsPortDSNeighborPropDelayThreshLs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshLs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNeighborPropDelayThreshLs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNeighborPropDelayThreshLs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSDelayAsymmetryHs_write()
/******************************************************************************/
int
ieee8021AsPortDSDelayAsymmetryHs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryHs: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryHs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSDelayAsymmetryHs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSDelayAsymmetryMs_write()
/******************************************************************************/
int
ieee8021AsPortDSDelayAsymmetryMs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryMs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryMs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSDelayAsymmetryMs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSDelayAsymmetryLs_write()
/******************************************************************************/
int
ieee8021AsPortDSDelayAsymmetryLs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryLs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSDelayAsymmetryLs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSDelayAsymmetryLs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSInitialLogAnnounceInterval_write()
/******************************************************************************/
int
ieee8021AsPortDSInitialLogAnnounceInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogAnnounceInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogAnnounceInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -128 || set_value > 127) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSInitialLogAnnounceInterval = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSAnnounceReceiptTimeout_write()
/******************************************************************************/
int
ieee8021AsPortDSAnnounceReceiptTimeout_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAnnounceReceiptTimeout: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAnnounceReceiptTimeout: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSAnnounceReceiptTimeout = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSInitialLogSyncInterval_write()
/******************************************************************************/
int
ieee8021AsPortDSInitialLogSyncInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogSyncInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogSyncInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -128 || set_value > 127) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSInitialLogSyncInterval = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSSyncReceiptTimeout_write()
/******************************************************************************/
int
ieee8021AsPortDSSyncReceiptTimeout_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSSyncReceiptTimeout: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSSyncReceiptTimeout: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSSyncReceiptTimeout = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSInitialLogPdelayReqInterval_write()
/******************************************************************************/
int
ieee8021AsPortDSInitialLogPdelayReqInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogPdelayReqInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSInitialLogPdelayReqInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -128 || set_value > 127) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSInitialLogPdelayReqInterval = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSAllowedLostResponses_write()
/******************************************************************************/
int
ieee8021AsPortDSAllowedLostResponses_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAllowedLostResponses: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAllowedLostResponses: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 65535) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSAllowedLostResponses = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNupMs_write()
/******************************************************************************/
int
ieee8021AsPortDSNupMs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNupMs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNupMs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNupMs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNupLs_write()
/******************************************************************************/
int
ieee8021AsPortDSNupLs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNupLs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNupLs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNupLs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNdownMs_write()
/******************************************************************************/
int
ieee8021AsPortDSNdownMs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNdownMs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNdownMs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNdownMs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsPortDSNdownLs_write()
/******************************************************************************/
int
ieee8021AsPortDSNdownLs_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNdownLs: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSNdownLs: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSNdownLs = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#if IEEE8021AsTimeSyncMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021AsPortDSAcceptableMasterTableEnabled_write()
/******************************************************************************/
int
ieee8021AsPortDSAcceptableMasterTableEnabled_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsPortDSIfTable_entry_t table_entry;
    static ieee8021AsPortDSIfTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAcceptableMasterTableEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAcceptableMasterTableEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsPortDSAcceptableMasterTableEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsPortDSIfTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsPortDSIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsPortDSAcceptableMasterTableEnabled = set_value;
            if (ieee8021AsPortDSIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsPortDSIfTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsAcceptableMasterClockIdentity_write()
/******************************************************************************/
int
ieee8021AsAcceptableMasterClockIdentity_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021AsAcceptableMasterTableDSMasterTable_entry_t table_entry;
    static ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterClockIdentity: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021ASTIMESYNCMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterClockIdentity: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 8) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsAcceptableMasterTableDSMasterTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021AsAcceptableMasterClockIdentity, var_val, var_val_len);
            table_entry.ieee8021AsAcceptableMasterClockIdentity_len = var_val_len;
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsAcceptableMasterPortNumber_write()
/******************************************************************************/
int
ieee8021AsAcceptableMasterPortNumber_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsAcceptableMasterTableDSMasterTable_entry_t table_entry;
    static ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterPortNumber: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterPortNumber: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 65535) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsAcceptableMasterTableDSMasterTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsAcceptableMasterPortNumber = set_value;
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsAcceptableMasterAlternatePriority1_write()
/******************************************************************************/
int
ieee8021AsAcceptableMasterAlternatePriority1_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021AsAcceptableMasterTableDSMasterTable_entry_t table_entry;
    static ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterAlternatePriority1: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterAlternatePriority1: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsAcceptableMasterTableDSMasterTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsAcceptableMasterAlternatePriority1 = set_value;
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021AsAcceptableMasterRowStatus_write()
/******************************************************************************/
int
ieee8021AsAcceptableMasterRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021AsAcceptableMasterTableDSMasterTable_entry_t table_entry;
    static ieee8021AsAcceptableMasterTableDSMasterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021AsAcceptableMasterRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	  if ((old_table_entry_p = (ieee8021AsAcceptableMasterTableDSMasterTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021AsAcceptableMasterTableDSMasterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021AsAcceptableMasterTableDSMasterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021AsAcceptableMasterRowStatus = set_value;
            if (ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021AsAcceptableMasterTableDSMasterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* IEEE8021AsTimeSyncMIB_NOT_SUPPORTED */
