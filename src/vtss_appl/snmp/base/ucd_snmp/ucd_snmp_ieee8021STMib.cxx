/*
 Copyright (c) 2006-2021 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_ieee8021STMib.h"
#include "ieee8021STMib.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021STMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021STMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021STMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[IEEE8021STMIB_STR_LEN_MAX + 1];
    struct counter64    c64_ret;
    u_long              ulong_ret;
} ieee8021STMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ieee8021STMib_var;
FindVarMethod ieee8021STMaxSDUTable_var;
FindVarMethod ieee8021STParametersTable_var;
WriteMethod ieee8021STMaxSDU_write;
WriteMethod ieee8021STGateEnabled_write;
WriteMethod ieee8021STAdminGateStates_write;
WriteMethod ieee8021STAdminControlListLength_write;
WriteMethod ieee8021STAdminControlList_write;
WriteMethod ieee8021STAdminCycleTimeNumerator_write;
WriteMethod ieee8021STAdminCycleTimeDenominator_write;
WriteMethod ieee8021STAdminCycleTimeExtension_write;
WriteMethod ieee8021STAdminBaseTime_write;
WriteMethod ieee8021STConfigChange_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ieee8021STMib_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021STMib_ret_t ieee8021STMib_global_ret;

/*
 * ieee8021STMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ieee8021STMib_variables_oid[] = {1,3,111,2,802,1,1,30};



/*
 * variable ieee8021STMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021STMib mib section
 */

struct variable7 ieee8021STMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IEEE8021STMAXSDU		1
    {IEEE8021STMAXSDU, ASN_UNSIGNED, RWRITE, ieee8021STMaxSDUTable_var, 5, {1,1,1, 1, 2}},
#define IEEE8021TRANSMISSIONOVERRUN		2
    {IEEE8021TRANSMISSIONOVERRUN, ASN_COUNTER64, RONLY, ieee8021STMaxSDUTable_var, 5, {1,1,1, 1, 3}},
#define IEEE8021STGATEENABLED		3
    {IEEE8021STGATEENABLED, ASN_INTEGER, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 1}},
#define IEEE8021STADMINGATESTATES		4
    {IEEE8021STADMINGATESTATES, ASN_OCTET_STR, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 2}},
#define IEEE8021STOPERGATESTATES		5
    {IEEE8021STOPERGATESTATES, ASN_OCTET_STR, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 3}},
#define IEEE8021STADMINCONTROLLISTLENGTH		6
    {IEEE8021STADMINCONTROLLISTLENGTH, ASN_UNSIGNED, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 4}},
#define IEEE8021STOPERCONTROLLISTLENGTH		7
    {IEEE8021STOPERCONTROLLISTLENGTH, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 5}},
#define IEEE8021STADMINCONTROLLIST		8
    {IEEE8021STADMINCONTROLLIST, ASN_OCTET_STR, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 6}},
#define IEEE8021STOPERCONTROLLIST		9
    {IEEE8021STOPERCONTROLLIST, ASN_OCTET_STR, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 7}},
#define IEEE8021STADMINCYCLETIMENUMERATOR		10
    {IEEE8021STADMINCYCLETIMENUMERATOR, ASN_UNSIGNED, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 8}},
#define IEEE8021STADMINCYCLETIMEDENOMINATOR		11
    {IEEE8021STADMINCYCLETIMEDENOMINATOR, ASN_UNSIGNED, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 9}},
#define IEEE8021STOPERCYCLETIMENUMERATOR		12
    {IEEE8021STOPERCYCLETIMENUMERATOR, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 10}},
#define IEEE8021STOPERCYCLETIMEDENOMINATOR		13
    {IEEE8021STOPERCYCLETIMEDENOMINATOR, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 11}},
#define IEEE8021STADMINCYCLETIMEEXTENSION		14
    {IEEE8021STADMINCYCLETIMEEXTENSION, ASN_UNSIGNED, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 12}},
#define IEEE8021STOPERCYCLETIMEEXTENSION		15
    {IEEE8021STOPERCYCLETIMEEXTENSION, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 13}},
#define IEEE8021STADMINBASETIME		16
    {IEEE8021STADMINBASETIME, ASN_OCTET_STR, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 14}},
#define IEEE8021STOPERBASETIME		17
    {IEEE8021STOPERBASETIME, ASN_OCTET_STR, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 15}},
#define IEEE8021STCONFIGCHANGE		18
    {IEEE8021STCONFIGCHANGE, ASN_INTEGER, RWRITE, ieee8021STParametersTable_var, 5, {1,2,1, 1, 16}},
#define IEEE8021STCONFIGCHANGETIME		19
    {IEEE8021STCONFIGCHANGETIME, ASN_OCTET_STR, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 17}},
#define IEEE8021STTICKGRANULARITY		20
    {IEEE8021STTICKGRANULARITY, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 18}},
#define IEEE8021STCURRENTTIME		21
    {IEEE8021STCURRENTTIME, ASN_OCTET_STR, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 19}},
#define IEEE8021STCONFIGPENDING		22
    {IEEE8021STCONFIGPENDING, ASN_INTEGER, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 20}},
#define IEEE8021STCONFIGCHANGEERROR		23
    {IEEE8021STCONFIGCHANGEERROR, ASN_COUNTER64, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 21}},
#define IEEE8021STSUPPORTEDLISTMAX		24
    {IEEE8021STSUPPORTEDLISTMAX, ASN_UNSIGNED, RONLY, ieee8021STParametersTable_var, 5, {1,2,1, 1, 22}},
};


/******************************************************************************/
// ucd_snmp_init_ieee8021STMib()
// Initializes the UCD-SNMP-part of the IEEE8021-ST-MIB:ieee8021STMib.
/******************************************************************************/
void ucd_snmp_init_ieee8021STMib(void)
{
    DEBUGMSGTL(("ieee8021STMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021STMib", ieee8021STMib_variables, variable7, ieee8021STMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021STMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ieee8021STMib_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021STMib_var\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021STMaxSDUTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021STMaxSDUTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021STMaxSDUTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021STMaxSDUTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021STTrafficClass = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021STMaxSDUTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021STMaxSDUTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021STMaxSDUTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;
    name[name_pos++] = (oid) table_entry->ieee8021STTrafficClass;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021STMaxSDUTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021STMib_var above.
 */
u_char *
ieee8021STMaxSDUTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021STMaxSDUTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021STMaxSDUTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021STMaxSDUTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021STMaxSDUTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021STMaxSDUTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021STMAXSDU: {
        *write_method = ieee8021STMaxSDU_write;
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STMaxSDU;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021TRANSMISSIONOVERRUN: {
        ieee8021STMib_global_ret.c64_ret = table_entry.ieee8021TransmissionOverrun;
        *var_len = sizeof(ieee8021STMib_global_ret.c64_ret);
        return (u_char *) &ieee8021STMib_global_ret.c64_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021STMaxSDUTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021STParametersTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021STParametersTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021STParametersTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021STParametersTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021STParametersTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021STParametersTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021STParametersTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021STParametersTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021STMib_var above.
 */
u_char *
ieee8021STParametersTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021STParametersTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021STParametersTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021STParametersTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021STParametersTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021STParametersTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021STGATEENABLED: {
        *write_method = ieee8021STGateEnabled_write;
        ieee8021STMib_global_ret.long_ret = table_entry.ieee8021STGateEnabled;
        *var_len = sizeof(ieee8021STMib_global_ret.long_ret);
        return (u_char *) &ieee8021STMib_global_ret.long_ret;
    }
    case IEEE8021STADMINGATESTATES: {
        *write_method = ieee8021STAdminGateStates_write;
        *var_len = table_entry.ieee8021STAdminGateStates_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STAdminGateStates, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STOPERGATESTATES: {
        *var_len = table_entry.ieee8021STOperGateStates_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STOperGateStates, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STADMINCONTROLLISTLENGTH: {
        *write_method = ieee8021STAdminControlListLength_write;
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STAdminControlListLength;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STOPERCONTROLLISTLENGTH: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STOperControlListLength;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STADMINCONTROLLIST: {
        *write_method = ieee8021STAdminControlList_write;
        *var_len = table_entry.ieee8021STAdminControlList_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STAdminControlList, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STOPERCONTROLLIST: {
        *var_len = table_entry.ieee8021STOperControlList_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STOperControlList, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STADMINCYCLETIMENUMERATOR: {
        *write_method = ieee8021STAdminCycleTimeNumerator_write;
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STAdminCycleTimeNumerator;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STADMINCYCLETIMEDENOMINATOR: {
        *write_method = ieee8021STAdminCycleTimeDenominator_write;
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STAdminCycleTimeDenominator;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STOPERCYCLETIMENUMERATOR: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STOperCycleTimeNumerator;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STOPERCYCLETIMEDENOMINATOR: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STOperCycleTimeDenominator;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STADMINCYCLETIMEEXTENSION: {
        *write_method = ieee8021STAdminCycleTimeExtension_write;
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STAdminCycleTimeExtension;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STOPERCYCLETIMEEXTENSION: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STOperCycleTimeExtension;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STADMINBASETIME: {
        *write_method = ieee8021STAdminBaseTime_write;
        *var_len = table_entry.ieee8021STAdminBaseTime_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STAdminBaseTime, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STOPERBASETIME: {
        *var_len = table_entry.ieee8021STOperBaseTime_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STOperBaseTime, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STCONFIGCHANGE: {
        *write_method = ieee8021STConfigChange_write;
        ieee8021STMib_global_ret.long_ret = table_entry.ieee8021STConfigChange;
        *var_len = sizeof(ieee8021STMib_global_ret.long_ret);
        return (u_char *) &ieee8021STMib_global_ret.long_ret;
    }
    case IEEE8021STCONFIGCHANGETIME: {
        *var_len = table_entry.ieee8021STConfigChangeTime_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STConfigChangeTime, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STTICKGRANULARITY: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STTickGranularity;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    case IEEE8021STCURRENTTIME: {
        *var_len = table_entry.ieee8021STCurrentTime_len;
        memcpy(ieee8021STMib_global_ret.string_ret, table_entry.ieee8021STCurrentTime, *var_len);
        ieee8021STMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021STMib_global_ret.string_ret;
    }
    case IEEE8021STCONFIGPENDING: {
        ieee8021STMib_global_ret.long_ret = table_entry.ieee8021STConfigPending;
        *var_len = sizeof(ieee8021STMib_global_ret.long_ret);
        return (u_char *) &ieee8021STMib_global_ret.long_ret;
    }
    case IEEE8021STCONFIGCHANGEERROR: {
        ieee8021STMib_global_ret.c64_ret = table_entry.ieee8021STConfigChangeError;
        *var_len = sizeof(ieee8021STMib_global_ret.c64_ret);
        return (u_char *) &ieee8021STMib_global_ret.c64_ret;
    }
    case IEEE8021STSUPPORTEDLISTMAX: {
        ieee8021STMib_global_ret.ulong_ret = table_entry.ieee8021STSupportedListMax;
        *var_len = sizeof(ieee8021STMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021STMib_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021STParametersTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021STMaxSDU_write()
/******************************************************************************/
int
ieee8021STMaxSDU_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021STMaxSDUTable_entry_t table_entry;
    static ieee8021STMaxSDUTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STMaxSDU: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STMaxSDU: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STMaxSDUTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STMaxSDUTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STMaxSDUTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STMaxSDU = set_value;
            if (ieee8021STMaxSDUTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STMaxSDUTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STGateEnabled_write()
/******************************************************************************/
int
ieee8021STGateEnabled_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STGateEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STGateEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STGateEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STGateEnabled = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            if (old_table_entry_p) {
                int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                if (undo_rc) {
                    return SNMP_ERR_UNDOFAILED;
                }
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminGateStates_write()
/******************************************************************************/
int
ieee8021STAdminGateStates_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminGateStates: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021STMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminGateStates: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > IEEE8021STMIB_STR_LEN_GATE) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021STAdminGateStates, var_val, var_val_len);
            table_entry.ieee8021STAdminGateStates_len = var_val_len;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminControlListLength_write()
/******************************************************************************/
int
ieee8021STAdminControlListLength_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminControlListLength: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminControlListLength: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STAdminControlListLength = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminControlList_write()
/******************************************************************************/
int
ieee8021STAdminControlList_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminControlList: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021STMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminControlList: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021STAdminControlList, var_val, var_val_len);
            table_entry.ieee8021STAdminControlList_len = var_val_len;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminCycleTimeNumerator_write()
/******************************************************************************/
int
ieee8021STAdminCycleTimeNumerator_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeNumerator: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeNumerator: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STAdminCycleTimeNumerator = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminCycleTimeDenominator_write()
/******************************************************************************/
int
ieee8021STAdminCycleTimeDenominator_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeDenominator: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeDenominator: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STAdminCycleTimeDenominator = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminCycleTimeExtension_write()
/******************************************************************************/
int
ieee8021STAdminCycleTimeExtension_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeExtension: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminCycleTimeExtension: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STAdminCycleTimeExtension = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STAdminBaseTime_write()
/******************************************************************************/
int
ieee8021STAdminBaseTime_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminBaseTime: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021STMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STAdminBaseTime: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
             if (var_val_len > IEEE8021STMIB_STR_LEN_TIME) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021STAdminBaseTime, var_val, var_val_len);
            table_entry.ieee8021STAdminBaseTime_len = var_val_len;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021STConfigChange_write()
/******************************************************************************/
int
ieee8021STConfigChange_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021STParametersTable_entry_t table_entry;
    static ieee8021STParametersTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STConfigChange: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STConfigChange: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021STConfigChange: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
	    if ((old_table_entry_p = (ieee8021STParametersTable_entry_t*)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021STParametersTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021STConfigChange = set_value;
            if (ieee8021STParametersTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021STParametersTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

