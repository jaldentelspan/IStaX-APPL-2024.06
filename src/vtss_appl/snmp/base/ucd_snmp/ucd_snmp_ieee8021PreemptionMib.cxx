/*
 Copyright (c) 2006-2017 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

//#include <ucd-snmp/config.h>              /* For HAVE_STDLIB_H, etc.       */
//#include <ucd-snmp/mibincl.h>             /* Standard set of SNMP includes */
//#include <ucd-snmp/mibgroup/util_funcs.h> /* For header_generic() */

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_ieee8021PreemptionMib.h"
#include "ieee8021PreemptionMib.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021PREEMPTIONMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021PREEMPTIONMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021PREEMPTIONMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    u_long              ulong_ret;
} ieee8021PreemptionMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ieee8021PreemptionMib_var;
FindVarMethod ieee8021PreemptionParameterTable_var;
FindVarMethod ieee8021PreemptionConfigTable_var;
WriteMethod ieee8021FramePreemptionAdminStatus_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ieee8021PreemptionMib_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021PreemptionMib_ret_t ieee8021PreemptionMib_global_ret;

/*
 * ieee8021PreemptionMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ieee8021PreemptionMib_variables_oid[] = {1,3,111,2,802,1,1,29};



/*
 * variable ieee8021PreemptionMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021PreemptionMib mib section
 */

struct variable7 ieee8021PreemptionMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IEEE8021FRAMEPREEMPTIONADMINSTATUS		1
    {IEEE8021FRAMEPREEMPTIONADMINSTATUS, ASN_INTEGER, RWRITE, ieee8021PreemptionParameterTable_var, 5, {1,1,1, 1, 2}},
#define IEEE8021FRAMEPREEMPTIONHOLDADVANCE		2
    {IEEE8021FRAMEPREEMPTIONHOLDADVANCE, ASN_UNSIGNED, RONLY, ieee8021PreemptionConfigTable_var, 5, {1,1,2, 1, 1}},
#define IEEE8021FRAMEPREEMPTIONRELEASEADVANCE		3
    {IEEE8021FRAMEPREEMPTIONRELEASEADVANCE, ASN_UNSIGNED, RONLY, ieee8021PreemptionConfigTable_var, 5, {1,1,2, 1, 2}},
#define IEEE8021FRAMEPREEMPTIONACTIVE		4
    {IEEE8021FRAMEPREEMPTIONACTIVE, ASN_INTEGER, RONLY, ieee8021PreemptionConfigTable_var, 5, {1,1,2, 1, 3}},
#define IEEE8021FRAMEPREEMPTIONHOLDREQUEST		5
    {IEEE8021FRAMEPREEMPTIONHOLDREQUEST, ASN_INTEGER, RONLY, ieee8021PreemptionConfigTable_var, 5, {1,1,2, 1, 4}},
};


/******************************************************************************/
// ucd_snmp_init_ieee8021PreemptionMib()
// Initializes the UCD-SNMP-part of the IEEE8021-Preemption-MIB:ieee8021PreemptionMib.
/******************************************************************************/
void ucd_snmp_init_ieee8021PreemptionMib(void)
{
    DEBUGMSGTL(("ieee8021PreemptionMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021PreemptionMib", ieee8021PreemptionMib_variables, variable7, ieee8021PreemptionMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021PreemptionMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ieee8021PreemptionMib_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021PreemptionMib_var\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021PreemptionParameterTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PreemptionParameterTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PreemptionParameterTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PreemptionParameterTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021PreemptionPriority = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PreemptionParameterTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PreemptionParameterTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PreemptionParameterTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;
    name[name_pos++] = (oid) table_entry->ieee8021PreemptionPriority;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PreemptionParameterTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PreemptionMib_var above.
 */
u_char *
ieee8021PreemptionParameterTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PreemptionParameterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PreemptionParameterTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PreemptionParameterTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PreemptionParameterTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021PreemptionParameterTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021FRAMEPREEMPTIONADMINSTATUS: {
        *write_method = ieee8021FramePreemptionAdminStatus_write;
        ieee8021PreemptionMib_global_ret.long_ret = table_entry.ieee8021FramePreemptionAdminStatus;
        *var_len = sizeof(ieee8021PreemptionMib_global_ret.long_ret);
        return (u_char *) &ieee8021PreemptionMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PreemptionParameterTable\n", vp->magic));
    }
    return NULL;
}
/******************************************************************************/
// ieee8021PreemptionConfigTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021PreemptionConfigTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ieee8021PreemptionConfigTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021PreemptionConfigTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBaseComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021PreemptionConfigTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021PreemptionConfigTable_fillobj(oid     *name,
             size_t  *length,
             ieee8021PreemptionConfigTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021BridgeBaseComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021PreemptionConfigTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021PreemptionMib_var above.
 */
u_char *
ieee8021PreemptionConfigTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ieee8021PreemptionConfigTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ieee8021PreemptionConfigTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ieee8021PreemptionConfigTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021PreemptionConfigTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021PreemptionConfigTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021FRAMEPREEMPTIONHOLDADVANCE: {
        ieee8021PreemptionMib_global_ret.ulong_ret = table_entry.ieee8021FramePreemptionHoldAdvance;
        *var_len = sizeof(ieee8021PreemptionMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PreemptionMib_global_ret.ulong_ret;
    }
    case IEEE8021FRAMEPREEMPTIONRELEASEADVANCE: {
        ieee8021PreemptionMib_global_ret.ulong_ret = table_entry.ieee8021FramePreemptionReleaseAdvance;
        *var_len = sizeof(ieee8021PreemptionMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021PreemptionMib_global_ret.ulong_ret;
    }
    case IEEE8021FRAMEPREEMPTIONACTIVE: {
        ieee8021PreemptionMib_global_ret.long_ret = table_entry.ieee8021FramePreemptionActive;
        *var_len = sizeof(ieee8021PreemptionMib_global_ret.long_ret);
        return (u_char *) &ieee8021PreemptionMib_global_ret.long_ret;
    }
    case IEEE8021FRAMEPREEMPTIONHOLDREQUEST: {
        ieee8021PreemptionMib_global_ret.long_ret = table_entry.ieee8021FramePreemptionHoldRequest;
        *var_len = sizeof(ieee8021PreemptionMib_global_ret.long_ret);
        return (u_char *) &ieee8021PreemptionMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021PreemptionConfigTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021FramePreemptionAdminStatus_write()
/******************************************************************************/
int
ieee8021FramePreemptionAdminStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ieee8021PreemptionParameterTable_entry_t table_entry;
    static ieee8021PreemptionParameterTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ieee8021FramePreemptionAdminStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ieee8021FramePreemptionAdminStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ieee8021FramePreemptionAdminStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = (ieee8021PreemptionParameterTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PreemptionParameterTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021PreemptionParameterTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021FramePreemptionAdminStatus = set_value;
            if (ieee8021PreemptionParameterTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ieee8021PreemptionParameterTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

