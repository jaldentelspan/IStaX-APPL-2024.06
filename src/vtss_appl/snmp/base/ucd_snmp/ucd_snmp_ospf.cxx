/*

 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_ospf.h"
#include "rfc4750_ospf.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[OSPF_STR_LEN_MAX + 1];
    u_char              ip_string_ret[4];
    u_long              ulong_ret;
} ospf_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ospf_var;
FindVarMethod ospfAreaTable_var;
FindVarMethod ospfStubAreaTable_var;
FindVarMethod ospfLsdbTable_var;
FindVarMethod ospfAreaRangeTable_var;
FindVarMethod ospfHostTable_var;
FindVarMethod ospfIfTable_var;
FindVarMethod ospfIfMetricTable_var;
FindVarMethod ospfVirtIfTable_var;
FindVarMethod ospfNbrTable_var;
FindVarMethod ospfVirtNbrTable_var;
FindVarMethod ospfExtLsdbTable_var;
FindVarMethod ospfAreaAggregateTable_var;
FindVarMethod ospfLocalLsdbTable_var;
FindVarMethod ospfVirtLocalLsdbTable_var;
FindVarMethod ospfAsLsdbTable_var;
FindVarMethod ospfAreaLsaCountTable_var;
WriteMethod ospfRouterId_write;
WriteMethod ospfAdminStat_write;
WriteMethod ospfASBdrRtrStatus_write;
WriteMethod ospfTOSSupport_write;
WriteMethod ospfExtLsdbLimit_write;
WriteMethod ospfMulticastExtensions_write;
WriteMethod ospfExitOverflowInterval_write;
WriteMethod ospfDemandExtensions_write;
WriteMethod ospfRFC1583Compatibility_write;
WriteMethod ospfReferenceBandwidth_write;
WriteMethod ospfRestartSupport_write;
WriteMethod ospfRestartInterval_write;
WriteMethod ospfRestartStrictLsaChecking_write;
WriteMethod ospfStubRouterAdvertisement_write;
WriteMethod ospfAuthType_write;
WriteMethod ospfImportAsExtern_write;
WriteMethod ospfAreaSummary_write;
WriteMethod ospfAreaStatus_write;
WriteMethod ospfAreaNssaTranslatorRole_write;
WriteMethod ospfAreaNssaTranslatorStabilityInterval_write;
WriteMethod ospfStubMetric_write;
WriteMethod ospfStubStatus_write;
WriteMethod ospfStubMetricType_write;
WriteMethod ospfAreaRangeMask_write;
WriteMethod ospfAreaRangeStatus_write;
WriteMethod ospfAreaRangeEffect_write;
WriteMethod ospfHostMetric_write;
WriteMethod ospfHostStatus_write;
WriteMethod ospfHostCfgAreaID_write;
WriteMethod ospfIfAreaId_write;
WriteMethod ospfIfType_write;
WriteMethod ospfIfAdminStat_write;
WriteMethod ospfIfRtrPriority_write;
WriteMethod ospfIfTransitDelay_write;
WriteMethod ospfIfRetransInterval_write;
WriteMethod ospfIfHelloInterval_write;
WriteMethod ospfIfRtrDeadInterval_write;
WriteMethod ospfIfPollInterval_write;
WriteMethod ospfIfAuthKey_write;
WriteMethod ospfIfStatus_write;
WriteMethod ospfIfMulticastForwarding_write;
WriteMethod ospfIfDemand_write;
WriteMethod ospfIfAuthType_write;
WriteMethod ospfIfMetricValue_write;
WriteMethod ospfIfMetricStatus_write;
WriteMethod ospfVirtIfTransitDelay_write;
WriteMethod ospfVirtIfRetransInterval_write;
WriteMethod ospfVirtIfHelloInterval_write;
WriteMethod ospfVirtIfRtrDeadInterval_write;
WriteMethod ospfVirtIfAuthKey_write;
WriteMethod ospfVirtIfStatus_write;
WriteMethod ospfVirtIfAuthType_write;
WriteMethod ospfNbrPriority_write;
WriteMethod ospfNbmaNbrStatus_write;
WriteMethod ospfAreaAggregateStatus_write;
WriteMethod ospfAreaAggregateEffect_write;
WriteMethod ospfAreaAggregateExtRouteTag_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ospf_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ospf_ret_t ospf_global_ret;

/*
 * ospf_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ospf_variables_oid[] = {1,3,6,1,2,1,14};



/*
 * variable ospf_variables:
 *   this variable defines function callbacks and type return information
 *   for the ospf mib section
 */

struct variable4 ospf_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
// --- ospfGeneralGroup
#define OSPFROUTERID		1
    {OSPFROUTERID, ASN_IPADDRESS, RWRITE, ospf_var, 2, {1,1}},
#define OSPFADMINSTAT		2
    {OSPFADMINSTAT, ASN_INTEGER, RWRITE, ospf_var, 2, {1,2}},
#define OSPFVERSIONNUMBER		3
    {OSPFVERSIONNUMBER, ASN_INTEGER, RONLY, ospf_var, 2, {1,3}},
#define OSPFAREABDRRTRSTATUS		4
// unsupported    {OSPFAREABDRRTRSTATUS, ASN_INTEGER, RONLY, ospf_var, 2, {1,4}},
#define OSPFASBDRRTRSTATUS		5
// unsupported    {OSPFASBDRRTRSTATUS, ASN_INTEGER, RWRITE, ospf_var, 2, {1,5}},
#define OSPFEXTERNLSACOUNT		6
    {OSPFEXTERNLSACOUNT, ASN_GAUGE, RONLY, ospf_var, 2, {1,6}},
#define OSPFEXTERNLSACKSUMSUM		7
    {OSPFEXTERNLSACKSUMSUM, ASN_INTEGER, RONLY, ospf_var, 2, {1,7}},
#define OSPFTOSSUPPORT		8
    {OSPFTOSSUPPORT, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,8}},
#define OSPFORIGINATENEWLSAS		9
// unsupported    {OSPFORIGINATENEWLSAS, ASN_COUNTER, RONLY, ospf_var, 2, {1,9}},
#define OSPFRXNEWLSAS		10
// unsupported    {OSPFRXNEWLSAS, ASN_COUNTER, RONLY, ospf_var, 2, {1,10}},
#define OSPFEXTLSDBLIMIT		11
    {OSPFEXTLSDBLIMIT, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,11}},
#define OSPFMULTICASTEXTENSIONS		12
    {OSPFMULTICASTEXTENSIONS, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,12}},
#define OSPFEXITOVERFLOWINTERVAL		13
    {OSPFEXITOVERFLOWINTERVAL, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,13}},
#define OSPFDEMANDEXTENSIONS		14
    {OSPFDEMANDEXTENSIONS, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,14}},
#define OSPFRFC1583COMPATIBILITY		15
    {OSPFRFC1583COMPATIBILITY, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,15}},
#define OSPFOPAQUELSASUPPORT		16
    {OSPFOPAQUELSASUPPORT, ASN_INTEGER, RONLY, ospf_var, 2, {1,16}},
#define OSPFREFERENCEBANDWIDTH		17
    {OSPFREFERENCEBANDWIDTH, ASN_UNSIGNED, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,17}},
#define OSPFRESTARTSUPPORT		18
    {OSPFRESTARTSUPPORT, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospf_var, 2, {1,18}},
#define OSPFRESTARTINTERVAL		19
// unsupported    {OSPFRESTARTINTERVAL, ASN_INTEGER, RWRITE, ospf_var, 2, {1,19}},
#define OSPFRESTARTSTRICTLSACHECKING		20
// unsupported    {OSPFRESTARTSTRICTLSACHECKING, ASN_INTEGER, RWRITE, ospf_var, 2, {1,20}},
#define OSPFRESTARTSTATUS		21
// unsupported    {OSPFRESTARTSTATUS, ASN_INTEGER, RONLY, ospf_var, 2, {1,21}},
#define OSPFRESTARTAGE		22
// unsupported    {OSPFRESTARTAGE, ASN_UNSIGNED, RONLY, ospf_var, 2, {1,22}},
#define OSPFRESTARTEXITREASON		23
// unsupported    {OSPFRESTARTEXITREASON, ASN_INTEGER, RONLY, ospf_var, 2, {1,23}},
#define OSPFASLSACOUNT		24
    {OSPFASLSACOUNT, ASN_GAUGE, RONLY, ospf_var, 2, {1,24}},
#define OSPFASLSACKSUMSUM		25
// unsupported    {OSPFASLSACKSUMSUM, ASN_UNSIGNED, RONLY, ospf_var, 2, {1,25}},
#define OSPFSTUBROUTERSUPPORT		26
    {OSPFSTUBROUTERSUPPORT, ASN_INTEGER, RONLY, ospf_var, 2, {1,26}},
#define OSPFSTUBROUTERADVERTISEMENT		27
    {OSPFSTUBROUTERADVERTISEMENT, ASN_INTEGER, RWRITE, ospf_var, 2, {1,27}},
#define OSPFDISCONTINUITYTIME		28
// unsupported    {OSPFDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, ospf_var, 2, {1,28}},

// --- ospfAreaTable
#define OSPFAREAID		29
    {OSPFAREAID, ASN_IPADDRESS, RONLY, ospfAreaTable_var, 3, {2, 1, 1}},
#define OSPFAUTHTYPE		30
// obsolete    {OSPFAUTHTYPE, ASN_INTEGER, RWRITE, ospfAreaTable_var, 3, {2, 1, 2}},
#define OSPFIMPORTASEXTERN		31
    {OSPFIMPORTASEXTERN, ASN_INTEGER, RWRITE, ospfAreaTable_var, 3, {2, 1, 3}},
#define OSPFSPFRUNS		32
    {OSPFSPFRUNS, ASN_COUNTER, RONLY, ospfAreaTable_var, 3, {2, 1, 4}},
#define OSPFAREABDRRTRCOUNT		33
// unsupported    {OSPFAREABDRRTRCOUNT, ASN_GAUGE, RONLY, ospfAreaTable_var, 3, {2, 1, 5}},
#define OSPFASBDRRTRCOUNT		34
// unsupported    {OSPFASBDRRTRCOUNT, ASN_GAUGE, RONLY, ospfAreaTable_var, 3, {2, 1, 6}},
#define OSPFAREALSACOUNT		35
// unsupported    {OSPFAREALSACOUNT, ASN_GAUGE, RONLY, ospfAreaTable_var, 3, {2, 1, 7}},
#define OSPFAREALSACKSUMSUM		36
// unsupported     {OSPFAREALSACKSUMSUM, ASN_INTEGER, RONLY, ospfAreaTable_var, 3, {2, 1, 8}},
#define OSPFAREASUMMARY		37
    {OSPFAREASUMMARY, ASN_INTEGER, RWRITE, ospfAreaTable_var, 3, {2, 1, 9}},
#define OSPFAREASTATUS		38
    {OSPFAREASTATUS, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospfAreaTable_var, 3, {2, 1, 10}},
#define OSPFAREANSSATRANSLATORROLE		39
    {OSPFAREANSSATRANSLATORROLE, ASN_INTEGER, RWRITE, ospfAreaTable_var, 3, {2, 1, 11}},
#define OSPFAREANSSATRANSLATORSTATE		40
    {OSPFAREANSSATRANSLATORSTATE, ASN_INTEGER, RONLY, ospfAreaTable_var, 3, {2, 1, 12}},
#define OSPFAREANSSATRANSLATORSTABILITYINTERVAL		41
    {OSPFAREANSSATRANSLATORSTABILITYINTERVAL, ASN_INTEGER, RONLY /* Changed from RWRITE */, ospfAreaTable_var, 3, {2, 1, 13}},
#define OSPFAREANSSATRANSLATOREVENTS		42
// unsupported     {OSPFAREANSSATRANSLATOREVENTS, ASN_COUNTER, RONLY, ospfAreaTable_var, 3, {2, 1, 14}},

// --- ospfStubAreaTable
#define OSPFSTUBAREAID		43
// unsupported    {OSPFSTUBAREAID, ASN_IPADDRESS, RONLY, ospfStubAreaTable_var, 3, {3, 1, 1}},
#define OSPFSTUBTOS		44
// unsupported    {OSPFSTUBTOS, ASN_INTEGER, RONLY, ospfStubAreaTable_var, 3, {3, 1, 2}},
#define OSPFSTUBMETRIC		45
// unsupported    {OSPFSTUBMETRIC, ASN_INTEGER, RWRITE, ospfStubAreaTable_var, 3, {3, 1, 3}},
#define OSPFSTUBSTATUS		46
// unsupported    {OSPFSTUBSTATUS, ASN_INTEGER, RWRITE, ospfStubAreaTable_var, 3, {3, 1, 4}},
#define OSPFSTUBMETRICTYPE		47
// unsupported    {OSPFSTUBMETRICTYPE, ASN_INTEGER, RWRITE, ospfStubAreaTable_var, 3, {3, 1, 5}},

// --- ospfLsdbTable
#define OSPFLSDBAREAID		48
    {OSPFLSDBAREAID, ASN_IPADDRESS, RONLY, ospfLsdbTable_var, 3, {4, 1, 1}},
#define OSPFLSDBTYPE		49
    {OSPFLSDBTYPE, ASN_INTEGER, RONLY, ospfLsdbTable_var, 3, {4, 1, 2}},
#define OSPFLSDBLSID		50
    {OSPFLSDBLSID, ASN_IPADDRESS, RONLY, ospfLsdbTable_var, 3, {4, 1, 3}},
#define OSPFLSDBROUTERID		51
    {OSPFLSDBROUTERID, ASN_IPADDRESS, RONLY, ospfLsdbTable_var, 3, {4, 1, 4}},
#define OSPFLSDBSEQUENCE		52
    {OSPFLSDBSEQUENCE, ASN_INTEGER, RONLY, ospfLsdbTable_var, 3, {4, 1, 5}},
#define OSPFLSDBAGE		53
    {OSPFLSDBAGE, ASN_INTEGER, RONLY, ospfLsdbTable_var, 3, {4, 1, 6}},
#define OSPFLSDBCHECKSUM		54
    {OSPFLSDBCHECKSUM, ASN_INTEGER, RONLY, ospfLsdbTable_var, 3, {4, 1, 7}},
#define OSPFLSDBADVERTISEMENT		55
    {OSPFLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, ospfLsdbTable_var, 3, {4, 1, 8}},

// --- ospfAreaRangeTable
#define OSPFAREARANGEAREAID		56
// obsolete    {OSPFAREARANGEAREAID, ASN_IPADDRESS, RONLY, ospfAreaRangeTable_var, 3, {5, 1, 1}},
#define OSPFAREARANGENET		57
// obsolete    {OSPFAREARANGENET, ASN_IPADDRESS, RONLY, ospfAreaRangeTable_var, 3, {5, 1, 2}},
#define OSPFAREARANGEMASK		58
// obsolete    {OSPFAREARANGEMASK, ASN_IPADDRESS, RWRITE, ospfAreaRangeTable_var, 3, {5, 1, 3}},
#define OSPFAREARANGESTATUS		59
// obsolete    {OSPFAREARANGESTATUS, ASN_INTEGER, RWRITE, ospfAreaRangeTable_var, 3, {5, 1, 4}},
#define OSPFAREARANGEEFFECT		60
// obsolete    {OSPFAREARANGEEFFECT, ASN_INTEGER, RWRITE, ospfAreaRangeTable_var, 3, {5, 1, 5}},

// --- ospfHostTable
#define OSPFHOSTIPADDRESS		61
// unsupported    {OSPFHOSTIPADDRESS, ASN_IPADDRESS, RONLY, ospfHostTable_var, 3, {6, 1, 1}},
#define OSPFHOSTTOS		62
// unsupported    {OSPFHOSTTOS, ASN_INTEGER, RONLY, ospfHostTable_var, 3, {6, 1, 2}},
#define OSPFHOSTMETRIC		63
// unsupported    {OSPFHOSTMETRIC, ASN_INTEGER, RWRITE, ospfHostTable_var, 3, {6, 1, 3}},
#define OSPFHOSTSTATUS		64
// unsupported    {OSPFHOSTSTATUS, ASN_INTEGER, RWRITE, ospfHostTable_var, 3, {6, 1, 4}},
#define OSPFHOSTAREAID		65
// unsupported    {OSPFHOSTAREAID, ASN_IPADDRESS, RONLY, ospfHostTable_var, 3, {6, 1, 5}},
#define OSPFHOSTCFGAREAID		66
// unsupported    {OSPFHOSTCFGAREAID, ASN_IPADDRESS, RWRITE, ospfHostTable_var, 3, {6, 1, 6}},

// --- ospfIfTable
#define OSPFIFIPADDRESS		67
    {OSPFIFIPADDRESS, ASN_IPADDRESS, RONLY, ospfIfTable_var, 3, {7, 1, 1}},
#define OSPFADDRESSLESSIF		68
    {OSPFADDRESSLESSIF, ASN_INTEGER, RONLY, ospfIfTable_var, 3, {7, 1, 2}},
#define OSPFIFAREAID		69
    {OSPFIFAREAID, ASN_IPADDRESS, RWRITE, ospfIfTable_var, 3, {7, 1, 3}},
#define OSPFIFTYPE		70
    {OSPFIFTYPE, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfTable_var, 3, {7, 1, 4}},
#define OSPFIFADMINSTAT		71
    {OSPFIFADMINSTAT, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfTable_var, 3, {7, 1, 5}},
#define OSPFIFRTRPRIORITY		72
    {OSPFIFRTRPRIORITY, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 6}},
#define OSPFIFTRANSITDELAY		73
    {OSPFIFTRANSITDELAY, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfTable_var, 3, {7, 1, 7}},
#define OSPFIFRETRANSINTERVAL		74
    {OSPFIFRETRANSINTERVAL, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 8}},
#define OSPFIFHELLOINTERVAL		75
    {OSPFIFHELLOINTERVAL, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 9}},
#define OSPFIFRTRDEADINTERVAL		76
    {OSPFIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 10}},
#define OSPFIFPOLLINTERVAL		77
// unsupported    {OSPFIFPOLLINTERVAL, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 11}},
#define OSPFIFSTATE		78
    {OSPFIFSTATE, ASN_INTEGER, RONLY, ospfIfTable_var, 3, {7, 1, 12}},
#define OSPFIFDESIGNATEDROUTER		79
    {OSPFIFDESIGNATEDROUTER, ASN_IPADDRESS, RONLY, ospfIfTable_var, 3, {7, 1, 13}},
#define OSPFIFBACKUPDESIGNATEDROUTER		80
    {OSPFIFBACKUPDESIGNATEDROUTER, ASN_IPADDRESS, RONLY, ospfIfTable_var, 3, {7, 1, 14}},
#define OSPFIFEVENTS		81
// unsupported    {OSPFIFEVENTS, ASN_COUNTER, RONLY, ospfIfTable_var, 3, {7, 1, 15}},
#define OSPFIFAUTHKEY		82
// unsupported    {OSPFIFAUTHKEY, ASN_OCTET_STR, RWRITE, ospfIfTable_var, 3, {7, 1, 16}},
#define OSPFIFSTATUS		83
    {OSPFIFSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfTable_var, 3, {7, 1, 17}},
#define OSPFIFMULTICASTFORWARDING		84
    {OSPFIFMULTICASTFORWARDING, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfTable_var, 3, {7, 1, 18}},
#define OSPFIFDEMAND		85
// unsupported    {OSPFIFDEMAND, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 19}},
#define OSPFIFAUTHTYPE		86
    {OSPFIFAUTHTYPE, ASN_INTEGER, RWRITE, ospfIfTable_var, 3, {7, 1, 20}},
#define OSPFIFLSACOUNT		87
// unsupported    {OSPFIFLSACOUNT, ASN_GAUGE, RONLY, ospfIfTable_var, 3, {7, 1, 21}},
#define OSPFIFLSACKSUMSUM		88
// unsupported    {OSPFIFLSACKSUMSUM, ASN_UNSIGNED, RONLY, ospfIfTable_var, 3, {7, 1, 22}},
#define OSPFIFDESIGNATEDROUTERID		89
    {OSPFIFDESIGNATEDROUTERID, ASN_IPADDRESS, RONLY, ospfIfTable_var, 3, {7, 1, 23}},
#define OSPFIFBACKUPDESIGNATEDROUTERID		90
    {OSPFIFBACKUPDESIGNATEDROUTERID, ASN_IPADDRESS, RONLY, ospfIfTable_var, 3, {7, 1, 24}},

// --- ospfIfMetricTable
#define OSPFIFMETRICIPADDRESS		91
    {OSPFIFMETRICIPADDRESS, ASN_IPADDRESS, RONLY, ospfIfMetricTable_var, 3, {8, 1, 1}},
#define OSPFIFMETRICADDRESSLESSIF		92
    {OSPFIFMETRICADDRESSLESSIF, ASN_INTEGER, RONLY, ospfIfMetricTable_var, 3, {8, 1, 2}},
#define OSPFIFMETRICTOS		93
    {OSPFIFMETRICTOS, ASN_INTEGER, RONLY, ospfIfMetricTable_var, 3, {8, 1, 3}},
#define OSPFIFMETRICVALUE		94
    {OSPFIFMETRICVALUE, ASN_INTEGER, RWRITE, ospfIfMetricTable_var, 3, {8, 1, 4}},
#define OSPFIFMETRICSTATUS		95
    {OSPFIFMETRICSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfIfMetricTable_var, 3, {8, 1, 5}},

// --- ospfVirtIfTable
#define OSPFVIRTIFAREAID		96
    {OSPFVIRTIFAREAID, ASN_IPADDRESS, RONLY, ospfVirtIfTable_var, 3, {9, 1, 1}},
#define OSPFVIRTIFNEIGHBOR		97
    {OSPFVIRTIFNEIGHBOR, ASN_IPADDRESS, RONLY, ospfVirtIfTable_var, 3, {9, 1, 2}},
#define OSPFVIRTIFTRANSITDELAY		98
    {OSPFVIRTIFTRANSITDELAY, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfVirtIfTable_var, 3, {9, 1, 3}},
#define OSPFVIRTIFRETRANSINTERVAL		99
    {OSPFVIRTIFRETRANSINTERVAL, ASN_INTEGER, RWRITE, ospfVirtIfTable_var, 3, {9, 1, 4}},
#define OSPFVIRTIFHELLOINTERVAL		100
    {OSPFVIRTIFHELLOINTERVAL, ASN_INTEGER, RWRITE, ospfVirtIfTable_var, 3, {9, 1, 5}},
#define OSPFVIRTIFRTRDEADINTERVAL		101
    {OSPFVIRTIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE, ospfVirtIfTable_var, 3, {9, 1, 6}},
#define OSPFVIRTIFSTATE		102
    {OSPFVIRTIFSTATE, ASN_INTEGER, RONLY, ospfVirtIfTable_var, 3, {9, 1, 7}},
#define OSPFVIRTIFEVENTS		103
//unsupported    {OSPFVIRTIFEVENTS, ASN_COUNTER, RONLY, ospfVirtIfTable_var, 3, {9, 1, 8}},
#define OSPFVIRTIFAUTHKEY		104
//unsupported    {OSPFVIRTIFAUTHKEY, ASN_OCTET_STR, RWRITE, ospfVirtIfTable_var, 3, {9, 1, 9}},
#define OSPFVIRTIFSTATUS		105
    {OSPFVIRTIFSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfVirtIfTable_var, 3, {9, 1, 10}},
#define OSPFVIRTIFAUTHTYPE		106
    {OSPFVIRTIFAUTHTYPE, ASN_INTEGER, RWRITE, ospfVirtIfTable_var, 3, {9, 1, 11}},
#define OSPFVIRTIFLSACOUNT		107
//unsupported    {OSPFVIRTIFLSACOUNT, ASN_GAUGE, RONLY, ospfVirtIfTable_var, 3, {9, 1, 12}},
#define OSPFVIRTIFLSACKSUMSUM		108
//unsupported    {OSPFVIRTIFLSACKSUMSUM, ASN_UNSIGNED, RONLY, ospfVirtIfTable_var, 3, {9, 1, 13}},
// --- ospfNbrTable
#define OSPFNBRIPADDR		109
    {OSPFNBRIPADDR, ASN_IPADDRESS, RONLY, ospfNbrTable_var, 3, {10, 1, 1}},
#define OSPFNBRADDRESSLESSINDEX		110
    {OSPFNBRADDRESSLESSINDEX, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 2}},
#define OSPFNBRRTRID		111
    {OSPFNBRRTRID, ASN_IPADDRESS, RONLY, ospfNbrTable_var, 3, {10, 1, 3}},
#define OSPFNBROPTIONS		112
    {OSPFNBROPTIONS, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 4}},
#define OSPFNBRPRIORITY		113
    {OSPFNBRPRIORITY, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfNbrTable_var, 3, {10, 1, 5}},
#define OSPFNBRSTATE		114
    {OSPFNBRSTATE, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 6}},
#define OSPFNBREVENTS		115
    {OSPFNBREVENTS, ASN_COUNTER, RONLY, ospfNbrTable_var, 3, {10, 1, 7}},
#define OSPFNBRLSRETRANSQLEN		116
    {OSPFNBRLSRETRANSQLEN, ASN_GAUGE, RONLY, ospfNbrTable_var, 3, {10, 1, 8}},
#define OSPFNBMANBRSTATUS		117
    {OSPFNBMANBRSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, ospfNbrTable_var, 3, {10, 1, 9}},
#define OSPFNBMANBRPERMANENCE		118
    {OSPFNBMANBRPERMANENCE, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 10}},
#define OSPFNBRHELLOSUPPRESSED		119
    {OSPFNBRHELLOSUPPRESSED, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 11}},
#define OSPFNBRRESTARTHELPERSTATUS		120
    {OSPFNBRRESTARTHELPERSTATUS, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 12}},
#define OSPFNBRRESTARTHELPERAGE		121
    {OSPFNBRRESTARTHELPERAGE, ASN_UNSIGNED, RONLY, ospfNbrTable_var, 3, {10, 1, 13}},
#define OSPFNBRRESTARTHELPEREXITREASON		122
    {OSPFNBRRESTARTHELPEREXITREASON, ASN_INTEGER, RONLY, ospfNbrTable_var, 3, {10, 1, 14}},

// --- ospfVirtNbrTable
#define OSPFVIRTNBRAREA		123
    {OSPFVIRTNBRAREA, ASN_IPADDRESS, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 1}},
#define OSPFVIRTNBRRTRID		124
    {OSPFVIRTNBRRTRID, ASN_IPADDRESS, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 2}},
#define OSPFVIRTNBRIPADDR		125
    {OSPFVIRTNBRIPADDR, ASN_IPADDRESS, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 3}},
#define OSPFVIRTNBROPTIONS		126
    {OSPFVIRTNBROPTIONS, ASN_INTEGER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 4}},
#define OSPFVIRTNBRSTATE		127
    {OSPFVIRTNBRSTATE, ASN_INTEGER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 5}},
#define OSPFVIRTNBREVENTS		128
    {OSPFVIRTNBREVENTS, ASN_COUNTER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 6}},
#define OSPFVIRTNBRLSRETRANSQLEN		129
    {OSPFVIRTNBRLSRETRANSQLEN, ASN_GAUGE, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 7}},
#define OSPFVIRTNBRHELLOSUPPRESSED		130
    {OSPFVIRTNBRHELLOSUPPRESSED, ASN_INTEGER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 8}},
#define OSPFVIRTNBRRESTARTHELPERSTATUS		131
    {OSPFVIRTNBRRESTARTHELPERSTATUS, ASN_INTEGER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 9}},
#define OSPFVIRTNBRRESTARTHELPERAGE		132
    {OSPFVIRTNBRRESTARTHELPERAGE, ASN_UNSIGNED, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 10}},
#define OSPFVIRTNBRRESTARTHELPEREXITREASON		133
    {OSPFVIRTNBRRESTARTHELPEREXITREASON, ASN_INTEGER, RONLY, ospfVirtNbrTable_var, 3, {11, 1, 11}},

// --- ospfExtLsdbTable
#define OSPFEXTLSDBTYPE		134
    {OSPFEXTLSDBTYPE, ASN_INTEGER, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 1}},
#define OSPFEXTLSDBLSID		135
    {OSPFEXTLSDBLSID, ASN_IPADDRESS, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 2}},
#define OSPFEXTLSDBROUTERID		136
    {OSPFEXTLSDBROUTERID, ASN_IPADDRESS, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 3}},
#define OSPFEXTLSDBSEQUENCE		137
    {OSPFEXTLSDBSEQUENCE, ASN_INTEGER, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 4}},
#define OSPFEXTLSDBAGE		138
    {OSPFEXTLSDBAGE, ASN_INTEGER, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 5}},
#define OSPFEXTLSDBCHECKSUM		139
    {OSPFEXTLSDBCHECKSUM, ASN_INTEGER, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 6}},
#define OSPFEXTLSDBADVERTISEMENT		140
    {OSPFEXTLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, ospfExtLsdbTable_var, 3, {12, 1, 7}},

// --- ospfAreaAggregateTable
#define OSPFAREAAGGREGATEAREAID		141
    {OSPFAREAAGGREGATEAREAID, ASN_IPADDRESS, RONLY, ospfAreaAggregateTable_var, 3, {14, 1, 1}},
#define OSPFAREAAGGREGATELSDBTYPE		142
    {OSPFAREAAGGREGATELSDBTYPE, ASN_INTEGER, RONLY, ospfAreaAggregateTable_var, 3, {14, 1, 2}},
#define OSPFAREAAGGREGATENET		143
    {OSPFAREAAGGREGATENET, ASN_IPADDRESS, RONLY, ospfAreaAggregateTable_var, 3, {14, 1, 3}},
#define OSPFAREAAGGREGATEMASK		144
    {OSPFAREAAGGREGATEMASK, ASN_IPADDRESS, RONLY, ospfAreaAggregateTable_var, 3, {14, 1, 4}},
#define OSPFAREAAGGREGATESTATUS		145
    {OSPFAREAAGGREGATESTATUS, ASN_INTEGER, RONLY /* changed from RWRITE */, ospfAreaAggregateTable_var, 3, {14, 1, 5}},
#define OSPFAREAAGGREGATEEFFECT		146
    {OSPFAREAAGGREGATEEFFECT, ASN_INTEGER, RWRITE, ospfAreaAggregateTable_var, 3, {14, 1, 6}},
#define OSPFAREAAGGREGATEEXTROUTETAG		147
// unsupported       {OSPFAREAAGGREGATEEXTROUTETAG, ASN_UNSIGNED, RWRITE, ospfAreaAggregateTable_var, 3, {14, 1, 7}},

// --- ospfLocalLsdbTable
#define OSPFLOCALLSDBSEQUENCE		148
// unsupported    {OSPFLOCALLSDBSEQUENCE, ASN_INTEGER, RONLY, ospfLocalLsdbTable_var, 3, {17, 1, 6}},
#define OSPFLOCALLSDBAGE		149
// unsupported    {OSPFLOCALLSDBAGE, ASN_INTEGER, RONLY, ospfLocalLsdbTable_var, 3, {17, 1, 7}},
#define OSPFLOCALLSDBCHECKSUM		150
// unsupported    {OSPFLOCALLSDBCHECKSUM, ASN_INTEGER, RONLY, ospfLocalLsdbTable_var, 3, {17, 1, 8}},
#define OSPFLOCALLSDBADVERTISEMENT		151
// unsupported    {OSPFLOCALLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, ospfLocalLsdbTable_var, 3, {17, 1, 9}},

// --- ospfVirtLocalLsdbTable
#define OSPFVIRTLOCALLSDBSEQUENCE		152
// unsupported    {OSPFVIRTLOCALLSDBSEQUENCE, ASN_INTEGER, RONLY, ospfVirtLocalLsdbTable_var, 3, {18, 1, 6}},
#define OSPFVIRTLOCALLSDBAGE		153
// unsupported    {OSPFVIRTLOCALLSDBAGE, ASN_INTEGER, RONLY, ospfVirtLocalLsdbTable_var, 3, {18, 1, 7}},
#define OSPFVIRTLOCALLSDBCHECKSUM		154
// unsupported    {OSPFVIRTLOCALLSDBCHECKSUM, ASN_INTEGER, RONLY, ospfVirtLocalLsdbTable_var, 3, {18, 1, 8}},
#define OSPFVIRTLOCALLSDBADVERTISEMENT		155
// unsupported    {OSPFVIRTLOCALLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, ospfVirtLocalLsdbTable_var, 3, {18, 1, 9}},

// --- ospfAsLsdbTable
#define OSPFASLSDBSEQUENCE		156
// unsupported    {OSPFASLSDBSEQUENCE, ASN_INTEGER, RONLY, ospfAsLsdbTable_var, 3, {19, 1, 4}},
#define OSPFASLSDBAGE		157
// unsupported    {OSPFASLSDBAGE, ASN_INTEGER, RONLY, ospfAsLsdbTable_var, 3, {19, 1, 5}},
#define OSPFASLSDBCHECKSUM		158
// unsupported    {OSPFASLSDBCHECKSUM, ASN_INTEGER, RONLY, ospfAsLsdbTable_var, 3, {19, 1, 6}},
#define OSPFASLSDBADVERTISEMENT		159

// --- ospfAsLsaCountTable
    {OSPFASLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, ospfAsLsdbTable_var, 3, {19, 1, 7}},
#define OSPFAREALSACOUNTNUMBER		160
    {OSPFAREALSACOUNTNUMBER, ASN_GAUGE, RONLY, ospfAreaLsaCountTable_var, 3, {20, 1, 3}},
};


/******************************************************************************/
// ucd_snmp_init_ospf()
// Initializes the UCD-SNMP-part of the OSPF-MIB:ospf.
/******************************************************************************/
void ucd_snmp_init_ospf(void)
{
    DEBUGMSGTL(("ospf", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ospf", ospf_variables, variable4, ospf_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ospf_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ospf_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{
    ospfGeneralGroup_scalar_t ospfGeneralGroup_scalar_entry;
    u_char *cp = NULL;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (ospfGeneralGroupScalar_get(&ospfGeneralGroup_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFROUTERID: {
        *write_method = ospfRouterId_write;
        ospfGeneralGroup_scalar_entry.ospfRouterId = htonl(ospfGeneralGroup_scalar_entry.ospfRouterId);
        cp = (u_char *)&ospfGeneralGroup_scalar_entry.ospfRouterId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        ospfGeneralGroup_scalar_entry.ospfRouterId = ntohl(ospfGeneralGroup_scalar_entry.ospfRouterId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFADMINSTAT: {
        *write_method = ospfAdminStat_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfAdminStat;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVERSIONNUMBER: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfVersionNumber;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREABDRRTRSTATUS: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfAreaBdrRtrStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFASBDRRTRSTATUS: {
        *write_method = ospfASBdrRtrStatus_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfASBdrRtrStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXTERNLSACOUNT: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfExternLsaCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFEXTERNLSACKSUMSUM: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfExternLsaCksumSum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFTOSSUPPORT: {
        *write_method = ospfTOSSupport_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfTOSSupport;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFORIGINATENEWLSAS: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfOriginateNewLsas;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFRXNEWLSAS: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfRxNewLsas;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFEXTLSDBLIMIT: {
        *write_method = ospfExtLsdbLimit_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfExtLsdbLimit;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFMULTICASTEXTENSIONS: {
        *write_method = ospfMulticastExtensions_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfMulticastExtensions;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXITOVERFLOWINTERVAL: {
        *write_method = ospfExitOverflowInterval_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfExitOverflowInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFDEMANDEXTENSIONS: {
        *write_method = ospfDemandExtensions_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfDemandExtensions;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFRFC1583COMPATIBILITY: {
        *write_method = ospfRFC1583Compatibility_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRFC1583Compatibility;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFOPAQUELSASUPPORT: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfOpaqueLsaSupport;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFREFERENCEBANDWIDTH: {
        *write_method = ospfReferenceBandwidth_write;
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfReferenceBandwidth;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFRESTARTSUPPORT: {
        *write_method = ospfRestartSupport_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRestartSupport;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFRESTARTINTERVAL: {
        *write_method = ospfRestartInterval_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRestartInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFRESTARTSTRICTLSACHECKING: {
        *write_method = ospfRestartStrictLsaChecking_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRestartStrictLsaChecking;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFRESTARTSTATUS: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRestartStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFRESTARTAGE: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfRestartAge;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFRESTARTEXITREASON: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfRestartExitReason;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFASLSACOUNT: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfAsLsaCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFASLSACKSUMSUM: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfAsLsaCksumSum;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFSTUBROUTERSUPPORT: {
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfStubRouterSupport;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFSTUBROUTERADVERTISEMENT: {
        *write_method = ospfStubRouterAdvertisement_write;
        ospf_global_ret.long_ret = ospfGeneralGroup_scalar_entry.ospfStubRouterAdvertisement;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFDISCONTINUITYTIME: {
        ospf_global_ret.ulong_ret = ospfGeneralGroup_scalar_entry.ospfDiscontinuityTime;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ospf_var\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfAreaTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfAreaTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfAreaTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 4 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfAreaTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaId = ntohl(table_entry->ospfAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaId = ntohl(table_entry->ospfAreaId);
            if (!ospfAreaTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaId = ntohl(table_entry->ospfAreaId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfAreaTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfAreaTable_fillobj(oid     *name,
             size_t  *length,
             ospfAreaTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfAreaId = htonl(table_entry->ospfAreaId);
    cp = (u_char *) &table_entry->ospfAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaId = ntohl(table_entry->ospfAreaId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfAreaTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfAreaTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfAreaTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfAreaTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfAreaTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfAreaTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFAREASTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfAreaStatus_write;
                }
                return NULL;
            }
            if (ospfAreaTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFAREAID: {
        table_entry.ospfAreaId = htonl(table_entry.ospfAreaId);
        cp = (u_char *) &table_entry.ospfAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaId = ntohl(table_entry.ospfAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAUTHTYPE: {
        *write_method = ospfAuthType_write;
        ospf_global_ret.long_ret = table_entry.ospfAuthType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIMPORTASEXTERN: {
        *write_method = ospfImportAsExtern_write;
        ospf_global_ret.long_ret = table_entry.ospfImportAsExtern;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFSPFRUNS: {
        ospf_global_ret.ulong_ret = table_entry.ospfSpfRuns;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFAREABDRRTRCOUNT: {
        ospf_global_ret.ulong_ret = table_entry.ospfAreaBdrRtrCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFASBDRRTRCOUNT: {
        ospf_global_ret.ulong_ret = table_entry.ospfAsBdrRtrCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFAREALSACOUNT: {
        ospf_global_ret.ulong_ret = table_entry.ospfAreaLsaCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFAREALSACKSUMSUM: {
        ospf_global_ret.long_ret = table_entry.ospfAreaLsaCksumSum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREASUMMARY: {
        *write_method = ospfAreaSummary_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaSummary;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREASTATUS: {
        *write_method = ospfAreaStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREANSSATRANSLATORROLE: {
        *write_method = ospfAreaNssaTranslatorRole_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaNssaTranslatorRole;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREANSSATRANSLATORSTATE: {
        ospf_global_ret.long_ret = table_entry.ospfAreaNssaTranslatorState;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREANSSATRANSLATORSTABILITYINTERVAL: {
        *write_method = ospfAreaNssaTranslatorStabilityInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaNssaTranslatorStabilityInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREANSSATRANSLATOREVENTS: {
        ospf_global_ret.ulong_ret = table_entry.ospfAreaNssaTranslatorEvents;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfAreaTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfStubAreaTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfStubAreaTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfStubAreaTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 5 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfStubAreaTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfStubAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfStubAreaId = ntohl(table_entry->ospfStubAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfStubAreaId = ntohl(table_entry->ospfStubAreaId);
            if (!ospfStubAreaTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfStubAreaTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfStubAreaId = ntohl(table_entry->ospfStubAreaId);
    if (*length > op_pos) {
        table_entry->ospfStubTOS = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfStubAreaTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfStubAreaTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfStubAreaTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfStubAreaTable_fillobj(oid     *name,
             size_t  *length,
             ospfStubAreaTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfStubAreaId = htonl(table_entry->ospfStubAreaId);
    cp = (u_char *) &table_entry->ospfStubAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfStubAreaId = ntohl(table_entry->ospfStubAreaId);
    name[name_pos++] = (oid) table_entry->ospfStubTOS;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfStubAreaTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfStubAreaTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfStubAreaTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfStubAreaTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfStubAreaTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfStubAreaTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFSTUBSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfStubStatus_write;
                }
                return NULL;
            }
            if (ospfStubAreaTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFSTUBAREAID: {
        table_entry.ospfStubAreaId = htonl(table_entry.ospfStubAreaId);
        cp = (u_char *) &table_entry.ospfStubAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfStubAreaId = ntohl(table_entry.ospfStubAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFSTUBTOS: {
        ospf_global_ret.long_ret = table_entry.ospfStubTOS;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFSTUBMETRIC: {
        *write_method = ospfStubMetric_write;
        ospf_global_ret.long_ret = table_entry.ospfStubMetric;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFSTUBSTATUS: {
        *write_method = ospfStubStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfStubStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFSTUBMETRICTYPE: {
        *write_method = ospfStubMetricType_write;
        ospf_global_ret.long_ret = table_entry.ospfStubMetricType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfStubAreaTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfLsdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfLsdbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfLsdbTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 13 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 13)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfLsdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfLsdbAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLsdbAreaId = ntohl(table_entry->ospfLsdbAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLsdbAreaId = ntohl(table_entry->ospfLsdbAreaId);
            if (!ospfLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLsdbAreaId = ntohl(table_entry->ospfLsdbAreaId);
    if (*length > op_pos) {
        table_entry->ospfLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfLsdbLsid;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLsdbLsid = ntohl(table_entry->ospfLsdbLsid);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLsdbLsid = ntohl(table_entry->ospfLsdbLsid);
            if (!ospfLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLsdbLsid = ntohl(table_entry->ospfLsdbLsid);
    len = 4;
    cp = (u_char *) &table_entry->ospfLsdbRouterId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLsdbRouterId = ntohl(table_entry->ospfLsdbRouterId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLsdbRouterId = ntohl(table_entry->ospfLsdbRouterId);
            if (!ospfLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLsdbRouterId = ntohl(table_entry->ospfLsdbRouterId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfLsdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfLsdbTable_fillobj(oid     *name,
             size_t  *length,
             ospfLsdbTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfLsdbAreaId = htonl(table_entry->ospfLsdbAreaId);
    cp = (u_char *) &table_entry->ospfLsdbAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLsdbAreaId = ntohl(table_entry->ospfLsdbAreaId);
    name[name_pos++] = (oid) table_entry->ospfLsdbType;
    len = 4;
    table_entry->ospfLsdbLsid = htonl(table_entry->ospfLsdbLsid);
    cp = (u_char *) &table_entry->ospfLsdbLsid;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLsdbLsid = ntohl(table_entry->ospfLsdbLsid);
    len = 4;
    table_entry->ospfLsdbRouterId = htonl(table_entry->ospfLsdbRouterId);
    cp = (u_char *) &table_entry->ospfLsdbRouterId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLsdbRouterId = ntohl(table_entry->ospfLsdbRouterId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfLsdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfLsdbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfLsdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfLsdbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfLsdbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFLSDBAREAID: {
        table_entry.ospfLsdbAreaId = htonl(table_entry.ospfLsdbAreaId);
        cp = (u_char *) &table_entry.ospfLsdbAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfLsdbAreaId = ntohl(table_entry.ospfLsdbAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFLSDBTYPE: {
        ospf_global_ret.long_ret = table_entry.ospfLsdbType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLSDBLSID: {
        table_entry.ospfLsdbLsid = htonl(table_entry.ospfLsdbLsid);
        cp = (u_char *) &table_entry.ospfLsdbLsid;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfLsdbLsid = ntohl(table_entry.ospfLsdbLsid);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFLSDBROUTERID: {
        table_entry.ospfLsdbRouterId = htonl(table_entry.ospfLsdbRouterId);
        cp = (u_char *) &table_entry.ospfLsdbRouterId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfLsdbRouterId = ntohl(table_entry.ospfLsdbRouterId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFLSDBSEQUENCE: {
        ospf_global_ret.long_ret = table_entry.ospfLsdbSequence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLSDBAGE: {
        ospf_global_ret.long_ret = table_entry.ospfLsdbAge;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLSDBCHECKSUM: {
        ospf_global_ret.long_ret = table_entry.ospfLsdbChecksum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLSDBADVERTISEMENT: {
        *var_len = table_entry.ospfLsdbAdvertisement_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfLsdbAdvertisement, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfLsdbTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfAreaRangeTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfAreaRangeTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfAreaRangeTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 8 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 8)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfAreaRangeTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfAreaRangeAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaRangeAreaId = ntohl(table_entry->ospfAreaRangeAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaRangeAreaId = ntohl(table_entry->ospfAreaRangeAreaId);
            if (!ospfAreaRangeTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaRangeTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaRangeAreaId = ntohl(table_entry->ospfAreaRangeAreaId);
    len = 4;
    cp = (u_char *) &table_entry->ospfAreaRangeNet;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaRangeNet = ntohl(table_entry->ospfAreaRangeNet);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaRangeNet = ntohl(table_entry->ospfAreaRangeNet);
            if (!ospfAreaRangeTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaRangeTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaRangeNet = ntohl(table_entry->ospfAreaRangeNet);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfAreaRangeTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfAreaRangeTable_fillobj(oid     *name,
             size_t  *length,
             ospfAreaRangeTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfAreaRangeAreaId = htonl(table_entry->ospfAreaRangeAreaId);
    cp = (u_char *) &table_entry->ospfAreaRangeAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaRangeAreaId = ntohl(table_entry->ospfAreaRangeAreaId);
    len = 4;
    table_entry->ospfAreaRangeNet = htonl(table_entry->ospfAreaRangeNet);
    cp = (u_char *) &table_entry->ospfAreaRangeNet;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaRangeNet = ntohl(table_entry->ospfAreaRangeNet);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfAreaRangeTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfAreaRangeTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfAreaRangeTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfAreaRangeTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfAreaRangeTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfAreaRangeTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFAREARANGESTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfAreaRangeStatus_write;
                }
                return NULL;
            }
            if (ospfAreaRangeTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFAREARANGEAREAID: {
        table_entry.ospfAreaRangeAreaId = htonl(table_entry.ospfAreaRangeAreaId);
        cp = (u_char *) &table_entry.ospfAreaRangeAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaRangeAreaId = ntohl(table_entry.ospfAreaRangeAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREARANGENET: {
        table_entry.ospfAreaRangeNet = htonl(table_entry.ospfAreaRangeNet);
        cp = (u_char *) &table_entry.ospfAreaRangeNet;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaRangeNet = ntohl(table_entry.ospfAreaRangeNet);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREARANGEMASK: {
        *write_method = ospfAreaRangeMask_write;
        table_entry.ospfAreaRangeMask = htonl(table_entry.ospfAreaRangeMask);
        cp = (u_char *) &table_entry.ospfAreaRangeMask;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaRangeMask = ntohl(table_entry.ospfAreaRangeMask);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREARANGESTATUS: {
        *write_method = ospfAreaRangeStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaRangeStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREARANGEEFFECT: {
        *write_method = ospfAreaRangeEffect_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaRangeEffect;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfAreaRangeTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfHostTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfHostTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfHostTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 5 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfHostTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfHostIpAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfHostIpAddress = ntohl(table_entry->ospfHostIpAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfHostIpAddress = ntohl(table_entry->ospfHostIpAddress);
            if (!ospfHostTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfHostTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfHostIpAddress = ntohl(table_entry->ospfHostIpAddress);
    if (*length > op_pos) {
        table_entry->ospfHostTOS = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfHostTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfHostTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfHostTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfHostTable_fillobj(oid     *name,
             size_t  *length,
             ospfHostTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfHostIpAddress = htonl(table_entry->ospfHostIpAddress);
    cp = (u_char *) &table_entry->ospfHostIpAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfHostIpAddress = ntohl(table_entry->ospfHostIpAddress);
    name[name_pos++] = (oid) table_entry->ospfHostTOS;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfHostTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfHostTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfHostTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfHostTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfHostTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfHostTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFHOSTSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfHostStatus_write;
                }
                return NULL;
            }
            if (ospfHostTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFHOSTIPADDRESS: {
        table_entry.ospfHostIpAddress = htonl(table_entry.ospfHostIpAddress);
        cp = (u_char *) &table_entry.ospfHostIpAddress;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfHostIpAddress = ntohl(table_entry.ospfHostIpAddress);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFHOSTTOS: {
        ospf_global_ret.long_ret = table_entry.ospfHostTOS;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFHOSTMETRIC: {
        *write_method = ospfHostMetric_write;
        ospf_global_ret.long_ret = table_entry.ospfHostMetric;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFHOSTSTATUS: {
        *write_method = ospfHostStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfHostStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFHOSTAREAID: {
        table_entry.ospfHostAreaID = htonl(table_entry.ospfHostAreaID);
        cp = (u_char *) &table_entry.ospfHostAreaID;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfHostAreaID = ntohl(table_entry.ospfHostAreaID);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFHOSTCFGAREAID: {
        *write_method = ospfHostCfgAreaID_write;
        table_entry.ospfHostCfgAreaID = htonl(table_entry.ospfHostCfgAreaID);
        cp = (u_char *) &table_entry.ospfHostCfgAreaID;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfHostCfgAreaID = ntohl(table_entry.ospfHostCfgAreaID);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfHostTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfIfTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfIfTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfIfTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 5 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfIfTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfIfIpAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfIfIpAddress = ntohl(table_entry->ospfIfIpAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfIfIpAddress = ntohl(table_entry->ospfIfIpAddress);
            if (!ospfIfTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfIfTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfIfIpAddress = ntohl(table_entry->ospfIfIpAddress);
    if (*length > op_pos) {
        table_entry->ospfAddressLessIf = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfIfTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfIfTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfIfTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfIfTable_fillobj(oid     *name,
             size_t  *length,
             ospfIfTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfIfIpAddress = htonl(table_entry->ospfIfIpAddress);
    cp = (u_char *) &table_entry->ospfIfIpAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfIfIpAddress = ntohl(table_entry->ospfIfIpAddress);
    name[name_pos++] = (oid) table_entry->ospfAddressLessIf;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfIfTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfIfTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfIfTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfIfTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfIfTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfIfTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFIFSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfIfStatus_write;
                }
                return NULL;
            }
            if (ospfIfTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFIFIPADDRESS: {
        table_entry.ospfIfIpAddress = htonl(table_entry.ospfIfIpAddress);
        cp = (u_char *) &table_entry.ospfIfIpAddress;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfIpAddress = ntohl(table_entry.ospfIfIpAddress);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFADDRESSLESSIF: {
        ospf_global_ret.long_ret = table_entry.ospfAddressLessIf;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFAREAID: {
        *write_method = ospfIfAreaId_write;
        table_entry.ospfIfAreaId = htonl(table_entry.ospfIfAreaId);
        cp = (u_char *) &table_entry.ospfIfAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfAreaId = ntohl(table_entry.ospfIfAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFIFTYPE: {
        *write_method = ospfIfType_write;
        ospf_global_ret.long_ret = table_entry.ospfIfType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFADMINSTAT: {
        *write_method = ospfIfAdminStat_write;
        ospf_global_ret.long_ret = table_entry.ospfIfAdminStat;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFRTRPRIORITY: {
        *write_method = ospfIfRtrPriority_write;
        ospf_global_ret.long_ret = table_entry.ospfIfRtrPriority;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFTRANSITDELAY: {
        *write_method = ospfIfTransitDelay_write;
        ospf_global_ret.long_ret = table_entry.ospfIfTransitDelay;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFRETRANSINTERVAL: {
        *write_method = ospfIfRetransInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfIfRetransInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFHELLOINTERVAL: {
        *write_method = ospfIfHelloInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfIfHelloInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFRTRDEADINTERVAL: {
        *write_method = ospfIfRtrDeadInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfIfRtrDeadInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFPOLLINTERVAL: {
        *write_method = ospfIfPollInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfIfPollInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFSTATE: {
        ospf_global_ret.long_ret = table_entry.ospfIfState;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFDESIGNATEDROUTER: {
        table_entry.ospfIfDesignatedRouter = htonl(table_entry.ospfIfDesignatedRouter);
        cp = (u_char *) &table_entry.ospfIfDesignatedRouter;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfDesignatedRouter = ntohl(table_entry.ospfIfDesignatedRouter);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFIFBACKUPDESIGNATEDROUTER: {
        table_entry.ospfIfBackupDesignatedRouter = htonl(table_entry.ospfIfBackupDesignatedRouter);
        cp = (u_char *) &table_entry.ospfIfBackupDesignatedRouter;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfBackupDesignatedRouter = ntohl(table_entry.ospfIfBackupDesignatedRouter);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFIFEVENTS: {
        ospf_global_ret.ulong_ret = table_entry.ospfIfEvents;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFIFAUTHKEY: {
        *write_method = ospfIfAuthKey_write;
        *var_len = table_entry.ospfIfAuthKey_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfIfAuthKey, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    case OSPFIFSTATUS: {
        *write_method = ospfIfStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfIfStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFMULTICASTFORWARDING: {
        *write_method = ospfIfMulticastForwarding_write;
        ospf_global_ret.long_ret = table_entry.ospfIfMulticastForwarding;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFDEMAND: {
        *write_method = ospfIfDemand_write;
        ospf_global_ret.long_ret = table_entry.ospfIfDemand;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFAUTHTYPE: {
        *write_method = ospfIfAuthType_write;
        ospf_global_ret.long_ret = table_entry.ospfIfAuthType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFLSACOUNT: {
        ospf_global_ret.ulong_ret = table_entry.ospfIfLsaCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFIFLSACKSUMSUM: {
        ospf_global_ret.ulong_ret = table_entry.ospfIfLsaCksumSum;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFIFDESIGNATEDROUTERID: {
        table_entry.ospfIfDesignatedRouterId = htonl(table_entry.ospfIfDesignatedRouterId);
        cp = (u_char *) &table_entry.ospfIfDesignatedRouterId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfDesignatedRouterId = ntohl(table_entry.ospfIfDesignatedRouterId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFIFBACKUPDESIGNATEDROUTERID: {
        table_entry.ospfIfBackupDesignatedRouterId = htonl(table_entry.ospfIfBackupDesignatedRouterId);
        cp = (u_char *) &table_entry.ospfIfBackupDesignatedRouterId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfBackupDesignatedRouterId = ntohl(table_entry.ospfIfBackupDesignatedRouterId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfIfTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfIfMetricTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfIfMetricTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfIfMetricTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 6 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 6)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfIfMetricTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfIfMetricIpAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfIfMetricIpAddress = ntohl(table_entry->ospfIfMetricIpAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfIfMetricIpAddress = ntohl(table_entry->ospfIfMetricIpAddress);
            if (!ospfIfMetricTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfIfMetricTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfIfMetricIpAddress = ntohl(table_entry->ospfIfMetricIpAddress);
    if (*length > op_pos) {
        table_entry->ospfIfMetricAddressLessIf = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfIfMetricTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfIfMetricTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ospfIfMetricTOS = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfIfMetricTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfIfMetricTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfIfMetricTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfIfMetricTable_fillobj(oid     *name,
             size_t  *length,
             ospfIfMetricTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfIfMetricIpAddress = htonl(table_entry->ospfIfMetricIpAddress);
    cp = (u_char *) &table_entry->ospfIfMetricIpAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfIfMetricIpAddress = ntohl(table_entry->ospfIfMetricIpAddress);
    name[name_pos++] = (oid) table_entry->ospfIfMetricAddressLessIf;
    name[name_pos++] = (oid) table_entry->ospfIfMetricTOS;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfIfMetricTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfIfMetricTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfIfMetricTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfIfMetricTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfIfMetricTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfIfMetricTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFIFMETRICSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfIfMetricStatus_write;
                }
                return NULL;
            }
            if (ospfIfMetricTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFIFMETRICIPADDRESS: {
        table_entry.ospfIfMetricIpAddress = htonl(table_entry.ospfIfMetricIpAddress);
        cp = (u_char *) &table_entry.ospfIfMetricIpAddress;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfIfMetricIpAddress = ntohl(table_entry.ospfIfMetricIpAddress);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFIFMETRICADDRESSLESSIF: {
        ospf_global_ret.long_ret = table_entry.ospfIfMetricAddressLessIf;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFMETRICTOS: {
        ospf_global_ret.long_ret = table_entry.ospfIfMetricTOS;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFMETRICVALUE: {
        *write_method = ospfIfMetricValue_write;
        ospf_global_ret.long_ret = table_entry.ospfIfMetricValue;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFIFMETRICSTATUS: {
        *write_method = ospfIfMetricStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfIfMetricStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfIfMetricTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfVirtIfTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfVirtIfTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfVirtIfTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 8 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 8)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfVirtIfTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfVirtIfAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtIfAreaId = ntohl(table_entry->ospfVirtIfAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtIfAreaId = ntohl(table_entry->ospfVirtIfAreaId);
            if (!ospfVirtIfTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtIfTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtIfAreaId = ntohl(table_entry->ospfVirtIfAreaId);
    len = 4;
    cp = (u_char *) &table_entry->ospfVirtIfNeighbor;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtIfNeighbor = ntohl(table_entry->ospfVirtIfNeighbor);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtIfNeighbor = ntohl(table_entry->ospfVirtIfNeighbor);
            if (!ospfVirtIfTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtIfTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtIfNeighbor = ntohl(table_entry->ospfVirtIfNeighbor);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfVirtIfTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfVirtIfTable_fillobj(oid     *name,
             size_t  *length,
             ospfVirtIfTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfVirtIfAreaId = htonl(table_entry->ospfVirtIfAreaId);
    cp = (u_char *) &table_entry->ospfVirtIfAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtIfAreaId = ntohl(table_entry->ospfVirtIfAreaId);
    len = 4;
    table_entry->ospfVirtIfNeighbor = htonl(table_entry->ospfVirtIfNeighbor);
    cp = (u_char *) &table_entry->ospfVirtIfNeighbor;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtIfNeighbor = ntohl(table_entry->ospfVirtIfNeighbor);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfVirtIfTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfVirtIfTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfVirtIfTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfVirtIfTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfVirtIfTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfVirtIfTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFVIRTIFSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfVirtIfStatus_write;
                }
                return NULL;
            }
            if (ospfVirtIfTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFVIRTIFAREAID: {
        table_entry.ospfVirtIfAreaId = htonl(table_entry.ospfVirtIfAreaId);
        cp = (u_char *) &table_entry.ospfVirtIfAreaId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfVirtIfAreaId = ntohl(table_entry.ospfVirtIfAreaId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFVIRTIFNEIGHBOR: {
        table_entry.ospfVirtIfNeighbor = htonl(table_entry.ospfVirtIfNeighbor);
        cp = (u_char *) &table_entry.ospfVirtIfNeighbor;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfVirtIfNeighbor = ntohl(table_entry.ospfVirtIfNeighbor);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFVIRTIFTRANSITDELAY: {
        *write_method = ospfVirtIfTransitDelay_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfTransitDelay;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFRETRANSINTERVAL: {
        *write_method = ospfVirtIfRetransInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfRetransInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFHELLOINTERVAL: {
        *write_method = ospfVirtIfHelloInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfHelloInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFRTRDEADINTERVAL: {
        *write_method = ospfVirtIfRtrDeadInterval_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfRtrDeadInterval;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFSTATE: {
        ospf_global_ret.long_ret = table_entry.ospfVirtIfState;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFEVENTS: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtIfEvents;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFVIRTIFAUTHKEY: {
        *write_method = ospfVirtIfAuthKey_write;
        *var_len = table_entry.ospfVirtIfAuthKey_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfVirtIfAuthKey, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    case OSPFVIRTIFSTATUS: {
        *write_method = ospfVirtIfStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFAUTHTYPE: {
        *write_method = ospfVirtIfAuthType_write;
        ospf_global_ret.long_ret = table_entry.ospfVirtIfAuthType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTIFLSACOUNT: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtIfLsaCount;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFVIRTIFLSACKSUMSUM: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtIfLsaCksumSum;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfVirtIfTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfNbrTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfNbrTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfNbrTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 5 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfNbrTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfNbrIpAddr;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfNbrIpAddr = ntohl(table_entry->ospfNbrIpAddr);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfNbrIpAddr = ntohl(table_entry->ospfNbrIpAddr);
            if (!ospfNbrTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfNbrTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfNbrIpAddr = ntohl(table_entry->ospfNbrIpAddr);
    if (*length > op_pos) {
        table_entry->ospfNbrAddressLessIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfNbrTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfNbrTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfNbrTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfNbrTable_fillobj(oid     *name,
             size_t  *length,
             ospfNbrTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfNbrIpAddr = htonl(table_entry->ospfNbrIpAddr);
    cp = (u_char *) &table_entry->ospfNbrIpAddr;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfNbrIpAddr = ntohl(table_entry->ospfNbrIpAddr);
    name[name_pos++] = (oid) table_entry->ospfNbrAddressLessIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfNbrTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfNbrTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfNbrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfNbrTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfNbrTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfNbrTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFNBMANBRSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfNbmaNbrStatus_write;
                }
                return NULL;
            }
            if (ospfNbrTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFNBRIPADDR: {
        table_entry.ospfNbrIpAddr = htonl(table_entry.ospfNbrIpAddr);
        cp = (u_char *) &table_entry.ospfNbrIpAddr;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfNbrIpAddr = ntohl(table_entry.ospfNbrIpAddr);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFNBRADDRESSLESSINDEX: {
        ospf_global_ret.long_ret = table_entry.ospfNbrAddressLessIndex;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRRTRID: {
        table_entry.ospfNbrRtrId = htonl(table_entry.ospfNbrRtrId);
        cp = (u_char *) &table_entry.ospfNbrRtrId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfNbrRtrId = ntohl(table_entry.ospfNbrRtrId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFNBROPTIONS: {
        ospf_global_ret.long_ret = table_entry.ospfNbrOptions;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRPRIORITY: {
        *write_method = ospfNbrPriority_write;
        ospf_global_ret.long_ret = table_entry.ospfNbrPriority;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRSTATE: {
        ospf_global_ret.long_ret = table_entry.ospfNbrState;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBREVENTS: {
        ospf_global_ret.ulong_ret = table_entry.ospfNbrEvents;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFNBRLSRETRANSQLEN: {
        ospf_global_ret.ulong_ret = table_entry.ospfNbrLsRetransQLen;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFNBMANBRSTATUS: {
        *write_method = ospfNbmaNbrStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfNbmaNbrStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBMANBRPERMANENCE: {
        ospf_global_ret.long_ret = table_entry.ospfNbmaNbrPermanence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRHELLOSUPPRESSED: {
        ospf_global_ret.long_ret = table_entry.ospfNbrHelloSuppressed;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRRESTARTHELPERSTATUS: {
        ospf_global_ret.long_ret = table_entry.ospfNbrRestartHelperStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFNBRRESTARTHELPERAGE: {
        ospf_global_ret.ulong_ret = table_entry.ospfNbrRestartHelperAge;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFNBRRESTARTHELPEREXITREASON: {
        ospf_global_ret.long_ret = table_entry.ospfNbrRestartHelperExitReason;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfNbrTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfVirtNbrTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfVirtNbrTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfVirtNbrTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 8 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 8)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfVirtNbrTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfVirtNbrArea;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtNbrArea = ntohl(table_entry->ospfVirtNbrArea);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtNbrArea = ntohl(table_entry->ospfVirtNbrArea);
            if (!ospfVirtNbrTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtNbrTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtNbrArea = ntohl(table_entry->ospfVirtNbrArea);
    len = 4;
    cp = (u_char *) &table_entry->ospfVirtNbrRtrId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtNbrRtrId = ntohl(table_entry->ospfVirtNbrRtrId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtNbrRtrId = ntohl(table_entry->ospfVirtNbrRtrId);
            if (!ospfVirtNbrTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtNbrTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtNbrRtrId = ntohl(table_entry->ospfVirtNbrRtrId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfVirtNbrTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfVirtNbrTable_fillobj(oid     *name,
             size_t  *length,
             ospfVirtNbrTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfVirtNbrArea = htonl(table_entry->ospfVirtNbrArea);
    cp = (u_char *) &table_entry->ospfVirtNbrArea;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtNbrArea = ntohl(table_entry->ospfVirtNbrArea);
    len = 4;
    table_entry->ospfVirtNbrRtrId = htonl(table_entry->ospfVirtNbrRtrId);
    cp = (u_char *) &table_entry->ospfVirtNbrRtrId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtNbrRtrId = ntohl(table_entry->ospfVirtNbrRtrId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfVirtNbrTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfVirtNbrTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfVirtNbrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfVirtNbrTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfVirtNbrTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfVirtNbrTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfVirtNbrTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFVIRTNBRAREA: {
        table_entry.ospfVirtNbrArea = htonl(table_entry.ospfVirtNbrArea);
        cp = (u_char *) &table_entry.ospfVirtNbrArea;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfVirtNbrArea = ntohl(table_entry.ospfVirtNbrArea);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFVIRTNBRRTRID: {
        table_entry.ospfVirtNbrRtrId = htonl(table_entry.ospfVirtNbrRtrId);
        cp = (u_char *) &table_entry.ospfVirtNbrRtrId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfVirtNbrRtrId = ntohl(table_entry.ospfVirtNbrRtrId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFVIRTNBRIPADDR: {
        table_entry.ospfVirtNbrIpAddr = htonl(table_entry.ospfVirtNbrIpAddr);
        cp = (u_char *) &table_entry.ospfVirtNbrIpAddr;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfVirtNbrIpAddr = ntohl(table_entry.ospfVirtNbrIpAddr);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFVIRTNBROPTIONS: {
        ospf_global_ret.long_ret = table_entry.ospfVirtNbrOptions;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTNBRSTATE: {
        ospf_global_ret.long_ret = table_entry.ospfVirtNbrState;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTNBREVENTS: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtNbrEvents;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFVIRTNBRLSRETRANSQLEN: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtNbrLsRetransQLen;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFVIRTNBRHELLOSUPPRESSED: {
        ospf_global_ret.long_ret = table_entry.ospfVirtNbrHelloSuppressed;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTNBRRESTARTHELPERSTATUS: {
        ospf_global_ret.long_ret = table_entry.ospfVirtNbrRestartHelperStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTNBRRESTARTHELPERAGE: {
        ospf_global_ret.ulong_ret = table_entry.ospfVirtNbrRestartHelperAge;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    case OSPFVIRTNBRRESTARTHELPEREXITREASON: {
        ospf_global_ret.long_ret = table_entry.ospfVirtNbrRestartHelperExitReason;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfVirtNbrTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfExtLsdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfExtLsdbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfExtLsdbTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 9 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 9)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfExtLsdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ospfExtLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfExtLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfExtLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfExtLsdbLsid;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfExtLsdbLsid = ntohl(table_entry->ospfExtLsdbLsid);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfExtLsdbLsid = ntohl(table_entry->ospfExtLsdbLsid);
            if (!ospfExtLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfExtLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfExtLsdbLsid = ntohl(table_entry->ospfExtLsdbLsid);
    len = 4;
    cp = (u_char *) &table_entry->ospfExtLsdbRouterId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfExtLsdbRouterId = ntohl(table_entry->ospfExtLsdbRouterId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfExtLsdbRouterId = ntohl(table_entry->ospfExtLsdbRouterId);
            if (!ospfExtLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfExtLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfExtLsdbRouterId = ntohl(table_entry->ospfExtLsdbRouterId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfExtLsdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfExtLsdbTable_fillobj(oid     *name,
             size_t  *length,
             ospfExtLsdbTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    name[name_pos++] = (oid) table_entry->ospfExtLsdbType;
    len = 4;
    table_entry->ospfExtLsdbLsid = htonl(table_entry->ospfExtLsdbLsid);
    cp = (u_char *) &table_entry->ospfExtLsdbLsid;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfExtLsdbLsid = ntohl(table_entry->ospfExtLsdbLsid);
    len = 4;
    table_entry->ospfExtLsdbRouterId = htonl(table_entry->ospfExtLsdbRouterId);
    cp = (u_char *) &table_entry->ospfExtLsdbRouterId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfExtLsdbRouterId = ntohl(table_entry->ospfExtLsdbRouterId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfExtLsdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfExtLsdbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfExtLsdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfExtLsdbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfExtLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfExtLsdbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfExtLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFEXTLSDBTYPE: {
        ospf_global_ret.long_ret = table_entry.ospfExtLsdbType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXTLSDBLSID: {
        table_entry.ospfExtLsdbLsid = htonl(table_entry.ospfExtLsdbLsid);
        cp = (u_char *) &table_entry.ospfExtLsdbLsid;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfExtLsdbLsid = ntohl(table_entry.ospfExtLsdbLsid);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFEXTLSDBROUTERID: {
        table_entry.ospfExtLsdbRouterId = htonl(table_entry.ospfExtLsdbRouterId);
        cp = (u_char *) &table_entry.ospfExtLsdbRouterId;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfExtLsdbRouterId = ntohl(table_entry.ospfExtLsdbRouterId);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFEXTLSDBSEQUENCE: {
        ospf_global_ret.long_ret = table_entry.ospfExtLsdbSequence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXTLSDBAGE: {
        ospf_global_ret.long_ret = table_entry.ospfExtLsdbAge;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXTLSDBCHECKSUM: {
        ospf_global_ret.long_ret = table_entry.ospfExtLsdbChecksum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFEXTLSDBADVERTISEMENT: {
        *var_len = table_entry.ospfExtLsdbAdvertisement_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfExtLsdbAdvertisement, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfExtLsdbTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfAreaAggregateTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfAreaAggregateTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfAreaAggregateTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 13 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 13)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfAreaAggregateTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfAreaAggregateAreaID;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaAggregateAreaID = ntohl(table_entry->ospfAreaAggregateAreaID);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaAggregateAreaID = ntohl(table_entry->ospfAreaAggregateAreaID);
            if (!ospfAreaAggregateTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaAggregateTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaAggregateAreaID = ntohl(table_entry->ospfAreaAggregateAreaID);
    if (*length > op_pos) {
        table_entry->ospfAreaAggregateLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfAreaAggregateTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfAreaAggregateTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfAreaAggregateNet;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaAggregateNet = ntohl(table_entry->ospfAreaAggregateNet);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaAggregateNet = ntohl(table_entry->ospfAreaAggregateNet);
            if (!ospfAreaAggregateTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaAggregateTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaAggregateNet = ntohl(table_entry->ospfAreaAggregateNet);
    len = 4;
    cp = (u_char *) &table_entry->ospfAreaAggregateMask;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaAggregateMask = ntohl(table_entry->ospfAreaAggregateMask);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaAggregateMask = ntohl(table_entry->ospfAreaAggregateMask);
            if (!ospfAreaAggregateTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaAggregateTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaAggregateMask = ntohl(table_entry->ospfAreaAggregateMask);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfAreaAggregateTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfAreaAggregateTable_fillobj(oid     *name,
             size_t  *length,
             ospfAreaAggregateTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfAreaAggregateAreaID = htonl(table_entry->ospfAreaAggregateAreaID);
    cp = (u_char *) &table_entry->ospfAreaAggregateAreaID;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaAggregateAreaID = ntohl(table_entry->ospfAreaAggregateAreaID);
    name[name_pos++] = (oid) table_entry->ospfAreaAggregateLsdbType;
    len = 4;
    table_entry->ospfAreaAggregateNet = htonl(table_entry->ospfAreaAggregateNet);
    cp = (u_char *) &table_entry->ospfAreaAggregateNet;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaAggregateNet = ntohl(table_entry->ospfAreaAggregateNet);
    len = 4;
    table_entry->ospfAreaAggregateMask = htonl(table_entry->ospfAreaAggregateMask);
    cp = (u_char *) &table_entry->ospfAreaAggregateMask;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaAggregateMask = ntohl(table_entry->ospfAreaAggregateMask);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfAreaAggregateTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfAreaAggregateTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    ospfAreaAggregateTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfAreaAggregateTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfAreaAggregateTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfAreaAggregateTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == OSPFAREAAGGREGATESTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ospfAreaAggregateStatus_write;
                }
                return NULL;
            }
            if (ospfAreaAggregateTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFAREAAGGREGATEAREAID: {
        table_entry.ospfAreaAggregateAreaID = htonl(table_entry.ospfAreaAggregateAreaID);
        cp = (u_char *) &table_entry.ospfAreaAggregateAreaID;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaAggregateAreaID = ntohl(table_entry.ospfAreaAggregateAreaID);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREAAGGREGATELSDBTYPE: {
        ospf_global_ret.long_ret = table_entry.ospfAreaAggregateLsdbType;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREAAGGREGATENET: {
        table_entry.ospfAreaAggregateNet = htonl(table_entry.ospfAreaAggregateNet);
        cp = (u_char *) &table_entry.ospfAreaAggregateNet;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaAggregateNet = ntohl(table_entry.ospfAreaAggregateNet);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREAAGGREGATEMASK: {
        table_entry.ospfAreaAggregateMask = htonl(table_entry.ospfAreaAggregateMask);
        cp = (u_char *) &table_entry.ospfAreaAggregateMask;
        ospf_global_ret.ip_string_ret[0] = *cp++;
        ospf_global_ret.ip_string_ret[1] = *cp++;
        ospf_global_ret.ip_string_ret[2] = *cp++;
        ospf_global_ret.ip_string_ret[3] = *cp;
        table_entry.ospfAreaAggregateMask = ntohl(table_entry.ospfAreaAggregateMask);
        *var_len = sizeof(ospf_global_ret.ip_string_ret);
        return ospf_global_ret.ip_string_ret;
    }
    case OSPFAREAAGGREGATESTATUS: {
        *write_method = ospfAreaAggregateStatus_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaAggregateStatus;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREAAGGREGATEEFFECT: {
        *write_method = ospfAreaAggregateEffect_write;
        ospf_global_ret.long_ret = table_entry.ospfAreaAggregateEffect;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFAREAAGGREGATEEXTROUTETAG: {
        *write_method = ospfAreaAggregateExtRouteTag_write;
        ospf_global_ret.ulong_ret = table_entry.ospfAreaAggregateExtRouteTag;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfAreaAggregateTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfLocalLsdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfLocalLsdbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfLocalLsdbTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 14 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 14)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfLocalLsdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfLocalLsdbIpAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLocalLsdbIpAddress = ntohl(table_entry->ospfLocalLsdbIpAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLocalLsdbIpAddress = ntohl(table_entry->ospfLocalLsdbIpAddress);
            if (!ospfLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLocalLsdbIpAddress = ntohl(table_entry->ospfLocalLsdbIpAddress);
    if (*length > op_pos) {
        table_entry->ospfLocalLsdbAddressLessIf = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfLocalLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfLocalLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ospfLocalLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfLocalLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfLocalLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfLocalLsdbLsid;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLocalLsdbLsid = ntohl(table_entry->ospfLocalLsdbLsid);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLocalLsdbLsid = ntohl(table_entry->ospfLocalLsdbLsid);
            if (!ospfLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLocalLsdbLsid = ntohl(table_entry->ospfLocalLsdbLsid);
    len = 4;
    cp = (u_char *) &table_entry->ospfLocalLsdbRouterId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfLocalLsdbRouterId = ntohl(table_entry->ospfLocalLsdbRouterId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfLocalLsdbRouterId = ntohl(table_entry->ospfLocalLsdbRouterId);
            if (!ospfLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfLocalLsdbRouterId = ntohl(table_entry->ospfLocalLsdbRouterId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfLocalLsdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfLocalLsdbTable_fillobj(oid     *name,
             size_t  *length,
             ospfLocalLsdbTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfLocalLsdbIpAddress = htonl(table_entry->ospfLocalLsdbIpAddress);
    cp = (u_char *) &table_entry->ospfLocalLsdbIpAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLocalLsdbIpAddress = ntohl(table_entry->ospfLocalLsdbIpAddress);
    name[name_pos++] = (oid) table_entry->ospfLocalLsdbAddressLessIf;
    name[name_pos++] = (oid) table_entry->ospfLocalLsdbType;
    len = 4;
    table_entry->ospfLocalLsdbLsid = htonl(table_entry->ospfLocalLsdbLsid);
    cp = (u_char *) &table_entry->ospfLocalLsdbLsid;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLocalLsdbLsid = ntohl(table_entry->ospfLocalLsdbLsid);
    len = 4;
    table_entry->ospfLocalLsdbRouterId = htonl(table_entry->ospfLocalLsdbRouterId);
    cp = (u_char *) &table_entry->ospfLocalLsdbRouterId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfLocalLsdbRouterId = ntohl(table_entry->ospfLocalLsdbRouterId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfLocalLsdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfLocalLsdbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ospfLocalLsdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfLocalLsdbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfLocalLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfLocalLsdbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfLocalLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFLOCALLSDBSEQUENCE: {
        ospf_global_ret.long_ret = table_entry.ospfLocalLsdbSequence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLOCALLSDBAGE: {
        ospf_global_ret.long_ret = table_entry.ospfLocalLsdbAge;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLOCALLSDBCHECKSUM: {
        ospf_global_ret.long_ret = table_entry.ospfLocalLsdbChecksum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFLOCALLSDBADVERTISEMENT: {
        *var_len = table_entry.ospfLocalLsdbAdvertisement_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfLocalLsdbAdvertisement, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfLocalLsdbTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfVirtLocalLsdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfVirtLocalLsdbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfVirtLocalLsdbTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 17 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 17)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfVirtLocalLsdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbTransitArea;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtLocalLsdbTransitArea = ntohl(table_entry->ospfVirtLocalLsdbTransitArea);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtLocalLsdbTransitArea = ntohl(table_entry->ospfVirtLocalLsdbTransitArea);
            if (!ospfVirtLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtLocalLsdbTransitArea = ntohl(table_entry->ospfVirtLocalLsdbTransitArea);
    len = 4;
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbNeighbor;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtLocalLsdbNeighbor = ntohl(table_entry->ospfVirtLocalLsdbNeighbor);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtLocalLsdbNeighbor = ntohl(table_entry->ospfVirtLocalLsdbNeighbor);
            if (!ospfVirtLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtLocalLsdbNeighbor = ntohl(table_entry->ospfVirtLocalLsdbNeighbor);
    if (*length > op_pos) {
        table_entry->ospfVirtLocalLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfVirtLocalLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfVirtLocalLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbLsid;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtLocalLsdbLsid = ntohl(table_entry->ospfVirtLocalLsdbLsid);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtLocalLsdbLsid = ntohl(table_entry->ospfVirtLocalLsdbLsid);
            if (!ospfVirtLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtLocalLsdbLsid = ntohl(table_entry->ospfVirtLocalLsdbLsid);
    len = 4;
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbRouterId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfVirtLocalLsdbRouterId = ntohl(table_entry->ospfVirtLocalLsdbRouterId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfVirtLocalLsdbRouterId = ntohl(table_entry->ospfVirtLocalLsdbRouterId);
            if (!ospfVirtLocalLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfVirtLocalLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfVirtLocalLsdbRouterId = ntohl(table_entry->ospfVirtLocalLsdbRouterId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfVirtLocalLsdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfVirtLocalLsdbTable_fillobj(oid     *name,
             size_t  *length,
             ospfVirtLocalLsdbTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfVirtLocalLsdbTransitArea = htonl(table_entry->ospfVirtLocalLsdbTransitArea);
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbTransitArea;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtLocalLsdbTransitArea = ntohl(table_entry->ospfVirtLocalLsdbTransitArea);
    len = 4;
    table_entry->ospfVirtLocalLsdbNeighbor = htonl(table_entry->ospfVirtLocalLsdbNeighbor);
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbNeighbor;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtLocalLsdbNeighbor = ntohl(table_entry->ospfVirtLocalLsdbNeighbor);
    name[name_pos++] = (oid) table_entry->ospfVirtLocalLsdbType;
    len = 4;
    table_entry->ospfVirtLocalLsdbLsid = htonl(table_entry->ospfVirtLocalLsdbLsid);
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbLsid;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtLocalLsdbLsid = ntohl(table_entry->ospfVirtLocalLsdbLsid);
    len = 4;
    table_entry->ospfVirtLocalLsdbRouterId = htonl(table_entry->ospfVirtLocalLsdbRouterId);
    cp = (u_char *) &table_entry->ospfVirtLocalLsdbRouterId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfVirtLocalLsdbRouterId = ntohl(table_entry->ospfVirtLocalLsdbRouterId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfVirtLocalLsdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfVirtLocalLsdbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ospfVirtLocalLsdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfVirtLocalLsdbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfVirtLocalLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfVirtLocalLsdbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfVirtLocalLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFVIRTLOCALLSDBSEQUENCE: {
        ospf_global_ret.long_ret = table_entry.ospfVirtLocalLsdbSequence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTLOCALLSDBAGE: {
        ospf_global_ret.long_ret = table_entry.ospfVirtLocalLsdbAge;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTLOCALLSDBCHECKSUM: {
        ospf_global_ret.long_ret = table_entry.ospfVirtLocalLsdbChecksum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFVIRTLOCALLSDBADVERTISEMENT: {
        *var_len = table_entry.ospfVirtLocalLsdbAdvertisement_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfVirtLocalLsdbAdvertisement, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfVirtLocalLsdbTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfAsLsdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfAsLsdbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfAsLsdbTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 9 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 9)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfAsLsdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ospfAsLsdbType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfAsLsdbTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfAsLsdbTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    len = 4;
    cp = (u_char *) &table_entry->ospfAsLsdbLsid;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAsLsdbLsid = ntohl(table_entry->ospfAsLsdbLsid);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAsLsdbLsid = ntohl(table_entry->ospfAsLsdbLsid);
            if (!ospfAsLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAsLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAsLsdbLsid = ntohl(table_entry->ospfAsLsdbLsid);
    len = 4;
    cp = (u_char *) &table_entry->ospfAsLsdbRouterId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAsLsdbRouterId = ntohl(table_entry->ospfAsLsdbRouterId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAsLsdbRouterId = ntohl(table_entry->ospfAsLsdbRouterId);
            if (!ospfAsLsdbTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAsLsdbTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAsLsdbRouterId = ntohl(table_entry->ospfAsLsdbRouterId);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfAsLsdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfAsLsdbTable_fillobj(oid     *name,
             size_t  *length,
             ospfAsLsdbTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    name[name_pos++] = (oid) table_entry->ospfAsLsdbType;
    len = 4;
    table_entry->ospfAsLsdbLsid = htonl(table_entry->ospfAsLsdbLsid);
    cp = (u_char *) &table_entry->ospfAsLsdbLsid;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAsLsdbLsid = ntohl(table_entry->ospfAsLsdbLsid);
    len = 4;
    table_entry->ospfAsLsdbRouterId = htonl(table_entry->ospfAsLsdbRouterId);
    cp = (u_char *) &table_entry->ospfAsLsdbRouterId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAsLsdbRouterId = ntohl(table_entry->ospfAsLsdbRouterId);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfAsLsdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfAsLsdbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ospfAsLsdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfAsLsdbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfAsLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfAsLsdbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfAsLsdbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFASLSDBSEQUENCE: {
        ospf_global_ret.long_ret = table_entry.ospfAsLsdbSequence;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFASLSDBAGE: {
        ospf_global_ret.long_ret = table_entry.ospfAsLsdbAge;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFASLSDBCHECKSUM: {
        ospf_global_ret.long_ret = table_entry.ospfAsLsdbChecksum;
        *var_len = sizeof(ospf_global_ret.long_ret);
        return (u_char *) &ospf_global_ret.long_ret;
    }
    case OSPFASLSDBADVERTISEMENT: {
        *var_len = table_entry.ospfAsLsdbAdvertisement_len;
        memcpy(ospf_global_ret.string_ret, table_entry.ospfAsLsdbAdvertisement, *var_len);
        ospf_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ospf_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfAsLsdbTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ospfAreaLsaCountTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ospfAreaLsaCountTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           ospfAreaLsaCountTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 5 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ospfAreaLsaCountTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->ospfAreaLsaCountAreaId;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->ospfAreaLsaCountAreaId = ntohl(table_entry->ospfAreaLsaCountAreaId);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->ospfAreaLsaCountAreaId = ntohl(table_entry->ospfAreaLsaCountAreaId);
            if (!ospfAreaLsaCountTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!ospfAreaLsaCountTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->ospfAreaLsaCountAreaId = ntohl(table_entry->ospfAreaLsaCountAreaId);
    if (*length > op_pos) {
        table_entry->ospfAreaLsaCountLsaType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!ospfAreaLsaCountTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!ospfAreaLsaCountTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ospfAreaLsaCountTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ospfAreaLsaCountTable_fillobj(oid     *name,
             size_t  *length,
             ospfAreaLsaCountTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->ospfAreaLsaCountAreaId = htonl(table_entry->ospfAreaLsaCountAreaId);
    cp = (u_char *) &table_entry->ospfAreaLsaCountAreaId;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->ospfAreaLsaCountAreaId = ntohl(table_entry->ospfAreaLsaCountAreaId);
    name[name_pos++] = (oid) table_entry->ospfAreaLsaCountLsaType;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ospfAreaLsaCountTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ospf_var above.
 */
u_char *
ospfAreaLsaCountTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ospfAreaLsaCountTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ospfAreaLsaCountTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (ospfAreaLsaCountTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ospfAreaLsaCountTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ospfAreaLsaCountTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case OSPFAREALSACOUNTNUMBER: {
        ospf_global_ret.ulong_ret = table_entry.ospfAreaLsaCountNumber;
        *var_len = sizeof(ospf_global_ret.ulong_ret);
        return (u_char *) &ospf_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ospfAreaLsaCountTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/

/******************************************************************************/
// ospfRouterId_write()
/******************************************************************************/
int
ospfRouterId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    in_addr_t set_value = var_val ? *((in_addr_t *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_IPADDRESS) {
                (void) snmp_log(LOG_ERR, "write to ospfRouterId: not ASN_IPADDRESS\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(in_addr_t)) {
                (void) snmp_log(LOG_ERR, "write to ospfRouterId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfRouterId = set_value;
            scalar_entry.ospfRouterId = ntohl(scalar_entry.ospfRouterId);
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAdminStat_write()
/******************************************************************************/
int
ospfAdminStat_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAdminStat: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAdminStat: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAdminStat: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfAdminStat = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfASBdrRtrStatus_write()
/******************************************************************************/
int
ospfASBdrRtrStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfASBdrRtrStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfASBdrRtrStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfASBdrRtrStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfASBdrRtrStatus = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfTOSSupport_write()
/******************************************************************************/
int
ospfTOSSupport_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfTOSSupport: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfTOSSupport: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfTOSSupport: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfTOSSupport = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfExtLsdbLimit_write()
/******************************************************************************/
int
ospfExtLsdbLimit_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfExtLsdbLimit: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfExtLsdbLimit: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < -1 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfExtLsdbLimit = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfMulticastExtensions_write()
/******************************************************************************/
int
ospfMulticastExtensions_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfMulticastExtensions: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfMulticastExtensions: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfMulticastExtensions = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfExitOverflowInterval_write()
/******************************************************************************/
int
ospfExitOverflowInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfExitOverflowInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfExitOverflowInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfExitOverflowInterval = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfDemandExtensions_write()
/******************************************************************************/
int
ospfDemandExtensions_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfDemandExtensions: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfDemandExtensions: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfDemandExtensions: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfDemandExtensions = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfRFC1583Compatibility_write()
/******************************************************************************/
int
ospfRFC1583Compatibility_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfRFC1583Compatibility: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfRFC1583Compatibility: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfRFC1583Compatibility: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfRFC1583Compatibility = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfReferenceBandwidth_write()
/******************************************************************************/
int
ospfReferenceBandwidth_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ospfReferenceBandwidth: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ospfReferenceBandwidth: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfReferenceBandwidth = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfRestartSupport_write()
/******************************************************************************/
int
ospfRestartSupport_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartSupport: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartSupport: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartSupport: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfRestartSupport = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfRestartInterval_write()
/******************************************************************************/
int
ospfRestartInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 1 || set_value > 1800) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfRestartInterval = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfRestartStrictLsaChecking_write()
/******************************************************************************/
int
ospfRestartStrictLsaChecking_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartStrictLsaChecking: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartStrictLsaChecking: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfRestartStrictLsaChecking: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfRestartStrictLsaChecking = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfStubRouterAdvertisement_write()
/******************************************************************************/
int
ospfStubRouterAdvertisement_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfGeneralGroup_scalar_t scalar_entry;
    static ospfGeneralGroup_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfStubRouterAdvertisement: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfStubRouterAdvertisement: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfStubRouterAdvertisement: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (ospfGeneralGroup_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ospfGeneralGroupScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfGeneralGroupScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.ospfStubRouterAdvertisement = set_value;
            if (ospfGeneralGroupScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfGeneralGroupScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ospfAuthType_write()
/******************************************************************************/
int
ospfAuthType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAuthType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAuthType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 0
                && set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAuthType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAuthType = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfImportAsExtern_write()
/******************************************************************************/
int
ospfImportAsExtern_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfImportAsExtern: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfImportAsExtern: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfImportAsExtern: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfImportAsExtern = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaSummary_write()
/******************************************************************************/
int
ospfAreaSummary_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaSummary: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaSummary: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaSummary: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaSummary = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaStatus_write()
/******************************************************************************/
int
ospfAreaStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaStatus = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaNssaTranslatorRole_write()
/******************************************************************************/
int
ospfAreaNssaTranslatorRole_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaNssaTranslatorRole: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaNssaTranslatorRole: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaNssaTranslatorRole: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaNssaTranslatorRole = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaNssaTranslatorStabilityInterval_write()
/******************************************************************************/
int
ospfAreaNssaTranslatorStabilityInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaTable_entry_t table_entry;
    static ospfAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaNssaTranslatorStabilityInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaNssaTranslatorStabilityInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaNssaTranslatorStabilityInterval = set_value;
            if (ospfAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfStubMetric_write()
/******************************************************************************/
int
ospfStubMetric_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfStubAreaTable_entry_t table_entry;
    static ospfStubAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfStubMetric: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfStubMetric: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 16777215) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfStubAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfStubAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfStubMetric = set_value;
            if (ospfStubAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfStubAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfStubStatus_write()
/******************************************************************************/
int
ospfStubStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfStubAreaTable_entry_t table_entry;
    static ospfStubAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfStubStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfStubStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfStubStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfStubAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfStubAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfStubStatus = set_value;
            if (ospfStubAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfStubAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfStubMetricType_write()
/******************************************************************************/
int
ospfStubMetricType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfStubAreaTable_entry_t table_entry;
    static ospfStubAreaTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfStubMetricType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfStubMetricType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfStubMetricType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfStubAreaTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfStubAreaTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfStubAreaTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfStubMetricType = set_value;
            if (ospfStubAreaTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfStubAreaTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaRangeMask_write()
/******************************************************************************/
int
ospfAreaRangeMask_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    in_addr_t set_value = var_val ? *((in_addr_t *) var_val) : 0;
    ospfAreaRangeTable_entry_t table_entry;
    static ospfAreaRangeTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_IPADDRESS) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeMask: not ASN_IPADDRESS\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(in_addr_t)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeMask: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaRangeTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaRangeTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaRangeMask = set_value;
            table_entry.ospfAreaRangeMask = ntohl(table_entry.ospfAreaRangeMask);
            if (ospfAreaRangeTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaRangeTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaRangeStatus_write()
/******************************************************************************/
int
ospfAreaRangeStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaRangeTable_entry_t table_entry;
    static ospfAreaRangeTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaRangeTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaRangeTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaRangeStatus = set_value;
            if (ospfAreaRangeTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaRangeTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaRangeEffect_write()
/******************************************************************************/
int
ospfAreaRangeEffect_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaRangeTable_entry_t table_entry;
    static ospfAreaRangeTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeEffect: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeEffect: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaRangeEffect: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaRangeTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaRangeTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaRangeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaRangeEffect = set_value;
            if (ospfAreaRangeTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaRangeTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfHostMetric_write()
/******************************************************************************/
int
ospfHostMetric_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfHostTable_entry_t table_entry;
    static ospfHostTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfHostMetric: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfHostMetric: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 65535) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfHostTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfHostTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfHostMetric = set_value;
            if (ospfHostTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfHostTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfHostStatus_write()
/******************************************************************************/
int
ospfHostStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfHostTable_entry_t table_entry;
    static ospfHostTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfHostStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfHostStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfHostStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfHostTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfHostTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfHostStatus = set_value;
            if (ospfHostTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfHostTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfHostCfgAreaID_write()
/******************************************************************************/
int
ospfHostCfgAreaID_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    in_addr_t set_value = var_val ? *((in_addr_t *) var_val) : 0;
    ospfHostTable_entry_t table_entry;
    static ospfHostTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_IPADDRESS) {
                (void) snmp_log(LOG_ERR, "write to ospfHostCfgAreaID: not ASN_IPADDRESS\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(in_addr_t)) {
                (void) snmp_log(LOG_ERR, "write to ospfHostCfgAreaID: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfHostTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfHostTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfHostTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfHostCfgAreaID = set_value;
            table_entry.ospfHostCfgAreaID = ntohl(table_entry.ospfHostCfgAreaID);
            if (ospfHostTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfHostTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfAreaId_write()
/******************************************************************************/
int
ospfIfAreaId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    in_addr_t set_value = var_val ? *((in_addr_t *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_IPADDRESS) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAreaId: not ASN_IPADDRESS\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(in_addr_t)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAreaId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfAreaId = set_value;
            table_entry.ospfIfAreaId = ntohl(table_entry.ospfIfAreaId);
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfType_write()
/******************************************************************************/
int
ospfIfType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 5
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfType = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfAdminStat_write()
/******************************************************************************/
int
ospfIfAdminStat_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAdminStat: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAdminStat: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAdminStat: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfAdminStat = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfRtrPriority_write()
/******************************************************************************/
int
ospfIfRtrPriority_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRtrPriority: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRtrPriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 255) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfRtrPriority = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfTransitDelay_write()
/******************************************************************************/
int
ospfIfTransitDelay_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfTransitDelay: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfTransitDelay: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 3600) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfTransitDelay = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfRetransInterval_write()
/******************************************************************************/
int
ospfIfRetransInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRetransInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRetransInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 3600) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfRetransInterval = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfHelloInterval_write()
/******************************************************************************/
int
ospfIfHelloInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfHelloInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfHelloInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 1 || set_value > 65535) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfHelloInterval = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfRtrDeadInterval_write()
/******************************************************************************/
int
ospfIfRtrDeadInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRtrDeadInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfRtrDeadInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfRtrDeadInterval = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfPollInterval_write()
/******************************************************************************/
int
ospfIfPollInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfPollInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfPollInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfPollInterval = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfAuthKey_write()
/******************************************************************************/
int
ospfIfAuthKey_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAuthKey: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > OSPF_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAuthKey: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 256) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.ospfIfAuthKey, var_val, var_val_len);
            table_entry.ospfIfAuthKey_len = var_val_len;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfStatus_write()
/******************************************************************************/
int
ospfIfStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfStatus = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfMulticastForwarding_write()
/******************************************************************************/
int
ospfIfMulticastForwarding_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMulticastForwarding: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMulticastForwarding: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMulticastForwarding: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfMulticastForwarding = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfDemand_write()
/******************************************************************************/
int
ospfIfDemand_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfDemand: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfDemand: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfDemand: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfDemand = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfAuthType_write()
/******************************************************************************/
int
ospfIfAuthType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfTable_entry_t table_entry;
    static ospfIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAuthType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAuthType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 0
                && set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfAuthType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfAuthType = set_value;
            if (ospfIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfMetricValue_write()
/******************************************************************************/
int
ospfIfMetricValue_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfMetricTable_entry_t table_entry;
    static ospfIfMetricTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMetricValue: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMetricValue: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 65535) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfMetricTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfMetricTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfIfMetricTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfMetricTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfMetricValue = set_value;
            if (ospfIfMetricTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfMetricTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfIfMetricStatus_write()
/******************************************************************************/
int
ospfIfMetricStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfIfMetricTable_entry_t table_entry;
    static ospfIfMetricTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMetricStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMetricStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfIfMetricStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfIfMetricTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfIfMetricTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfIfMetricTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfIfMetricTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfIfMetricStatus = set_value;
            if (ospfIfMetricTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfIfMetricTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfTransitDelay_write()
/******************************************************************************/
int
ospfVirtIfTransitDelay_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfTransitDelay: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfTransitDelay: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 3600) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfTransitDelay = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfRetransInterval_write()
/******************************************************************************/
int
ospfVirtIfRetransInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfRetransInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfRetransInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 3600) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfRetransInterval = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfHelloInterval_write()
/******************************************************************************/
int
ospfVirtIfHelloInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfHelloInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfHelloInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 1 || set_value > 65535) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfHelloInterval = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfRtrDeadInterval_write()
/******************************************************************************/
int
ospfVirtIfRtrDeadInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfRtrDeadInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfRtrDeadInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfRtrDeadInterval = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfAuthKey_write()
/******************************************************************************/
int
ospfVirtIfAuthKey_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfAuthKey: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > OSPF_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfAuthKey: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 256) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.ospfVirtIfAuthKey, var_val, var_val_len);
            table_entry.ospfVirtIfAuthKey_len = var_val_len;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfStatus_write()
/******************************************************************************/
int
ospfVirtIfStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfStatus = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfVirtIfAuthType_write()
/******************************************************************************/
int
ospfVirtIfAuthType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfVirtIfTable_entry_t table_entry;
    static ospfVirtIfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfAuthType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfAuthType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 0
                && set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfVirtIfAuthType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfVirtIfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfVirtIfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfVirtIfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfVirtIfAuthType = set_value;
            if (ospfVirtIfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfVirtIfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfNbrPriority_write()
/******************************************************************************/
int
ospfNbrPriority_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfNbrTable_entry_t table_entry;
    static ospfNbrTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfNbrPriority: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfNbrPriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 255) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfNbrTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfNbrTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfNbrTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfNbrTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfNbrPriority = set_value;
            if (ospfNbrTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfNbrTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfNbmaNbrStatus_write()
/******************************************************************************/
int
ospfNbmaNbrStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfNbrTable_entry_t table_entry;
    static ospfNbrTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfNbmaNbrStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfNbmaNbrStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfNbmaNbrStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfNbrTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfNbrTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfNbrTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfNbrTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfNbmaNbrStatus = set_value;
            if (ospfNbrTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfNbrTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaAggregateStatus_write()
/******************************************************************************/
int
ospfAreaAggregateStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaAggregateTable_entry_t table_entry;
    static ospfAreaAggregateTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaAggregateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaAggregateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaAggregateStatus = set_value;
            if (ospfAreaAggregateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaAggregateTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaAggregateEffect_write()
/******************************************************************************/
int
ospfAreaAggregateEffect_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    ospfAreaAggregateTable_entry_t table_entry;
    static ospfAreaAggregateTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateEffect: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateEffect: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateEffect: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaAggregateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaAggregateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaAggregateEffect = set_value;
            if (ospfAreaAggregateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaAggregateTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ospfAreaAggregateExtRouteTag_write()
/******************************************************************************/
int
ospfAreaAggregateExtRouteTag_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    ospfAreaAggregateTable_entry_t table_entry;
    static ospfAreaAggregateTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateExtRouteTag: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to ospfAreaAggregateExtRouteTag: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (ospfAreaAggregateTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (ospfAreaAggregateTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && ospfAreaAggregateTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.ospfAreaAggregateExtRouteTag = set_value;
            if (ospfAreaAggregateTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ospfAreaAggregateTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

