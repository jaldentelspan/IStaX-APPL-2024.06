/*

 Copyright (c) 2006-2019 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_ieee8021CfmMib.h"
#include "ieee8021CfmMib.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021CFMMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021CFMMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021CFMMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[IEEE8021CFMMIB_STR_LEN_MAX + 1];
    oid                 objid_ret[IEEE8021CFMMIB_OID_LEN_MAX];
    size_t              objid_len_ret;
    u_long              ulong_ret;
} ieee8021CfmMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ieee8021CfmMib_var;
FindVarMethod dot1agCfmStackTable_var;
FindVarMethod dot1agCfmDefaultMdTable_var;
FindVarMethod dot1agCfmVlanTable_var;
FindVarMethod dot1agCfmConfigErrorListTable_var;
FindVarMethod dot1agCfmMdTable_var;
FindVarMethod dot1agCfmMaNetTable_var;
FindVarMethod dot1agCfmMaCompTable_var;
FindVarMethod dot1agCfmMaMepListTable_var;
FindVarMethod dot1agCfmMepTable_var;
FindVarMethod dot1agCfmLtrTable_var;
FindVarMethod dot1agCfmMepDbTable_var;
WriteMethod dot1agCfmDefaultMdDefLevel_write;
WriteMethod dot1agCfmDefaultMdDefMhfCreation_write;
WriteMethod dot1agCfmDefaultMdDefIdPermission_write;
WriteMethod dot1agCfmDefaultMdLevel_write;
WriteMethod dot1agCfmDefaultMdMhfCreation_write;
WriteMethod dot1agCfmDefaultMdIdPermission_write;
WriteMethod dot1agCfmVlanPrimaryVid_write;
WriteMethod dot1agCfmVlanRowStatus_write;
WriteMethod dot1agCfmMdFormat_write;
WriteMethod dot1agCfmMdName_write;
WriteMethod dot1agCfmMdMdLevel_write;
WriteMethod dot1agCfmMdMhfCreation_write;
WriteMethod dot1agCfmMdMhfIdPermission_write;
WriteMethod dot1agCfmMdRowStatus_write;
WriteMethod dot1agCfmMaNetFormat_write;
WriteMethod dot1agCfmMaNetName_write;
WriteMethod dot1agCfmMaNetCcmInterval_write;
WriteMethod dot1agCfmMaNetRowStatus_write;
WriteMethod dot1agCfmMaCompPrimaryVlanId_write;
WriteMethod dot1agCfmMaCompMhfCreation_write;
WriteMethod dot1agCfmMaCompIdPermission_write;
WriteMethod dot1agCfmMaCompNumberOfVids_write;
WriteMethod dot1agCfmMaCompRowStatus_write;
WriteMethod dot1agCfmMaMepListRowStatus_write;
WriteMethod dot1agCfmMepIfIndex_write;
WriteMethod dot1agCfmMepDirection_write;
WriteMethod dot1agCfmMepPrimaryVid_write;
WriteMethod dot1agCfmMepActive_write;
WriteMethod dot1agCfmMepCciEnabled_write;
WriteMethod dot1agCfmMepCcmLtmPriority_write;
WriteMethod dot1agCfmMepLowPrDef_write;
WriteMethod dot1agCfmMepFngAlarmTime_write;
WriteMethod dot1agCfmMepFngResetTime_write;
WriteMethod dot1agCfmMepTransmitLbmStatus_write;
WriteMethod dot1agCfmMepTransmitLbmDestMacAddress_write;
WriteMethod dot1agCfmMepTransmitLbmDestMepId_write;
WriteMethod dot1agCfmMepTransmitLbmDestIsMepId_write;
WriteMethod dot1agCfmMepTransmitLbmMessages_write;
WriteMethod dot1agCfmMepTransmitLbmDataTlv_write;
WriteMethod dot1agCfmMepTransmitLbmVlanPriority_write;
WriteMethod dot1agCfmMepTransmitLbmVlanDropEnable_write;
WriteMethod dot1agCfmMepTransmitLtmStatus_write;
WriteMethod dot1agCfmMepTransmitLtmFlags_write;
WriteMethod dot1agCfmMepTransmitLtmTargetMacAddress_write;
WriteMethod dot1agCfmMepTransmitLtmTargetMepId_write;
WriteMethod dot1agCfmMepTransmitLtmTargetIsMepId_write;
WriteMethod dot1agCfmMepTransmitLtmTtl_write;
WriteMethod dot1agCfmMepTransmitLtmEgressIdentifier_write;
WriteMethod dot1agCfmMepRowStatus_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ieee8021CfmMib_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021CfmMib_ret_t ieee8021CfmMib_global_ret;

/*
 * ieee8021CfmMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ieee8021CfmMib_variables_oid[] = {1,3,111,2,802,1,1,8};



/*
 * variable ieee8021CfmMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021CfmMib mib section
 */

struct variable7 ieee8021CfmMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define DOT1AGCFMDEFAULTMDDEFLEVEL		1
    {DOT1AGCFMDEFAULTMDDEFLEVEL, ASN_INTEGER, RWRITE, ieee8021CfmMib_var, 3, {1,2,1}},
#define DOT1AGCFMDEFAULTMDDEFMHFCREATION		2
    {DOT1AGCFMDEFAULTMDDEFMHFCREATION, ASN_INTEGER, RWRITE, ieee8021CfmMib_var, 3, {1,2,2}},
#define DOT1AGCFMDEFAULTMDDEFIDPERMISSION		3
    {DOT1AGCFMDEFAULTMDDEFIDPERMISSION, ASN_INTEGER, RWRITE, ieee8021CfmMib_var, 3, {1,2,3}},
#define DOT1AGCFMMDTABLENEXTINDEX		4
    {DOT1AGCFMMDTABLENEXTINDEX, ASN_UNSIGNED, RONLY, ieee8021CfmMib_var, 3, {1,5,1}},

#define DOT1AGCFMSTACKMDINDEX		5
    {DOT1AGCFMSTACKMDINDEX, ASN_UNSIGNED, RONLY, dot1agCfmStackTable_var, 5, {1,1,1, 1, 5}},
#define DOT1AGCFMSTACKMAINDEX		6
    {DOT1AGCFMSTACKMAINDEX, ASN_UNSIGNED, RONLY, dot1agCfmStackTable_var, 5, {1,1,1, 1, 6}},
#define DOT1AGCFMSTACKMEPID		7
    {DOT1AGCFMSTACKMEPID, ASN_UNSIGNED, RONLY, dot1agCfmStackTable_var, 5, {1,1,1, 1, 7}},
#define DOT1AGCFMSTACKMACADDRESS		8
    {DOT1AGCFMSTACKMACADDRESS, ASN_OCTET_STR, RONLY, dot1agCfmStackTable_var, 5, {1,1,1, 1, 8}},
#define DOT1AGCFMDEFAULTMDSTATUS		9
    {DOT1AGCFMDEFAULTMDSTATUS, ASN_INTEGER, RONLY, dot1agCfmDefaultMdTable_var, 5, {1,2,4, 1, 3}},
#define DOT1AGCFMDEFAULTMDLEVEL		10
    {DOT1AGCFMDEFAULTMDLEVEL, ASN_INTEGER, RWRITE, dot1agCfmDefaultMdTable_var, 5, {1,2,4, 1, 4}},
#define DOT1AGCFMDEFAULTMDMHFCREATION		11
    {DOT1AGCFMDEFAULTMDMHFCREATION, ASN_INTEGER, RWRITE, dot1agCfmDefaultMdTable_var, 5, {1,2,4, 1, 5}},
#define DOT1AGCFMDEFAULTMDIDPERMISSION		12
    {DOT1AGCFMDEFAULTMDIDPERMISSION, ASN_INTEGER, RWRITE, dot1agCfmDefaultMdTable_var, 5, {1,2,4, 1, 6}},
#define DOT1AGCFMVLANPRIMARYVID		13
    {DOT1AGCFMVLANPRIMARYVID, ASN_INTEGER, RWRITE, dot1agCfmVlanTable_var, 5, {1,3,1, 1, 3}},
#define DOT1AGCFMVLANROWSTATUS		14
    {DOT1AGCFMVLANROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmVlanTable_var, 5, {1,3,1, 1, 4}},
#define DOT1AGCFMCONFIGERRORLISTERRORTYPE		15
    {DOT1AGCFMCONFIGERRORLISTERRORTYPE, ASN_OCTET_STR, RONLY, dot1agCfmConfigErrorListTable_var, 5, {1,4,1, 1, 3}},
#define DOT1AGCFMMDFORMAT		16
    {DOT1AGCFMMDFORMAT, ASN_INTEGER, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 2}},
#define DOT1AGCFMMDNAME		17
    {DOT1AGCFMMDNAME, ASN_OCTET_STR, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 3}},
#define DOT1AGCFMMDMDLEVEL		18
    {DOT1AGCFMMDMDLEVEL, ASN_INTEGER, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 4}},
#define DOT1AGCFMMDMHFCREATION		19
    {DOT1AGCFMMDMHFCREATION, ASN_INTEGER, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 5}},
#define DOT1AGCFMMDMHFIDPERMISSION		20
    {DOT1AGCFMMDMHFIDPERMISSION, ASN_INTEGER, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 6}},
#define DOT1AGCFMMDMANEXTINDEX		21
    {DOT1AGCFMMDMANEXTINDEX, ASN_UNSIGNED, RONLY, dot1agCfmMdTable_var, 5, {1,5,2, 1, 7}},
#define DOT1AGCFMMDROWSTATUS		22
    {DOT1AGCFMMDROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMdTable_var, 5, {1,5,2, 1, 8}},
#define DOT1AGCFMMANETFORMAT		23
    {DOT1AGCFMMANETFORMAT, ASN_INTEGER, RWRITE, dot1agCfmMaNetTable_var, 5, {1,6,1, 1, 2}},
#define DOT1AGCFMMANETNAME		24
    {DOT1AGCFMMANETNAME, ASN_OCTET_STR, RWRITE, dot1agCfmMaNetTable_var, 5, {1,6,1, 1, 3}},
#define DOT1AGCFMMANETCCMINTERVAL		25
    {DOT1AGCFMMANETCCMINTERVAL, ASN_INTEGER, RWRITE, dot1agCfmMaNetTable_var, 5, {1,6,1, 1, 4}},
#define DOT1AGCFMMANETROWSTATUS		26
    {DOT1AGCFMMANETROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMaNetTable_var, 5, {1,6,1, 1, 5}},
#define DOT1AGCFMMACOMPPRIMARYVLANID		27
    {DOT1AGCFMMACOMPPRIMARYVLANID, ASN_INTEGER, RWRITE, dot1agCfmMaCompTable_var, 5, {1,6,2, 1, 2}},
#define DOT1AGCFMMACOMPMHFCREATION		28
    {DOT1AGCFMMACOMPMHFCREATION, ASN_INTEGER, RWRITE, dot1agCfmMaCompTable_var, 5, {1,6,2, 1, 3}},
#define DOT1AGCFMMACOMPIDPERMISSION		29
    {DOT1AGCFMMACOMPIDPERMISSION, ASN_INTEGER, RWRITE, dot1agCfmMaCompTable_var, 5, {1,6,2, 1, 4}},
#define DOT1AGCFMMACOMPNUMBEROFVIDS		30
    {DOT1AGCFMMACOMPNUMBEROFVIDS, ASN_UNSIGNED, RWRITE, dot1agCfmMaCompTable_var, 5, {1,6,2, 1, 5}},
#define DOT1AGCFMMACOMPROWSTATUS		31
    {DOT1AGCFMMACOMPROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMaCompTable_var, 5, {1,6,2, 1, 6}},
#define DOT1AGCFMMAMEPLISTROWSTATUS		32
    {DOT1AGCFMMAMEPLISTROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMaMepListTable_var, 5, {1,6,3, 1, 2}},
#define DOT1AGCFMMEPIFINDEX		33
    {DOT1AGCFMMEPIFINDEX, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 2}},
#define DOT1AGCFMMEPDIRECTION		34
    {DOT1AGCFMMEPDIRECTION, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 3}},
#define DOT1AGCFMMEPPRIMARYVID		35
    {DOT1AGCFMMEPPRIMARYVID, ASN_UNSIGNED, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 4}},
#define DOT1AGCFMMEPACTIVE		36
    {DOT1AGCFMMEPACTIVE, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 5}},
#define DOT1AGCFMMEPFNGSTATE		37
    {DOT1AGCFMMEPFNGSTATE, ASN_INTEGER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 6}},
#define DOT1AGCFMMEPCCIENABLED		38
    {DOT1AGCFMMEPCCIENABLED, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 7}},
#define DOT1AGCFMMEPCCMLTMPRIORITY		39
    {DOT1AGCFMMEPCCMLTMPRIORITY, ASN_UNSIGNED, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 8}},
#define DOT1AGCFMMEPMACADDRESS		40
    {DOT1AGCFMMEPMACADDRESS, ASN_OCTET_STR, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 9}},
#define DOT1AGCFMMEPLOWPRDEF		41
    {DOT1AGCFMMEPLOWPRDEF, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 10}},
#define DOT1AGCFMMEPFNGALARMTIME		42
    {DOT1AGCFMMEPFNGALARMTIME, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 11}},
#define DOT1AGCFMMEPFNGRESETTIME		43
    {DOT1AGCFMMEPFNGRESETTIME, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 12}},
#define DOT1AGCFMMEPHIGHESTPRDEFECT		44
    {DOT1AGCFMMEPHIGHESTPRDEFECT, ASN_INTEGER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 13}},
#define DOT1AGCFMMEPDEFECTS		45
    {DOT1AGCFMMEPDEFECTS, ASN_OCTET_STR, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 14}},
#define DOT1AGCFMMEPERRORCCMLASTFAILURE		46
    {DOT1AGCFMMEPERRORCCMLASTFAILURE, ASN_OCTET_STR, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 15}},
#define DOT1AGCFMMEPXCONCCMLASTFAILURE		47
    {DOT1AGCFMMEPXCONCCMLASTFAILURE, ASN_OCTET_STR, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 16}},
#define DOT1AGCFMMEPCCMSEQUENCEERRORS		48
    {DOT1AGCFMMEPCCMSEQUENCEERRORS, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 17}},
#define DOT1AGCFMMEPCCISENTCCMS		49
    {DOT1AGCFMMEPCCISENTCCMS, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 18}},
#define DOT1AGCFMMEPNEXTLBMTRANSID		50
    {DOT1AGCFMMEPNEXTLBMTRANSID, ASN_UNSIGNED, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 19}},
#define DOT1AGCFMMEPLBRIN		51
    {DOT1AGCFMMEPLBRIN, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 20}},
#define DOT1AGCFMMEPLBRINOUTOFORDER		52
    {DOT1AGCFMMEPLBRINOUTOFORDER, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 21}},
#define DOT1AGCFMMEPLBRBADMSDU		53
    {DOT1AGCFMMEPLBRBADMSDU, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 22}},
#define DOT1AGCFMMEPLTMNEXTSEQNUMBER		54
    {DOT1AGCFMMEPLTMNEXTSEQNUMBER, ASN_UNSIGNED, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 23}},
#define DOT1AGCFMMEPUNEXPLTRIN		55
    {DOT1AGCFMMEPUNEXPLTRIN, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 24}},
#define DOT1AGCFMMEPLBROUT		56
    {DOT1AGCFMMEPLBROUT, ASN_COUNTER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 25}},
#define DOT1AGCFMMEPTRANSMITLBMSTATUS		57
    {DOT1AGCFMMEPTRANSMITLBMSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 26}},
#define DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS		58
    {DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS, ASN_OCTET_STR, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 27}},
#define DOT1AGCFMMEPTRANSMITLBMDESTMEPID		59
    {DOT1AGCFMMEPTRANSMITLBMDESTMEPID, ASN_UNSIGNED, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 28}},
#define DOT1AGCFMMEPTRANSMITLBMDESTISMEPID		60
    {DOT1AGCFMMEPTRANSMITLBMDESTISMEPID, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 29}},
#define DOT1AGCFMMEPTRANSMITLBMMESSAGES		61
    {DOT1AGCFMMEPTRANSMITLBMMESSAGES, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 30}},
#define DOT1AGCFMMEPTRANSMITLBMDATATLV		62
    {DOT1AGCFMMEPTRANSMITLBMDATATLV, ASN_OCTET_STR, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 31}},
#define DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY		63
    {DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 32}},
#define DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE		64
    {DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 33}},
#define DOT1AGCFMMEPTRANSMITLBMRESULTOK		65
    {DOT1AGCFMMEPTRANSMITLBMRESULTOK, ASN_INTEGER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 34}},
#define DOT1AGCFMMEPTRANSMITLBMSEQNUMBER		66
    {DOT1AGCFMMEPTRANSMITLBMSEQNUMBER, ASN_UNSIGNED, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 35}},
#define DOT1AGCFMMEPTRANSMITLTMSTATUS		67
    {DOT1AGCFMMEPTRANSMITLTMSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 36}},
#define DOT1AGCFMMEPTRANSMITLTMFLAGS		68
    {DOT1AGCFMMEPTRANSMITLTMFLAGS, ASN_OCTET_STR, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 37}},
#define DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS		69
    {DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS, ASN_OCTET_STR, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 38}},
#define DOT1AGCFMMEPTRANSMITLTMTARGETMEPID		70
    {DOT1AGCFMMEPTRANSMITLTMTARGETMEPID, ASN_UNSIGNED, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 39}},
#define DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID		71
    {DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 40}},
#define DOT1AGCFMMEPTRANSMITLTMTTL		72
    {DOT1AGCFMMEPTRANSMITLTMTTL, ASN_UNSIGNED, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 41}},
#define DOT1AGCFMMEPTRANSMITLTMRESULT		73
    {DOT1AGCFMMEPTRANSMITLTMRESULT, ASN_INTEGER, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 42}},
#define DOT1AGCFMMEPTRANSMITLTMSEQNUMBER		74
    {DOT1AGCFMMEPTRANSMITLTMSEQNUMBER, ASN_UNSIGNED, RONLY, dot1agCfmMepTable_var, 5, {1,7,1, 1, 43}},
#define DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER		75
    {DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER, ASN_OCTET_STR, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 44}},
#define DOT1AGCFMMEPROWSTATUS		76
    {DOT1AGCFMMEPROWSTATUS, ASN_INTEGER, RWRITE, dot1agCfmMepTable_var, 5, {1,7,1, 1, 45}},
#define DOT1AGCFMLTRTTL		77
    {DOT1AGCFMLTRTTL, ASN_UNSIGNED, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 3}},
#define DOT1AGCFMLTRFORWARDED		78
    {DOT1AGCFMLTRFORWARDED, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 4}},
#define DOT1AGCFMLTRTERMINALMEP		79
    {DOT1AGCFMLTRTERMINALMEP, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 5}},
#define DOT1AGCFMLTRLASTEGRESSIDENTIFIER		80
    {DOT1AGCFMLTRLASTEGRESSIDENTIFIER, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 6}},
#define DOT1AGCFMLTRNEXTEGRESSIDENTIFIER		81
    {DOT1AGCFMLTRNEXTEGRESSIDENTIFIER, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 7}},
#define DOT1AGCFMLTRRELAY		82
    {DOT1AGCFMLTRRELAY, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 8}},
#define DOT1AGCFMLTRCHASSISIDSUBTYPE		83
    {DOT1AGCFMLTRCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 9}},
#define DOT1AGCFMLTRCHASSISID		84
    {DOT1AGCFMLTRCHASSISID, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 10}},
#define DOT1AGCFMLTRMANADDRESSDOMAIN		85
    {DOT1AGCFMLTRMANADDRESSDOMAIN, ASN_OBJECT_ID, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 11}},
#define DOT1AGCFMLTRMANADDRESS		86
    {DOT1AGCFMLTRMANADDRESS, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 12}},
#define DOT1AGCFMLTRINGRESS		87
    {DOT1AGCFMLTRINGRESS, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 13}},
#define DOT1AGCFMLTRINGRESSMAC		88
    {DOT1AGCFMLTRINGRESSMAC, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 14}},
#define DOT1AGCFMLTRINGRESSPORTIDSUBTYPE		89
    {DOT1AGCFMLTRINGRESSPORTIDSUBTYPE, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 15}},
#define DOT1AGCFMLTRINGRESSPORTID		90
    {DOT1AGCFMLTRINGRESSPORTID, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 16}},
#define DOT1AGCFMLTREGRESS		91
    {DOT1AGCFMLTREGRESS, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 17}},
#define DOT1AGCFMLTREGRESSMAC		92
    {DOT1AGCFMLTREGRESSMAC, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 18}},
#define DOT1AGCFMLTREGRESSPORTIDSUBTYPE		93
    {DOT1AGCFMLTREGRESSPORTIDSUBTYPE, ASN_INTEGER, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 19}},
#define DOT1AGCFMLTREGRESSPORTID		94
    {DOT1AGCFMLTREGRESSPORTID, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 20}},
#define DOT1AGCFMLTRORGANIZATIONSPECIFICTLV		95
    {DOT1AGCFMLTRORGANIZATIONSPECIFICTLV, ASN_OCTET_STR, RONLY, dot1agCfmLtrTable_var, 5, {1,7,2, 1, 21}},
#define DOT1AGCFMMEPDBRMEPSTATE		96
    {DOT1AGCFMMEPDBRMEPSTATE, ASN_INTEGER, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 2}},
#define DOT1AGCFMMEPDBRMEPFAILEDOKTIME		97
    {DOT1AGCFMMEPDBRMEPFAILEDOKTIME, ASN_TIMETICKS, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 3}},
#define DOT1AGCFMMEPDBMACADDRESS		98
    {DOT1AGCFMMEPDBMACADDRESS, ASN_OCTET_STR, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 4}},
#define DOT1AGCFMMEPDBRDI		99
    {DOT1AGCFMMEPDBRDI, ASN_INTEGER, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 5}},
#define DOT1AGCFMMEPDBPORTSTATUSTLV		100
    {DOT1AGCFMMEPDBPORTSTATUSTLV, ASN_INTEGER, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 6}},
#define DOT1AGCFMMEPDBINTERFACESTATUSTLV		101
    {DOT1AGCFMMEPDBINTERFACESTATUSTLV, ASN_INTEGER, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 7}},
#define DOT1AGCFMMEPDBCHASSISIDSUBTYPE		102
    {DOT1AGCFMMEPDBCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 8}},
#define DOT1AGCFMMEPDBCHASSISID		103
    {DOT1AGCFMMEPDBCHASSISID, ASN_OCTET_STR, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 9}},
#define DOT1AGCFMMEPDBMANADDRESSDOMAIN		104
    {DOT1AGCFMMEPDBMANADDRESSDOMAIN, ASN_OBJECT_ID, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 10}},
#define DOT1AGCFMMEPDBMANADDRESS		105
    {DOT1AGCFMMEPDBMANADDRESS, ASN_OCTET_STR, RONLY, dot1agCfmMepDbTable_var, 5, {1,7,3, 1, 11}},
};


/******************************************************************************/
// ucd_snmp_init_ieee8021CfmMib()
// Initializes the UCD-SNMP-part of the IEEE8021-CFM-MIB:ieee8021CfmMib.
/******************************************************************************/
void ucd_snmp_init_ieee8021CfmMib(void)
{
    DEBUGMSGTL(("ieee8021CfmMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021CfmMib", ieee8021CfmMib_variables, variable7, ieee8021CfmMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021CfmMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
ieee8021CfmMib_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{
    dot1agCfmDefaultMd_scalar_t dot1agCfmDefaultMd_scalar_entry;
    dot1agCfmMd_scalar_t dot1agCfmMd_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (dot1agCfmDefaultMdScalar_get(&dot1agCfmDefaultMd_scalar_entry)) {
        return NULL;
    }
    if (dot1agCfmMdScalar_get(&dot1agCfmMd_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMDEFAULTMDDEFLEVEL: {
        *write_method = dot1agCfmDefaultMdDefLevel_write;
        ieee8021CfmMib_global_ret.long_ret = dot1agCfmDefaultMd_scalar_entry.dot1agCfmDefaultMdDefLevel;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMDEFAULTMDDEFMHFCREATION: {
        *write_method = dot1agCfmDefaultMdDefMhfCreation_write;
        ieee8021CfmMib_global_ret.long_ret = dot1agCfmDefaultMd_scalar_entry.dot1agCfmDefaultMdDefMhfCreation;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMDEFAULTMDDEFIDPERMISSION: {
        *write_method = dot1agCfmDefaultMdDefIdPermission_write;
        ieee8021CfmMib_global_ret.long_ret = dot1agCfmDefaultMd_scalar_entry.dot1agCfmDefaultMdDefIdPermission;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMDTABLENEXTINDEX: {
        ieee8021CfmMib_global_ret.ulong_ret = dot1agCfmMd_scalar_entry.dot1agCfmMdTableNextIndex;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021CfmMib_var\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
// dot1agCfmStackTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmStackTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmStackTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmStackTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmStackifIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmStackTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmStackTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmStackVlanIdOrNone = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmStackTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmStackTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmStackMdLevel = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmStackTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmStackTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmStackDirection = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmStackTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmStackTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmStackTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmStackTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmStackTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmStackifIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmStackVlanIdOrNone;
    name[name_pos++] = (oid) table_entry->dot1agCfmStackMdLevel;
    name[name_pos++] = (oid) table_entry->dot1agCfmStackDirection;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmStackTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmStackTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmStackTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmStackTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmStackTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmStackTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot1agCfmStackTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMSTACKMDINDEX: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmStackMdIndex;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMSTACKMAINDEX: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmStackMaIndex;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMSTACKMEPID: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmStackMepId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMSTACKMACADDRESS: {
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmStackMacAddress, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmStackTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmDefaultMdTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmDefaultMdTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmDefaultMdTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmDefaultMdTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmDefaultMdComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmDefaultMdPrimaryVid = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmDefaultMdTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmDefaultMdTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmDefaultMdTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmDefaultMdTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmDefaultMdTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmDefaultMdComponentId;
    name[name_pos++] = (oid) table_entry->dot1agCfmDefaultMdPrimaryVid;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmDefaultMdTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmDefaultMdTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmDefaultMdTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmDefaultMdTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmDefaultMdTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmDefaultMdTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot1agCfmDefaultMdTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMDEFAULTMDSTATUS: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmDefaultMdStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMDEFAULTMDLEVEL: {
        *write_method = dot1agCfmDefaultMdLevel_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmDefaultMdLevel;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMDEFAULTMDMHFCREATION: {
        *write_method = dot1agCfmDefaultMdMhfCreation_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmDefaultMdMhfCreation;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMDEFAULTMDIDPERMISSION: {
        *write_method = dot1agCfmDefaultMdIdPermission_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmDefaultMdIdPermission;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmDefaultMdTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmVlanTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmVlanTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmVlanTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmVlanTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmVlanComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmVlanVid = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmVlanTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmVlanTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmVlanTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmVlanTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmVlanTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmVlanComponentId;
    name[name_pos++] = (oid) table_entry->dot1agCfmVlanVid;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmVlanTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmVlanTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmVlanTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmVlanTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmVlanTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmVlanTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMVLANROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmVlanRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmVlanTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMVLANPRIMARYVID: {
        *write_method = dot1agCfmVlanPrimaryVid_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmVlanPrimaryVid;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMVLANROWSTATUS: {
        *write_method = dot1agCfmVlanRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmVlanRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmVlanTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmConfigErrorListTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmConfigErrorListTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmConfigErrorListTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmConfigErrorListTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmConfigErrorListVid = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmConfigErrorListTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmConfigErrorListTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmConfigErrorListIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (!dot1agCfmConfigErrorListTableEntry_get(table_entry, FALSE)) {
            return 1;
        } else if (!dot1agCfmConfigErrorListTableEntry_get(table_entry, TRUE)) {
            return 1;
        }
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmConfigErrorListTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmConfigErrorListTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmConfigErrorListTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmConfigErrorListVid;
    name[name_pos++] = (oid) table_entry->dot1agCfmConfigErrorListIfIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmConfigErrorListTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmConfigErrorListTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmConfigErrorListTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmConfigErrorListTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmConfigErrorListTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmConfigErrorListTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot1agCfmConfigErrorListTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMCONFIGERRORLISTERRORTYPE: {
        *var_len = table_entry.dot1agCfmConfigErrorListErrorType_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmConfigErrorListErrorType, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmConfigErrorListTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMdTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMdTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMdTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMdTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMdTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMdTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMdTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMdTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMdTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMdTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMdTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMdTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMdTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMMDROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmMdRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmMdTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMDFORMAT: {
        *write_method = dot1agCfmMdFormat_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMdFormat;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMDNAME: {
        *write_method = dot1agCfmMdName_write;
        *var_len = table_entry.dot1agCfmMdName_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMdName, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMDMDLEVEL: {
        *write_method = dot1agCfmMdMdLevel_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMdMdLevel;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMDMHFCREATION: {
        *write_method = dot1agCfmMdMhfCreation_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMdMhfCreation;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMDMHFIDPERMISSION: {
        *write_method = dot1agCfmMdMhfIdPermission_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMdMhfIdPermission;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMDMANEXTINDEX: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMdMaNextIndex;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMDROWSTATUS: {
        *write_method = dot1agCfmMdRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMdRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMdTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMaNetTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMaNetTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMaNetTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMaNetTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMaNetTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMaNetTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMaNetTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMaNetTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMaNetTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMaNetTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMaNetTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMaNetTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMaNetTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMMANETROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmMaNetRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmMaNetTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMANETFORMAT: {
        *write_method = dot1agCfmMaNetFormat_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaNetFormat;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMANETNAME: {
        *write_method = dot1agCfmMaNetName_write;
        *var_len = table_entry.dot1agCfmMaNetName_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMaNetName, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMANETCCMINTERVAL: {
        *write_method = dot1agCfmMaNetCcmInterval_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaNetCcmInterval;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMANETROWSTATUS: {
        *write_method = dot1agCfmMaNetRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaNetRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMaNetTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMaCompTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMaCompTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMaCompTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMaCompTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMaComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMaCompTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMaCompTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMaCompTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMaComponentId;
    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMaCompTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMaCompTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMaCompTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMaCompTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMaCompTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMaCompTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMMACOMPROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmMaCompRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmMaCompTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMACOMPPRIMARYVLANID: {
        *write_method = dot1agCfmMaCompPrimaryVlanId_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaCompPrimaryVlanId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMACOMPMHFCREATION: {
        *write_method = dot1agCfmMaCompMhfCreation_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaCompMhfCreation;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMACOMPIDPERMISSION: {
        *write_method = dot1agCfmMaCompIdPermission_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaCompIdPermission;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMACOMPNUMBEROFVIDS: {
        *write_method = dot1agCfmMaCompNumberOfVids_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMaCompNumberOfVids;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMACOMPROWSTATUS: {
        *write_method = dot1agCfmMaCompRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaCompRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMaCompTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMaMepListTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMaMepListTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMaMepListTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMaMepListTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaMepListIdentifier = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMaMepListTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMaMepListTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMaMepListTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaMepListIdentifier;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMaMepListTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMaMepListTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMaMepListTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMaMepListTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMaMepListTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMaMepListTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMMAMEPLISTROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmMaMepListRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmMaMepListTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMAMEPLISTROWSTATUS: {
        *write_method = dot1agCfmMaMepListRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMaMepListRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMaMepListTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMepTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMepTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMepTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMepTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMepIdentifier = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMepTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMepTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMepTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMepIdentifier;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMepTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMepTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMepTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMepTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMepTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMepTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == DOT1AGCFMMEPROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = dot1agCfmMepRowStatus_write;
                }
                return NULL;
            }
            if (dot1agCfmMepTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMEPIFINDEX: {
        *write_method = dot1agCfmMepIfIndex_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepIfIndex;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDIRECTION: {
        *write_method = dot1agCfmMepDirection_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDirection;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPPRIMARYVID: {
        *write_method = dot1agCfmMepPrimaryVid_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepPrimaryVid;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPACTIVE: {
        *write_method = dot1agCfmMepActive_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepActive;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPFNGSTATE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepFngState;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPCCIENABLED: {
        *write_method = dot1agCfmMepCciEnabled_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepCciEnabled;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPCCMLTMPRIORITY: {
        *write_method = dot1agCfmMepCcmLtmPriority_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepCcmLtmPriority;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPMACADDRESS: {
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepMacAddress, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPLOWPRDEF: {
        *write_method = dot1agCfmMepLowPrDef_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepLowPrDef;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPFNGALARMTIME: {
        *write_method = dot1agCfmMepFngAlarmTime_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepFngAlarmTime;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPFNGRESETTIME: {
        *write_method = dot1agCfmMepFngResetTime_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepFngResetTime;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPHIGHESTPRDEFECT: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepHighestPrDefect;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDEFECTS: {
        *var_len = table_entry.dot1agCfmMepDefects_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepDefects, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPERRORCCMLASTFAILURE: {
        *var_len = table_entry.dot1agCfmMepErrorCcmLastFailure_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepErrorCcmLastFailure, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPXCONCCMLASTFAILURE: {
        *var_len = table_entry.dot1agCfmMepXconCcmLastFailure_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepXconCcmLastFailure, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPCCMSEQUENCEERRORS: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepCcmSequenceErrors;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPCCISENTCCMS: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepCciSentCcms;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPNEXTLBMTRANSID: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepNextLbmTransId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPLBRIN: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepLbrIn;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPLBRINOUTOFORDER: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepLbrInOutOfOrder;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPLBRBADMSDU: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepLbrBadMsdu;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPLTMNEXTSEQNUMBER: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepLtmNextSeqNumber;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPUNEXPLTRIN: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepUnexpLtrIn;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPLBROUT: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepLbrOut;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMSTATUS: {
        *write_method = dot1agCfmMepTransmitLbmStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS: {
        *write_method = dot1agCfmMepTransmitLbmDestMacAddress_write;
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepTransmitLbmDestMacAddress, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMDESTMEPID: {
        *write_method = dot1agCfmMepTransmitLbmDestMepId_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepTransmitLbmDestMepId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMDESTISMEPID: {
        *write_method = dot1agCfmMepTransmitLbmDestIsMepId_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmDestIsMepId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMMESSAGES: {
        *write_method = dot1agCfmMepTransmitLbmMessages_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmMessages;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMDATATLV: {
        *write_method = dot1agCfmMepTransmitLbmDataTlv_write;
        *var_len = table_entry.dot1agCfmMepTransmitLbmDataTlv_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepTransmitLbmDataTlv, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY: {
        *write_method = dot1agCfmMepTransmitLbmVlanPriority_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmVlanPriority;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE: {
        *write_method = dot1agCfmMepTransmitLbmVlanDropEnable_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmVlanDropEnable;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMRESULTOK: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLbmResultOK;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLBMSEQNUMBER: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepTransmitLbmSeqNumber;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMSTATUS: {
        *write_method = dot1agCfmMepTransmitLtmStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLtmStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMFLAGS: {
        *write_method = dot1agCfmMepTransmitLtmFlags_write;
        *var_len = table_entry.dot1agCfmMepTransmitLtmFlags_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepTransmitLtmFlags, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS: {
        *write_method = dot1agCfmMepTransmitLtmTargetMacAddress_write;
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepTransmitLtmTargetMacAddress, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMTARGETMEPID: {
        *write_method = dot1agCfmMepTransmitLtmTargetMepId_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepTransmitLtmTargetMepId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID: {
        *write_method = dot1agCfmMepTransmitLtmTargetIsMepId_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLtmTargetIsMepId;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMTTL: {
        *write_method = dot1agCfmMepTransmitLtmTtl_write;
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepTransmitLtmTtl;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMRESULT: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepTransmitLtmResult;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMSEQNUMBER: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepTransmitLtmSeqNumber;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER: {
        *write_method = dot1agCfmMepTransmitLtmEgressIdentifier_write;
        *var_len = table_entry.dot1agCfmMepTransmitLtmEgressIdentifier_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepTransmitLtmEgressIdentifier, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPROWSTATUS: {
        *write_method = dot1agCfmMepRowStatus_write;
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepRowStatus;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMepTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmLtrTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmLtrTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmLtrTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmLtrTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMepIdentifier = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmLtrSeqNumber = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmLtrReceiveOrder = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmLtrTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmLtrTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmLtrTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMepIdentifier;
    name[name_pos++] = (oid) table_entry->dot1agCfmLtrSeqNumber;
    name[name_pos++] = (oid) table_entry->dot1agCfmLtrReceiveOrder;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmLtrTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmLtrTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmLtrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmLtrTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmLtrTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmLtrTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot1agCfmLtrTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMLTRTTL: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmLtrTtl;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMLTRFORWARDED: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrForwarded;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRTERMINALMEP: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrTerminalMep;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRLASTEGRESSIDENTIFIER: {
        *var_len = table_entry.dot1agCfmLtrLastEgressIdentifier_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrLastEgressIdentifier, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRNEXTEGRESSIDENTIFIER: {
        *var_len = table_entry.dot1agCfmLtrNextEgressIdentifier_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrNextEgressIdentifier, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRRELAY: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrRelay;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRCHASSISIDSUBTYPE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrChassisIdSubtype;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRCHASSISID: {
        *var_len = table_entry.dot1agCfmLtrChassisId_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrChassisId, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRMANADDRESSDOMAIN: {
        memcpy(ieee8021CfmMib_global_ret.objid_ret, table_entry.dot1agCfmLtrManAddressDomain, table_entry.dot1agCfmLtrManAddressDomain_len * sizeof(oid));
        *var_len = table_entry.dot1agCfmLtrManAddressDomain_len * sizeof(oid);
        return (u_char *) ieee8021CfmMib_global_ret.objid_ret;
    }
    case DOT1AGCFMLTRMANADDRESS: {
        *var_len = table_entry.dot1agCfmLtrManAddress_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrManAddress, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRINGRESS: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrIngress;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRINGRESSMAC: {
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrIngressMac, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRINGRESSPORTIDSUBTYPE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrIngressPortIdSubtype;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTRINGRESSPORTID: {
        *var_len = table_entry.dot1agCfmLtrIngressPortId_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrIngressPortId, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTREGRESS: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrEgress;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTREGRESSMAC: {
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrEgressMac, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTREGRESSPORTIDSUBTYPE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmLtrEgressPortIdSubtype;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMLTREGRESSPORTID: {
        *var_len = table_entry.dot1agCfmLtrEgressPortId_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrEgressPortId, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMLTRORGANIZATIONSPECIFICTLV: {
        *var_len = table_entry.dot1agCfmLtrOrganizationSpecificTlv_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmLtrOrganizationSpecificTlv, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmLtrTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// dot1agCfmMepDbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot1agCfmMepDbTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           dot1agCfmMepDbTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot1agCfmMepDbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1agCfmMdIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMaIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMepIdentifier = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1agCfmMepDbRMepIdentifier = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot1agCfmMepDbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot1agCfmMepDbTable_fillobj(oid     *name,
             size_t  *length,
             dot1agCfmMepDbTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1agCfmMdIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMaIndex;
    name[name_pos++] = (oid) table_entry->dot1agCfmMepIdentifier;
    name[name_pos++] = (oid) table_entry->dot1agCfmMepDbRMepIdentifier;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * dot1agCfmMepDbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021CfmMib_var above.
 */
u_char *
dot1agCfmMepDbTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1agCfmMepDbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot1agCfmMepDbTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot1agCfmMepDbTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot1agCfmMepDbTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot1agCfmMepDbTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1AGCFMMEPDBRMEPSTATE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDbRMepState;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDBRMEPFAILEDOKTIME: {
        ieee8021CfmMib_global_ret.ulong_ret = table_entry.dot1agCfmMepDbRMepFailedOkTime;
        *var_len = sizeof(ieee8021CfmMib_global_ret.ulong_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.ulong_ret;
    }
    case DOT1AGCFMMEPDBMACADDRESS: {
        *var_len = 6;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepDbMacAddress, *var_len);
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPDBRDI: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDbRdi;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDBPORTSTATUSTLV: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDbPortStatusTlv;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDBINTERFACESTATUSTLV: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDbInterfaceStatusTlv;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDBCHASSISIDSUBTYPE: {
        ieee8021CfmMib_global_ret.long_ret = table_entry.dot1agCfmMepDbChassisIdSubtype;
        *var_len = sizeof(ieee8021CfmMib_global_ret.long_ret);
        return (u_char *) &ieee8021CfmMib_global_ret.long_ret;
    }
    case DOT1AGCFMMEPDBCHASSISID: {
        *var_len = table_entry.dot1agCfmMepDbChassisId_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepDbChassisId, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    case DOT1AGCFMMEPDBMANADDRESSDOMAIN: {
        memcpy(ieee8021CfmMib_global_ret.objid_ret, table_entry.dot1agCfmMepDbManAddressDomain, table_entry.dot1agCfmMepDbManAddressDomain_len * sizeof(oid));
        *var_len = table_entry.dot1agCfmMepDbManAddressDomain_len * sizeof(oid);
        return (u_char *) ieee8021CfmMib_global_ret.objid_ret;
    }
    case DOT1AGCFMMEPDBMANADDRESS: {
        *var_len = table_entry.dot1agCfmMepDbManAddress_len;
        memcpy(ieee8021CfmMib_global_ret.string_ret, table_entry.dot1agCfmMepDbManAddress, *var_len);
        ieee8021CfmMib_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ieee8021CfmMib_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1agCfmMepDbTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/

/******************************************************************************/
// dot1agCfmDefaultMdDefLevel_write()
/******************************************************************************/
int
dot1agCfmDefaultMdDefLevel_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMd_scalar_t scalar_entry;
    static dot1agCfmDefaultMd_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefLevel: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefLevel: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value > 7) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (dot1agCfmDefaultMd_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                dot1agCfmDefaultMdScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.dot1agCfmDefaultMdDefLevel = set_value;
            if (dot1agCfmDefaultMdScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmDefaultMdDefMhfCreation_write()
/******************************************************************************/
int
dot1agCfmDefaultMdDefMhfCreation_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMd_scalar_t scalar_entry;
    static dot1agCfmDefaultMd_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefMhfCreation: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefMhfCreation: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefMhfCreation: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (dot1agCfmDefaultMd_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                dot1agCfmDefaultMdScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.dot1agCfmDefaultMdDefMhfCreation = set_value;
            if (dot1agCfmDefaultMdScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmDefaultMdDefIdPermission_write()
/******************************************************************************/
int
dot1agCfmDefaultMdDefIdPermission_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMd_scalar_t scalar_entry;
    static dot1agCfmDefaultMd_scalar_t *old_scalar_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefIdPermission: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefIdPermission: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdDefIdPermission: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (((old_scalar_entry_p = (dot1agCfmDefaultMd_scalar_t *)ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                dot1agCfmDefaultMdScalar_get(old_scalar_entry_p))) {
                if (old_scalar_entry_p) {
                    malloc_ref_cnt = 1; /* Allocate success but get failed */
                }
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdScalar_get(&scalar_entry)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_scalar_entry_p) {
                scalar_entry = *old_scalar_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            scalar_entry.dot1agCfmDefaultMdDefIdPermission = set_value;
            if (dot1agCfmDefaultMdScalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdScalar_set(old_scalar_entry_p);
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_scalar_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_scalar_entry_p);
                old_scalar_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// dot1agCfmDefaultMdLevel_write()
/******************************************************************************/
int
dot1agCfmDefaultMdLevel_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMdTable_entry_t table_entry;
    static dot1agCfmDefaultMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdLevel: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdLevel: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != -1) {
                return SNMP_ERR_WRONGVALUE;
            }
            if (set_value < 0 || set_value > 7) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmDefaultMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmDefaultMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmDefaultMdLevel = set_value;
            if (dot1agCfmDefaultMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmDefaultMdMhfCreation_write()
/******************************************************************************/
int
dot1agCfmDefaultMdMhfCreation_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMdTable_entry_t table_entry;
    static dot1agCfmDefaultMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdMhfCreation: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdMhfCreation: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdMhfCreation: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmDefaultMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmDefaultMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmDefaultMdMhfCreation = set_value;
            if (dot1agCfmDefaultMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmDefaultMdIdPermission_write()
/******************************************************************************/
int
dot1agCfmDefaultMdIdPermission_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmDefaultMdTable_entry_t table_entry;
    static dot1agCfmDefaultMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdIdPermission: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdIdPermission: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmDefaultMdIdPermission: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmDefaultMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmDefaultMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmDefaultMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmDefaultMdIdPermission = set_value;
            if (dot1agCfmDefaultMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmDefaultMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmVlanPrimaryVid_write()
/******************************************************************************/
int
dot1agCfmVlanPrimaryVid_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmVlanTable_entry_t table_entry;
    static dot1agCfmVlanTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmVlanPrimaryVid: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmVlanPrimaryVid: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 1 || set_value > 4094) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmVlanTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmVlanTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmVlanTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmVlanTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmVlanPrimaryVid = set_value;
            if (dot1agCfmVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmVlanTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmVlanRowStatus_write()
/******************************************************************************/
int
dot1agCfmVlanRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmVlanTable_entry_t table_entry;
    static dot1agCfmVlanTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmVlanRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmVlanRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmVlanRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmVlanTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmVlanTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmVlanTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmVlanTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmVlanRowStatus = set_value;
            if (dot1agCfmVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmVlanTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdFormat_write()
/******************************************************************************/
int
dot1agCfmMdFormat_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdFormat: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdFormat: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdFormat: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMdFormat = set_value;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdName_write()
/******************************************************************************/
int
dot1agCfmMdName_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdName: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdName: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 43) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMdName, var_val, var_val_len);
            table_entry.dot1agCfmMdName_len = var_val_len;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdMdLevel_write()
/******************************************************************************/
int
dot1agCfmMdMdLevel_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMdLevel: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMdLevel: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 7) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMdMdLevel = set_value;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdMhfCreation_write()
/******************************************************************************/
int
dot1agCfmMdMhfCreation_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfCreation: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfCreation: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfCreation: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMdMhfCreation = set_value;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdMhfIdPermission_write()
/******************************************************************************/
int
dot1agCfmMdMhfIdPermission_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfIdPermission: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfIdPermission: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdMhfIdPermission: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMdMhfIdPermission = set_value;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMdRowStatus_write()
/******************************************************************************/
int
dot1agCfmMdRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMdTable_entry_t table_entry;
    static dot1agCfmMdTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMdRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMdTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMdTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMdTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMdRowStatus = set_value;
            if (dot1agCfmMdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMdTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaNetFormat_write()
/******************************************************************************/
int
dot1agCfmMaNetFormat_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaNetTable_entry_t table_entry;
    static dot1agCfmMaNetTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetFormat: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetFormat: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetFormat: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaNetTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaNetTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaNetFormat = set_value;
            if (dot1agCfmMaNetTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaNetTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaNetName_write()
/******************************************************************************/
int
dot1agCfmMaNetName_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMaNetTable_entry_t table_entry;
    static dot1agCfmMaNetTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetName: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetName: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 45) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaNetTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaNetTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMaNetName, var_val, var_val_len);
            table_entry.dot1agCfmMaNetName_len = var_val_len;
            if (dot1agCfmMaNetTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaNetTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaNetCcmInterval_write()
/******************************************************************************/
int
dot1agCfmMaNetCcmInterval_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaNetTable_entry_t table_entry;
    static dot1agCfmMaNetTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetCcmInterval: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetCcmInterval: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 0
                && set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
                && set_value != 7
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetCcmInterval: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaNetTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaNetTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaNetCcmInterval = set_value;
            if (dot1agCfmMaNetTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaNetTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaNetRowStatus_write()
/******************************************************************************/
int
dot1agCfmMaNetRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaNetTable_entry_t table_entry;
    static dot1agCfmMaNetTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaNetRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaNetTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaNetTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaNetTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaNetRowStatus = set_value;
            if (dot1agCfmMaNetTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaNetTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaCompPrimaryVlanId_write()
/******************************************************************************/
int
dot1agCfmMaCompPrimaryVlanId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaCompTable_entry_t table_entry;
    static dot1agCfmMaCompTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompPrimaryVlanId: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompPrimaryVlanId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 0) {
                return SNMP_ERR_WRONGVALUE;
            }
            if (set_value < 1 || set_value > 4094) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaCompTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaCompTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaCompPrimaryVlanId = set_value;
            if (dot1agCfmMaCompTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaCompTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaCompMhfCreation_write()
/******************************************************************************/
int
dot1agCfmMaCompMhfCreation_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaCompTable_entry_t table_entry;
    static dot1agCfmMaCompTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompMhfCreation: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompMhfCreation: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompMhfCreation: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaCompTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaCompTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaCompMhfCreation = set_value;
            if (dot1agCfmMaCompTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaCompTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaCompIdPermission_write()
/******************************************************************************/
int
dot1agCfmMaCompIdPermission_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaCompTable_entry_t table_entry;
    static dot1agCfmMaCompTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompIdPermission: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompIdPermission: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompIdPermission: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaCompTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaCompTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaCompIdPermission = set_value;
            if (dot1agCfmMaCompTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaCompTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaCompNumberOfVids_write()
/******************************************************************************/
int
dot1agCfmMaCompNumberOfVids_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMaCompTable_entry_t table_entry;
    static dot1agCfmMaCompTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompNumberOfVids: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompNumberOfVids: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaCompTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaCompTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaCompNumberOfVids = set_value;
            if (dot1agCfmMaCompTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaCompTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaCompRowStatus_write()
/******************************************************************************/
int
dot1agCfmMaCompRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaCompTable_entry_t table_entry;
    static dot1agCfmMaCompTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaCompRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaCompTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaCompTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaCompTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaCompRowStatus = set_value;
            if (dot1agCfmMaCompTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaCompTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMaMepListRowStatus_write()
/******************************************************************************/
int
dot1agCfmMaMepListRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMaMepListTable_entry_t table_entry;
    static dot1agCfmMaMepListTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaMepListRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaMepListRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMaMepListRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMaMepListTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMaMepListTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmMaMepListTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMaMepListTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMaMepListRowStatus = set_value;
            if (dot1agCfmMaMepListTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMaMepListTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepIfIndex_write()
/******************************************************************************/
int
dot1agCfmMepIfIndex_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepIfIndex: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepIfIndex: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 2147483647) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepIfIndex = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepDirection_write()
/******************************************************************************/
int
dot1agCfmMepDirection_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepDirection: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepDirection: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepDirection: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepDirection = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepPrimaryVid_write()
/******************************************************************************/
int
dot1agCfmMepPrimaryVid_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepPrimaryVid: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepPrimaryVid: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 16777215) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepPrimaryVid = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepActive_write()
/******************************************************************************/
int
dot1agCfmMepActive_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepActive: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepActive: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepActive: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepActive = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepCciEnabled_write()
/******************************************************************************/
int
dot1agCfmMepCciEnabled_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepCciEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepCciEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepCciEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepCciEnabled = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepCcmLtmPriority_write()
/******************************************************************************/
int
dot1agCfmMepCcmLtmPriority_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepCcmLtmPriority: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepCcmLtmPriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 7) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepCcmLtmPriority = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepLowPrDef_write()
/******************************************************************************/
int
dot1agCfmMepLowPrDef_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepLowPrDef: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepLowPrDef: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepLowPrDef: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepLowPrDef = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepFngAlarmTime_write()
/******************************************************************************/
int
dot1agCfmMepFngAlarmTime_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepFngAlarmTime: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepFngAlarmTime: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 250 || set_value > 1000) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepFngAlarmTime = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepFngResetTime_write()
/******************************************************************************/
int
dot1agCfmMepFngResetTime_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepFngResetTime: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepFngResetTime: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 250 || set_value > 1000) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepFngResetTime = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmStatus_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmStatus = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmDestMacAddress_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmDestMacAddress_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestMacAddress: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestMacAddress: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 6) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMepTransmitLbmDestMacAddress, var_val, var_val_len);
            table_entry.dot1agCfmMepTransmitLbmDestMacAddress_len = var_val_len;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmDestMepId_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmDestMepId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestMepId: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestMepId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 0) {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 8191) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmDestMepId = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmDestIsMepId_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmDestIsMepId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestIsMepId: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestIsMepId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDestIsMepId: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmDestIsMepId = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmMessages_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmMessages_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmMessages: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmMessages: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 1 || set_value > 1024) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmMessages = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmDataTlv_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmDataTlv_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDataTlv: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmDataTlv: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMepTransmitLbmDataTlv, var_val, var_val_len);
            table_entry.dot1agCfmMepTransmitLbmDataTlv_len = var_val_len;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmVlanPriority_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmVlanPriority_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmVlanPriority: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmVlanPriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 7) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmVlanPriority = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLbmVlanDropEnable_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLbmVlanDropEnable_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmVlanDropEnable: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmVlanDropEnable: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLbmVlanDropEnable: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLbmVlanDropEnable = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmStatus_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLtmStatus = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmFlags_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmFlags_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmFlags: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmFlags: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMepTransmitLtmFlags, var_val, var_val_len);
            table_entry.dot1agCfmMepTransmitLtmFlags_len = var_val_len;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmTargetMacAddress_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmTargetMacAddress_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetMacAddress: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetMacAddress: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 6) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMepTransmitLtmTargetMacAddress, var_val, var_val_len);
            table_entry.dot1agCfmMepTransmitLtmTargetMacAddress_len = var_val_len;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmTargetMepId_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmTargetMepId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetMepId: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetMepId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 0) {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 8191) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLtmTargetMepId = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmTargetIsMepId_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmTargetIsMepId_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetIsMepId: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetIsMepId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTargetIsMepId: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLtmTargetIsMepId = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmTtl_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmTtl_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    u_long set_value = var_val ? *((u_long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTtl: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmTtl: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 255) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepTransmitLtmTtl = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepTransmitLtmEgressIdentifier_write()
/******************************************************************************/
int
dot1agCfmMepTransmitLtmEgressIdentifier_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmEgressIdentifier: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021CFMMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepTransmitLtmEgressIdentifier: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 8) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.dot1agCfmMepTransmitLtmEgressIdentifier, var_val, var_val_len);
            table_entry.dot1agCfmMepTransmitLtmEgressIdentifier_len = var_val_len;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// dot1agCfmMepRowStatus_write()
/******************************************************************************/
int
dot1agCfmMepRowStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    dot1agCfmMepTable_entry_t table_entry;
    static dot1agCfmMepTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to dot1agCfmMepRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (dot1agCfmMepTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (dot1agCfmMepTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && dot1agCfmMepTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.dot1agCfmMepRowStatus = set_value;
            if (dot1agCfmMepTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = dot1agCfmMepTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

