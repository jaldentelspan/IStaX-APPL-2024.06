/*

 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "ucd_snmp_rip2.h"
#include "rfc1724_rip2.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define RIP2_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define RIP2_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define RIP2_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long                long_ret;
    char                string_ret[RIP2_STR_LEN_MAX + 1];
    u_char              ip_string_ret[4];
    u_long              ulong_ret;
} rip2_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod rip2_var;
FindVarMethod rip2IfStatTable_var;
FindVarMethod rip2IfConfTable_var;
FindVarMethod rip2PeerTable_var;
WriteMethod rip2IfStatStatus_write;
WriteMethod rip2IfConfDomain_write;
WriteMethod rip2IfConfAuthType_write;
WriteMethod rip2IfConfAuthKey_write;
WriteMethod rip2IfConfSend_write;
WriteMethod rip2IfConfReceive_write;
WriteMethod rip2IfConfDefaultMetric_write;
WriteMethod rip2IfConfStatus_write;
WriteMethod rip2IfConfSrcAddress_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, rip2_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static rip2_ret_t rip2_global_ret;

/*
 * rip2_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid rip2_variables_oid[] = {1,3,6,1,2,1,23};



/*
 * variable rip2_variables:
 *   this variable defines function callbacks and type return information
 *   for the rip2 mib section
 */

struct variable4 rip2_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define RIP2GLOBALROUTECHANGES		1
    {RIP2GLOBALROUTECHANGES, ASN_COUNTER, RONLY, rip2_var, 2, {1,1}},
#define RIP2GLOBALQUERIES		2
    {RIP2GLOBALQUERIES, ASN_COUNTER, RONLY, rip2_var, 2, {1,2}},

#define RIP2IFSTATADDRESS		3
    {RIP2IFSTATADDRESS, ASN_IPADDRESS, RONLY, rip2IfStatTable_var, 3, {2, 1, 1}},
#define RIP2IFSTATRCVBADPACKETS		4
    {RIP2IFSTATRCVBADPACKETS, ASN_COUNTER, RONLY, rip2IfStatTable_var, 3, {2, 1, 2}},
#define RIP2IFSTATRCVBADROUTES		5
    {RIP2IFSTATRCVBADROUTES, ASN_COUNTER, RONLY, rip2IfStatTable_var, 3, {2, 1, 3}},
#define RIP2IFSTATSENTUPDATES		6
    {RIP2IFSTATSENTUPDATES, ASN_COUNTER, RONLY, rip2IfStatTable_var, 3, {2, 1, 4}},
#define RIP2IFSTATSTATUS		7
    {RIP2IFSTATSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, rip2IfStatTable_var, 3, {2, 1, 5}},
#define RIP2IFCONFADDRESS		8
    {RIP2IFCONFADDRESS, ASN_IPADDRESS, RONLY, rip2IfConfTable_var, 3, {3, 1, 1}},
#define RIP2IFCONFDOMAIN		9
    {RIP2IFCONFDOMAIN, ASN_OCTET_STR, RONLY/* Changed from RWRITE */, rip2IfConfTable_var, 3, {3, 1, 2}},
#define RIP2IFCONFAUTHTYPE		10
    {RIP2IFCONFAUTHTYPE, ASN_INTEGER, RWRITE, rip2IfConfTable_var, 3, {3, 1, 3}},
#define RIP2IFCONFAUTHKEY		11
// unsupported    {RIP2IFCONFAUTHKEY, ASN_OCTET_STR, RWRITE, rip2IfConfTable_var, 3, {3, 1, 4}},
#define RIP2IFCONFSEND		12
    {RIP2IFCONFSEND, ASN_INTEGER, RONLY/* Changed from RWRITE */, rip2IfConfTable_var, 3, {3, 1, 5}},
#define RIP2IFCONFRECEIVE		13
    {RIP2IFCONFRECEIVE, ASN_INTEGER, RWRITE, rip2IfConfTable_var, 3, {3, 1, 6}},
#define RIP2IFCONFDEFAULTMETRIC		14
    {RIP2IFCONFDEFAULTMETRIC, ASN_INTEGER, RONLY/* Changed from RWRITE */, rip2IfConfTable_var, 3, {3, 1, 7}},
#define RIP2IFCONFSTATUS		15
    {RIP2IFCONFSTATUS, ASN_INTEGER, RONLY/* Changed from RWRITE */, rip2IfConfTable_var, 3, {3, 1, 8}},
#define RIP2IFCONFSRCADDRESS		16
    {RIP2IFCONFSRCADDRESS, ASN_IPADDRESS, RONLY/* Changed from RWRITE */, rip2IfConfTable_var, 3, {3, 1, 9}},
#define RIP2PEERADDRESS		17
    {RIP2PEERADDRESS, ASN_IPADDRESS, RONLY, rip2PeerTable_var, 3, {4, 1, 1}},
#define RIP2PEERDOMAIN		18
    {RIP2PEERDOMAIN, ASN_OCTET_STR, RONLY, rip2PeerTable_var, 3, {4, 1, 2}},
#define RIP2PEERLASTUPDATE		19
    {RIP2PEERLASTUPDATE, ASN_TIMETICKS, RONLY, rip2PeerTable_var, 3, {4, 1, 3}},
#define RIP2PEERVERSION		20
    {RIP2PEERVERSION, ASN_INTEGER, RONLY, rip2PeerTable_var, 3, {4, 1, 4}},
#define RIP2PEERRCVBADPACKETS		21
    {RIP2PEERRCVBADPACKETS, ASN_COUNTER, RONLY, rip2PeerTable_var, 3, {4, 1, 5}},
#define RIP2PEERRCVBADROUTES		22
    {RIP2PEERRCVBADROUTES, ASN_COUNTER, RONLY, rip2PeerTable_var, 3, {4, 1, 6}},
};


/******************************************************************************/
// ucd_snmp_init_rip2()
// Initializes the UCD-SNMP-part of the RIPv2-MIB:rip2.
/******************************************************************************/
void ucd_snmp_init_rip2(void)
{
    DEBUGMSGTL(("rip2", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("rip2", rip2_variables, variable4, rip2_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * rip2_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
rip2_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{
    rip2Globals_scalar_t rip2Globals_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (rip2GlobalsScalar_get(&rip2Globals_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RIP2GLOBALROUTECHANGES: {
        rip2_global_ret.ulong_ret = rip2Globals_scalar_entry.rip2GlobalRouteChanges;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2GLOBALQUERIES: {
        rip2_global_ret.ulong_ret = rip2Globals_scalar_entry.rip2GlobalQueries;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in rip2_var\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
// rip2IfStatTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
rip2IfStatTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           rip2IfStatTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 4 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (rip2IfStatTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->rip2IfStatAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->rip2IfStatAddress = ntohl(table_entry->rip2IfStatAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->rip2IfStatAddress = ntohl(table_entry->rip2IfStatAddress);
            if (!rip2IfStatTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!rip2IfStatTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->rip2IfStatAddress = ntohl(table_entry->rip2IfStatAddress);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// rip2IfStatTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
rip2IfStatTable_fillobj(oid     *name,
             size_t  *length,
             rip2IfStatTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->rip2IfStatAddress = htonl(table_entry->rip2IfStatAddress);
    cp = (u_char *) &table_entry->rip2IfStatAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->rip2IfStatAddress = ntohl(table_entry->rip2IfStatAddress);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * rip2IfStatTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for rip2_var above.
 */
u_char *
rip2IfStatTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    rip2IfStatTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = rip2IfStatTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (rip2IfStatTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (rip2IfStatTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == RIP2IFSTATSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = rip2IfStatStatus_write;
                }
                return NULL;
            }
            if (rip2IfStatTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RIP2IFSTATADDRESS: {
        table_entry.rip2IfStatAddress = htonl(table_entry.rip2IfStatAddress);
        cp = (u_char *) &table_entry.rip2IfStatAddress;
        rip2_global_ret.ip_string_ret[0] = *cp++;
        rip2_global_ret.ip_string_ret[1] = *cp++;
        rip2_global_ret.ip_string_ret[2] = *cp++;
        rip2_global_ret.ip_string_ret[3] = *cp;
        table_entry.rip2IfStatAddress = ntohl(table_entry.rip2IfStatAddress);
        *var_len = sizeof(rip2_global_ret.ip_string_ret);
        return rip2_global_ret.ip_string_ret;
    }
    case RIP2IFSTATRCVBADPACKETS: {
        rip2_global_ret.ulong_ret = table_entry.rip2IfStatRcvBadPackets;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2IFSTATRCVBADROUTES: {
        rip2_global_ret.ulong_ret = table_entry.rip2IfStatRcvBadRoutes;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2IFSTATSENTUPDATES: {
        rip2_global_ret.ulong_ret = table_entry.rip2IfStatSentUpdates;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2IFSTATSTATUS: {
        *write_method = rip2IfStatStatus_write;
        rip2_global_ret.long_ret = table_entry.rip2IfStatStatus;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_rip2IfStatTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// rip2IfConfTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
rip2IfConfTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           rip2IfConfTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 4 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (rip2IfConfTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->rip2IfConfAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->rip2IfConfAddress = ntohl(table_entry->rip2IfConfAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->rip2IfConfAddress = ntohl(table_entry->rip2IfConfAddress);
            if (!rip2IfConfTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!rip2IfConfTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->rip2IfConfAddress = ntohl(table_entry->rip2IfConfAddress);

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// rip2IfConfTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
rip2IfConfTable_fillobj(oid     *name,
             size_t  *length,
             rip2IfConfTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;

    len = 4;
    table_entry->rip2IfConfAddress = htonl(table_entry->rip2IfConfAddress);
    cp = (u_char *) &table_entry->rip2IfConfAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->rip2IfConfAddress = ntohl(table_entry->rip2IfConfAddress);

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * rip2IfConfTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for rip2_var above.
 */
u_char *
rip2IfConfTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    rip2IfConfTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = rip2IfConfTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (rip2IfConfTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (rip2IfConfTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == RIP2IFCONFSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = rip2IfConfStatus_write;
                }
                return NULL;
            }
            if (rip2IfConfTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RIP2IFCONFADDRESS: {
        table_entry.rip2IfConfAddress = htonl(table_entry.rip2IfConfAddress);
        cp = (u_char *) &table_entry.rip2IfConfAddress;
        rip2_global_ret.ip_string_ret[0] = *cp++;
        rip2_global_ret.ip_string_ret[1] = *cp++;
        rip2_global_ret.ip_string_ret[2] = *cp++;
        rip2_global_ret.ip_string_ret[3] = *cp;
        table_entry.rip2IfConfAddress = ntohl(table_entry.rip2IfConfAddress);
        *var_len = sizeof(rip2_global_ret.ip_string_ret);
        return rip2_global_ret.ip_string_ret;
    }
    case RIP2IFCONFDOMAIN: {
        *write_method = rip2IfConfDomain_write;
        *var_len = table_entry.rip2IfConfDomain_len;
        memcpy(rip2_global_ret.string_ret, table_entry.rip2IfConfDomain, *var_len);
        rip2_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) rip2_global_ret.string_ret;
    }
    case RIP2IFCONFAUTHTYPE: {
        *write_method = rip2IfConfAuthType_write;
        rip2_global_ret.long_ret = table_entry.rip2IfConfAuthType;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2IFCONFAUTHKEY: {
        *write_method = rip2IfConfAuthKey_write;
        *var_len = table_entry.rip2IfConfAuthKey_len;
        memcpy(rip2_global_ret.string_ret, table_entry.rip2IfConfAuthKey, *var_len);
        rip2_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) rip2_global_ret.string_ret;
    }
    case RIP2IFCONFSEND: {
        *write_method = rip2IfConfSend_write;
        rip2_global_ret.long_ret = table_entry.rip2IfConfSend;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2IFCONFRECEIVE: {
        *write_method = rip2IfConfReceive_write;
        rip2_global_ret.long_ret = table_entry.rip2IfConfReceive;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2IFCONFDEFAULTMETRIC: {
        *write_method = rip2IfConfDefaultMetric_write;
        rip2_global_ret.long_ret = table_entry.rip2IfConfDefaultMetric;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2IFCONFSTATUS: {
        *write_method = rip2IfConfStatus_write;
        rip2_global_ret.long_ret = table_entry.rip2IfConfStatus;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2IFCONFSRCADDRESS: {
        *write_method = rip2IfConfSrcAddress_write;
        table_entry.rip2IfConfSrcAddress = htonl(table_entry.rip2IfConfSrcAddress);
        cp = (u_char *) &table_entry.rip2IfConfSrcAddress;
        rip2_global_ret.ip_string_ret[0] = *cp++;
        rip2_global_ret.ip_string_ret[1] = *cp++;
        rip2_global_ret.ip_string_ret[2] = *cp++;
        rip2_global_ret.ip_string_ret[3] = *cp;
        table_entry.rip2IfConfSrcAddress = ntohl(table_entry.rip2IfConfSrcAddress);
        *var_len = sizeof(rip2_global_ret.ip_string_ret);
        return rip2_global_ret.ip_string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_rip2IfConfTable\n", vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// rip2PeerTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
rip2PeerTable_parse(oid     *name,
           size_t  *length,
           int     exact,
           rip2PeerTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    /* Quick filter for 'GET' operation
     * 8 for the table OIDs length
     * + 1 for the table entry
     * + 6 for the minmum table index input length
     */
    if (exact && *length < (8 + 1 + 6)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (rip2PeerTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 4;
    cp = (u_char *) &table_entry->rip2PeerAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                if (exact) {
                    return -1; /* illegal value */
                } else {
                    *cp++ = 255;
                    table_entry->rip2PeerAddress = ntohl(table_entry->rip2PeerAddress);
                    return 0; /* return the parsing and get next */
                }
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            table_entry->rip2PeerAddress = ntohl(table_entry->rip2PeerAddress);
            if (!rip2PeerTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!rip2PeerTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }
    table_entry->rip2PeerAddress = ntohl(table_entry->rip2PeerAddress);
    len = 2;
    table_entry->rip2PeerDomain_len = len;
    cp = (u_char *) table_entry->rip2PeerDomain;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            if (!rip2PeerTableEntry_get(table_entry, FALSE)) {
                return 1;
            } else if (!rip2PeerTableEntry_get(table_entry, TRUE)) {
                return 1;
            }
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// rip2PeerTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
rip2PeerTable_fillobj(oid     *name,
             size_t  *length,
             rip2PeerTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    u_char  *cp = NULL;
    int     len = 0;
    int     idx = 0;

    len = 4;
    table_entry->rip2PeerAddress = htonl(table_entry->rip2PeerAddress);
    cp = (u_char *) &table_entry->rip2PeerAddress;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->rip2PeerAddress = ntohl(table_entry->rip2PeerAddress);
    len = (int) table_entry->rip2PeerDomain_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->rip2PeerDomain[idx++];
    }

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * rip2PeerTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for rip2_var above.
 */
u_char *
rip2PeerTable_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    u_char              *cp = NULL;
    rip2PeerTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = rip2PeerTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (rip2PeerTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (rip2PeerTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (rip2PeerTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RIP2PEERADDRESS: {
        table_entry.rip2PeerAddress = htonl(table_entry.rip2PeerAddress);
        cp = (u_char *) &table_entry.rip2PeerAddress;
        rip2_global_ret.ip_string_ret[0] = *cp++;
        rip2_global_ret.ip_string_ret[1] = *cp++;
        rip2_global_ret.ip_string_ret[2] = *cp++;
        rip2_global_ret.ip_string_ret[3] = *cp;
        table_entry.rip2PeerAddress = ntohl(table_entry.rip2PeerAddress);
        *var_len = sizeof(rip2_global_ret.ip_string_ret);
        return rip2_global_ret.ip_string_ret;
    }
    case RIP2PEERDOMAIN: {
        *var_len = table_entry.rip2PeerDomain_len;
        memcpy(rip2_global_ret.string_ret, table_entry.rip2PeerDomain, *var_len);
        rip2_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) rip2_global_ret.string_ret;
    }
    case RIP2PEERLASTUPDATE: {
        rip2_global_ret.ulong_ret = table_entry.rip2PeerLastUpdate;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2PEERVERSION: {
        rip2_global_ret.long_ret = table_entry.rip2PeerVersion;
        *var_len = sizeof(rip2_global_ret.long_ret);
        return (u_char *) &rip2_global_ret.long_ret;
    }
    case RIP2PEERRCVBADPACKETS: {
        rip2_global_ret.ulong_ret = table_entry.rip2PeerRcvBadPackets;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    case RIP2PEERRCVBADROUTES: {
        rip2_global_ret.ulong_ret = table_entry.rip2PeerRcvBadRoutes;
        *var_len = sizeof(rip2_global_ret.ulong_ret);
        return (u_char *) &rip2_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_rip2PeerTable\n", vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// rip2IfStatStatus_write()
/******************************************************************************/
int
rip2IfStatStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfStatTable_entry_t table_entry;
    static rip2IfStatTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfStatStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfStatStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to rip2IfStatStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfStatTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfStatTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                rip2IfStatTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfStatTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfStatStatus = set_value;
            if (rip2IfStatTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfStatTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfDomain_write()
/******************************************************************************/
int
rip2IfConfDomain_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfDomain: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > RIP2_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfDomain: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 2) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.rip2IfConfDomain, var_val, var_val_len);
            table_entry.rip2IfConfDomain_len = var_val_len;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfAuthType_write()
/******************************************************************************/
int
rip2IfConfAuthType_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfAuthType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfAuthType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
            ) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfAuthType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfAuthType = set_value;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfAuthKey_write()
/******************************************************************************/
int
rip2IfConfAuthKey_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfAuthKey: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > RIP2_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfAuthKey: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 16) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy(table_entry.rip2IfConfAuthKey, var_val, var_val_len);
            table_entry.rip2IfConfAuthKey_len = var_val_len;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfSend_write()
/******************************************************************************/
int
rip2IfConfSend_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfSend: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfSend: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfSend: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfSend = set_value;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfReceive_write()
/******************************************************************************/
int
rip2IfConfReceive_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfReceive: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfReceive: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
            ) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfReceive: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfReceive = set_value;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfDefaultMetric_write()
/******************************************************************************/
int
rip2IfConfDefaultMetric_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfDefaultMetric: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfDefaultMetric: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value < 0 || set_value > 15) {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfDefaultMetric = set_value;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfStatus_write()
/******************************************************************************/
int
rip2IfConfStatus_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    long set_value = var_val ? *((long *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4
                && set_value != 5
                && set_value != 6
            ) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfStatus = set_value;
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// rip2IfConfSrcAddress_write()
/******************************************************************************/
int
rip2IfConfSrcAddress_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
    in_addr_t set_value = var_val ? *((in_addr_t *) var_val) : 0;
    rip2IfConfTable_entry_t table_entry;
    static rip2IfConfTable_entry_t *old_table_entry_p = NULL;
    static int malloc_ref_cnt = 0;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != ASN_IPADDRESS) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfSrcAddress: not ASN_IPADDRESS\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(in_addr_t)) {
                (void) snmp_log(LOG_ERR, "write to rip2IfConfSrcAddress: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (!malloc_ref_cnt && (old_table_entry_p = (rip2IfConfTable_entry_t *)ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            malloc_ref_cnt++;
            if (rip2IfConfTable_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        case ACTION: {
            // Re-get configration when multiple variables binding in one SNMP packet
            if (malloc_ref_cnt > 1 && rip2IfConfTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            // Set new configuration
            if (old_table_entry_p) {
                table_entry = *old_table_entry_p;
            } else {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            table_entry.rip2IfConfSrcAddress = set_value;
            table_entry.rip2IfConfSrcAddress = ntohl(table_entry.rip2IfConfSrcAddress);
            if (rip2IfConfTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = rip2IfConfTableEntry_set(old_table_entry_p);
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            if (old_table_entry_p && malloc_ref_cnt == 1 /* last reference */) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
                malloc_ref_cnt = 0;
            } else if (malloc_ref_cnt >= 1) {
                malloc_ref_cnt--;
            }
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}

