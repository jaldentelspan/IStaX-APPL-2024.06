/*
 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "rfc1724_rip2.h"
#include "ucd_snmp_rip2.h"
#include "mibContextTable.h" // mibContextTable_register()
// FIXME: Remove the include file if your implementation don't need to redefine the standard standard MIB objects
#include "snmp_mib_redefine.h"  // snmp_mib_redefine_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>

#include "frr_rip_api.hxx"

/****************************************************************************/
/** Module default trace group declaration                                  */
/****************************************************************************/
#define VTSS_TRACE_DEFAULT_GROUP FRR_TRACE_GRP_SNMP
#include "frr_trace.hxx"  // For module trace group definitions

/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the RIPv2-MIB:rip2.
  **/
void rfc1724_rip2_init(void)
{
    VTSS_TRACE(DEBUG) << "enter";
    ucd_snmp_init_rip2();


    /* Register snmpMibRedefineTable */

    // rip2IfStatStatus
    oid rip2IfStatStatus_variables_oid[] = { 1,3,6,1,2,1,23, 2, 1, 5 };
    snmp_mib_redefine_register(rip2IfStatStatus_variables_oid,
                               sizeof(rip2IfStatStatus_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfStatStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TURE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // rip2IfConfDomain
    oid rip2IfConfDomain_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 2 };
    snmp_mib_redefine_register(rip2IfConfDomain_variables_oid,
                               sizeof(rip2IfConfDomain_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfDomain",
                               "RouteTag",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "{2 2}" /* redefine_descr */);

    // rip2IfConfAuthType
    oid rip2IfConfAuthType_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 3 };
    snmp_mib_redefine_register(rip2IfConfAuthType_variables_oid,
                               sizeof(rip2IfConfAuthType_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfAuthType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "\
{1 noAuthentication} \
{2 simplePassword} \
{3 md5} \
" /* redefine_descr */);

    // rip2IfConfAuthKey
    oid rip2IfConfAuthKey_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 4 };
    snmp_mib_redefine_register(rip2IfConfAuthKey_variables_oid,
                               sizeof(rip2IfConfAuthKey_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfAuthKey",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "{0 16}" /* redefine_descr */);

    // rip2IfConfSend
    oid rip2IfConfSend_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 5 };
    snmp_mib_redefine_register(rip2IfConfSend_variables_oid,
                               sizeof(rip2IfConfSend_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfSend",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "\
{1 doNotSend} \
{2 ripVersion1} \
{3 rip1Compatible} \
{4 ripVersion2} \
{5 ripV1Demand} \
{6 ripV2Demand} \
" /* redefine_descr */);

    // rip2IfConfReceive
    oid rip2IfConfReceive_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 6 };
    snmp_mib_redefine_register(rip2IfConfReceive_variables_oid,
                               sizeof(rip2IfConfReceive_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfReceive",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "\
{1 rip1} \
{2 rip2} \
{3 rip1OrRip2} \
{4 doNotRecieve} \
" /* redefine_descr */);

    // rip2IfConfDefaultMetric
    oid rip2IfConfDefaultMetric_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 7 };
    snmp_mib_redefine_register(rip2IfConfDefaultMetric_variables_oid,
                               sizeof(rip2IfConfDefaultMetric_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfDefaultMetric",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TURE if size is redefined. */
                               "{0 15}" /* redefine_descr */);

    // rip2IfConfStatus
    oid rip2IfConfStatus_variables_oid[] = { 1,3,6,1,2,1,23, 3, 1, 8 };
    snmp_mib_redefine_register(rip2IfConfStatus_variables_oid,
                               sizeof(rip2IfConfStatus_variables_oid) / sizeof(oid),
                               "RIPv2-MIB : rip2IfConfStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TURE if size is redefined. */
                               "{1 active}" /* redefine_descr */);


    // FIXME: Update the mib context table
    /* Register mibContextTable.
     * Syntax of description: <MIB_Name> : <Supported_OID_Name> */
    oid rip2_variables_oid[] = { 1,3,6,1,2,1,23 };
    mibContextTable_register(rip2_variables_oid,
                             sizeof(rip2_variables_oid) / sizeof(oid),
                             "RIPv2-MIB : rip2");

    VTSS_TRACE(DEBUG) << "exit";
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/
/**
  * \brief Get scalar data of rip2GlobalsScalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2GlobalsScalar_get(rip2Globals_scalar_t *scalar_entry)
{
    VTSS_TRACE(DEBUG) << "enter";
    mesa_rc rc = VTSS_RC_OK;

    /* Get general status */
    vtss_appl_rip_general_status_t status = {};
    if ((rc = vtss_appl_rip_general_status_get(&status)) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get RIP general status fail!";
        return rc;
    }

    /* Update the MIB parameter values */
    scalar_entry->rip2GlobalRouteChanges = status.global_route_changes;
    scalar_entry->rip2GlobalQueries = status.global_queries;

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set scalar data of rip2GlobalsScalar
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2GlobalsScalar_set(rip2Globals_scalar_t *scalar_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of rip2IfStatTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfStatTableEntry_getfirst(rip2IfStatTable_entry_t *table_entry)
{
    /* 0 is invalid key, so we can use it for get-first operator. */
    table_entry->rip2IfStatAddress = 0;
    return rip2IfStatTableEntry_get(table_entry, TRUE);
}

/**
  * \brief Get/Getnext table entry of rip2IfStatTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfStatTableEntry_get(rip2IfStatTable_entry_t *table_entry, int getnext)
{
    mesa_ipv4_t key = {};
    mesa_ipv4_t next_addr = 0; // for next ipaddr use
    vtss_appl_rip_interface_status_t entry = {};
    mesa_rc rc = VTSS_RC_OK;

    VTSS_TRACE(DEBUG) << __func__ << " enter getnext:" << getnext;
    VTSS_TRACE(DEBUG) << " key:" << vtss::AsIpv4(table_entry->rip2IfStatAddress);

    key = table_entry->rip2IfStatAddress;
    rc =  vtss_appl_rip_intf_status_snmp_get(getnext, &key, &next_addr, &entry);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get interface " << vtss::AsIpv4(key)
                          << " failed";
        return -1;
    }
    if (getnext) {
        key = next_addr;
    }

    /* fill in the key */
    table_entry->rip2IfStatAddress = key;

    /* fill in the data */
    table_entry->rip2IfStatRcvBadPackets = entry.recv_badpackets;
    table_entry->rip2IfStatRcvBadRoutes = entry.recv_badroutes;
    table_entry->rip2IfStatSentUpdates = entry.sent_updates;
    table_entry->rip2IfStatStatus = 1;  // {1 active} {2 notInService}
                                        // {3 notReady} {4 createAndGo}
                                        // {5 createAndWait} {6 destroy}
    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of rip2IfStatTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfStatTableEntry_set(rip2IfStatTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get first table entry of rip2IfConfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfConfTableEntry_getfirst(rip2IfConfTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";
    table_entry->rip2IfConfAddress = 0;
    VTSS_TRACE(DEBUG) << "exit";
    return rip2IfConfTableEntry_get(table_entry, TRUE);
}

/**
  * \brief Get/Getnext table entry of rip2IfConfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfConfTableEntry_get(rip2IfConfTable_entry_t *table_entry, int getnext)
{
//    mesa_ipv4_t key = {};
    mesa_ipv4_t next_addr = 0;
    vtss_appl_rip_intf_conf_t conf = {};
    vtss_appl_rip_router_conf_t router_conf;
    mesa_rc rc = VTSS_RC_OK;

    VTSS_TRACE(DEBUG) << __func__ << " enter getnext:" << getnext;
    VTSS_TRACE(DEBUG) << " key:" << vtss::AsIpv4(table_entry->rip2IfConfAddress);

    //key = table_entry->rip2IfConfAddress;
    rc = vtss_appl_rip_intf_conf_snmp_get(getnext, &table_entry->rip2IfConfAddress, &next_addr, &conf);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get interface " << vtss::AsIpv4(table_entry->rip2IfConfAddress)
                          << " failed";
        return -1;
    }
    if (getnext) {
        //key = next_addr;
        table_entry->rip2IfConfAddress = next_addr;
    }

    /* Get the current configuration */
    if (vtss_appl_rip_router_conf_get(&router_conf) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "Get RIP router configuration failed.\n";
        return -1;
    }

    /* Get default route metric */
    vtss_appl_rip_db_key_t key;
    key.network = {0, 0};
    key.nexthop = 0;
    vtss_appl_rip_db_data_t data = {};
    (void) vtss_appl_rip_db_get(&key, &data);
    table_entry->rip2IfConfDefaultMetric = data.metric;

    /* fill in the data */
    table_entry->rip2IfConfDomain_len = 2;

    /* rip2IfConfAuthType
     * {1 noAuthentication} {2 simplePassword} {3 md5}
     */
    if (conf.auth_type == VTSS_APPL_RIP_AUTH_TYPE_NULL) {
        table_entry->rip2IfConfAuthType = 1;
    } else if (conf.auth_type == VTSS_APPL_RIP_AUTH_TYPE_SIMPLE_PASSWORD) {
        table_entry->rip2IfConfAuthType = 2;
    } else if (conf.auth_type == VTSS_APPL_RIP_AUTH_TYPE_MD5) {
        table_entry->rip2IfConfAuthType = 3;
    } else {
        /* should not be happened */
        VTSS_TRACE(WARNING) << "Got unexpected auth type on interface "
                            << vtss::AsIpv4(table_entry->rip2IfConfAddress);
    }

    /* rip2IfConfAuthKey
     * According RFC-1724 - section 4.2 RIP Interface Tables, page 10
     * Reading this object always results in an OCTET
     * STRING of length zero; authentication may not
     * be bypassed by reading the MIB object.
     */
    table_entry->rip2IfConfAuthKey_len = 0;

    /* rip2IfConfSend
     * doNotSend (1), ripVersion1 (2), rip1Compatible (3),
     * ripVersion2 (4), ripV1Demand (5), ripV2Demand (6)
     */
    if (conf.send_ver == VTSS_APPL_RIP_INTF_SEND_VER_1) {
        table_entry->rip2IfConfSend = 2;        // ripVersion1 (2)
    } else if (conf.send_ver == VTSS_APPL_RIP_INTF_SEND_VER_2) {
        table_entry->rip2IfConfSend = 4;        // ripVersion2 (4)
    } else if (conf.send_ver == VTSS_APPL_RIP_INTF_SEND_VER_BOTH) {
        table_entry->rip2IfConfSend = 4;        // ripVersion2 (4)
    } else if (conf.send_ver == VTSS_APPL_RIP_INTF_SEND_VER_NOT_SPECIFIED) {
        if (router_conf.version == VTSS_APPL_RIP_GLOBAL_VER_1) {
            table_entry->rip2IfConfSend = 2;    // ripVersion1 (2)
        } else {
             table_entry->rip2IfConfSend = 4;   // ripVersion2 (4)
        }
    } else {
        /* should not be happened */
        VTSS_TRACE(WARNING) << "Got unexpected version on interface "
                            << vtss::AsIpv4(table_entry->rip2IfConfAddress);
        return -1;
    }

    /* rip2IfConfReceive
     * rip1 (1), rip2 (2), rip1OrRip2 (3), doNotRecieve (4)
     */
    if (conf.recv_ver == VTSS_APPL_RIP_INTF_RECV_VER_NONE) {
        table_entry->rip2IfConfReceive = 4;     // doNotRecieve (4)
    } else if (conf.recv_ver == VTSS_APPL_RIP_INTF_RECV_VER_1) {
        table_entry->rip2IfConfReceive = 1;     // rip1 (1)
    } else if (conf.recv_ver == VTSS_APPL_RIP_INTF_RECV_VER_2) {
        table_entry->rip2IfConfReceive = 2;     // rip2 (2)
    } else if (conf.recv_ver == VTSS_APPL_RIP_INTF_RECV_VER_BOTH) {
        table_entry->rip2IfConfReceive = 3;     // rip1OrRip2 (3)
    } else if (conf.recv_ver == VTSS_APPL_RIP_INTF_RECV_VER_NOT_SPECIFIED) {
        if (router_conf.version == VTSS_APPL_RIP_GLOBAL_VER_1) {
            table_entry->rip2IfConfReceive = 1; // rip1 (1)
        } else if (router_conf.version == VTSS_APPL_RIP_GLOBAL_VER_2){
            table_entry->rip2IfConfReceive = 2; // rip2 (2)
        } else {
            table_entry->rip2IfConfReceive = 3; // rip1OrRip2 (3)
        }
    } else {
        /* should not be happened */
        VTSS_TRACE(WARNING) << "Got unexpected version on interface "
                            << vtss::AsIpv4(table_entry->rip2IfConfAddress);
        return -1;
    }

    table_entry->rip2IfConfStatus = 1;
    table_entry->rip2IfConfSrcAddress = table_entry->rip2IfConfAddress;

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of rip2IfConfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2IfConfTableEntry_set(rip2IfConfTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // variable declaration
    vtss_ifindex_t ifindex;
    vtss_appl_rip_intf_conf_t conf = {};
    mesa_rc rc = VTSS_RC_OK;

    /* Get original interface config */
    rc = vtss_appl_rip_intf_conf_snmp_get(false, &table_entry->rip2IfConfAddress, NULL, &conf);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get interface "
                          << vtss::AsIpv4(table_entry->rip2IfConfAddress)
                          << " failed";
        return -1;
    }


    /* get the ifindex */
    mesa_ip_addr_t if_addr;
    vtss_appl_ip_if_status_t if_status = {};
    if_addr.type = MESA_IP_TYPE_IPV4;
    if_addr.addr.ipv4 = (mesa_ipv4_t)table_entry->rip2IfConfAddress;

    if (vtss_appl_ip_if_status_find(&if_addr, &if_status) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get intf status from addr " << vtss::AsIpv4(table_entry->rip2IfConfAddress) << " failed";
        return -1;
    }

    if (!vtss_ifindex_is_vlan(if_status.ifindex)) {
        VTSS_TRACE(DEBUG) << "ifindex (" << if_status.ifindex << ") is not a VLAN";
        return -1;
    }

    ifindex = if_status.ifindex;

    /* rip2IfConfAuthType
     * {1 noAuthentication} {2 simplePassword} {3 md5}
     */
    if (table_entry->rip2IfConfAuthType == 1) {
        conf.auth_type = VTSS_APPL_RIP_AUTH_TYPE_NULL;
    } else if (table_entry->rip2IfConfAuthType == 2) {
        conf.auth_type = VTSS_APPL_RIP_AUTH_TYPE_SIMPLE_PASSWORD;
    } else if (table_entry->rip2IfConfAuthType == 3) {
        conf.auth_type = VTSS_APPL_RIP_AUTH_TYPE_MD5;
    }

    /* rip2IfConfReceive
     * rip1 (1), rip2 (2), rip1OrRip2 (3), doNotRecieve (4)
     */
    if (table_entry->rip2IfConfReceive == 1) { // rip1 (1)
        conf.recv_ver = VTSS_APPL_RIP_INTF_RECV_VER_1;
    } else if (table_entry->rip2IfConfReceive == 2) { // rip2 (2),
        conf.recv_ver = VTSS_APPL_RIP_INTF_RECV_VER_2;
    } else if (table_entry->rip2IfConfReceive == 3) { // rip1OrRip2
        conf.recv_ver = VTSS_APPL_RIP_INTF_RECV_VER_BOTH;
    } else { // doNotRecieve (4)
        conf.recv_ver = VTSS_APPL_RIP_INTF_RECV_VER_NONE;
    }

    /* Apply the new configuration */
    rc = vtss_appl_rip_intf_conf_set(ifindex, &conf);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "set interface " << ifindex << " config failed";
        return -1;
    }
    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of rip2PeerTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2PeerTableEntry_getfirst(rip2PeerTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    table_entry->rip2PeerAddress = 0;
    VTSS_TRACE(DEBUG) << "exit";
    return rip2PeerTableEntry_get(table_entry, TRUE);
}

/**
  * \brief Get/Getnext table entry of rip2PeerTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int rip2PeerTableEntry_get(rip2PeerTable_entry_t *table_entry, int getnext)
{
    mesa_ipv4_t key = {};
    vtss_appl_rip_peer_data_t entry = {};
    mesa_rc rc;
    VTSS_TRACE(DEBUG) << __func__ << " enter getnext:" << getnext;
    VTSS_TRACE(DEBUG) << " key:" << vtss::AsIpv4(table_entry->rip2PeerAddress);

    key = table_entry->rip2PeerAddress;
    /* MIB uses peer IP address as key */
    if (getnext) {
        /* 2. get next case - try to find the next valid key by the given IP address */
        mesa_ipv4_t key_1 = {};
        rc = vtss_appl_rip_peer_itr(&key, &key_1);

        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG)
                    << "get next peer from addr " << vtss::AsIpv4(key) << " failed";
            return -1;
        }
        key = key_1;
    }

    rc = vtss_appl_rip_peer_get(key, &entry);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG)
                << "get peer " << vtss::AsIpv4(key) << " failed";
        return -1;
    }
    /* 4. fill in the key */
    table_entry->rip2PeerAddress = key;

    /* 4. fill in the data */
    table_entry->rip2PeerRcvBadPackets = entry.recv_bad_packets;
    table_entry->rip2PeerRcvBadRoutes = entry.recv_bad_routes;
    table_entry->rip2PeerVersion = entry.rip_version;

    /* rip2PeerLastUpdate - The value of sysUpTime when the
       most recent RIP update was received from this system. */
    /* Refer to RFC1213 sysUpTime implementation */
    struct timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    if (now.tv_sec < entry.last_update_time) {
        // Quiet Coverity check : the case should never happen
        VTSS_TRACE(DEBUG) << "exit";
        return -1;
    }

    /* The syntax is TIMETICK (in hundredths of a second) */
    table_entry->rip2PeerLastUpdate = (now.tv_sec - entry.last_update_time) * 100
    + now.tv_nsec / 10000000;

    /* rip2PeerDomain - The value in the Routing Domain field  in  RIP
     * packets received from the peer.  As domain suuport
     * is deprecated, this must be zero.
     * The syntax of rip2PeerDomain is RouteTag(Octect String) (SIZE(2))
     */
    table_entry->rip2PeerDomain[0] = table_entry->rip2PeerDomain[1] = 0; //Deprecated
    table_entry->rip2PeerDomain_len = 2; //Deprecated

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}


