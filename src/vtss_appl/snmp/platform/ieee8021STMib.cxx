/*

 Copyright (c) 2006-2021 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <main.h>

#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "ieee8021STMib.h"
#include "ucd_snmp_ieee8021STMib.h"
#include "mibContextTable.h" // mibContextTable_register()
#include "snmp_mib_redefine.h"  // snmp_mib_redefine_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>

#include "vtss/appl/tsn.h"
// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP
#define IEEE8021BRIDGECOMPONENTID       1
#define IEEE8021BRIDGECOMPONENT_CNT     1
#define SNMP_TRUE                       1
#define SNMP_FALSE                      2


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-ST-MIB:ieee8021STMib.
  **/
void ieee8021STMib_init(void)
{
    T_D("enter");
    ucd_snmp_init_ieee8021STMib();

    /* Register mibContextTable */
    oid ieee8021STMib_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30 };
    mibContextTable_register(ieee8021STMib_variables_oid,
                             sizeof(ieee8021STMib_variables_oid) / sizeof(oid),
                             "IEEE8021-ST-MIB : ieee8021STMib");

    /* Register snmpMibRedefineTable */


    // ieee8021STMaxSDU
    oid ieee8021STMaxSDU_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 1, 1, 1, 2 };
    snmp_mib_redefine_register(ieee8021STMaxSDU_variables_oid,
                               sizeof(ieee8021STMaxSDU_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STMaxSDU",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021TransmissionOverrun
    oid ieee8021TransmissionOverrun_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 1, 1, 1, 3 };
    snmp_mib_redefine_register(ieee8021TransmissionOverrun_variables_oid,
                               sizeof(ieee8021TransmissionOverrun_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021TransmissionOverrun",
                               "COUNTER64",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STGateEnabled
    oid ieee8021STGateEnabled_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 1 };
    snmp_mib_redefine_register(ieee8021STGateEnabled_variables_oid,
                               sizeof(ieee8021STGateEnabled_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STGateEnabled",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "\
{1 true} \
{2 false} \
");

    // ieee8021STAdminGateStates
    oid ieee8021STAdminGateStates_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 2 };
    snmp_mib_redefine_register(ieee8021STAdminGateStates_variables_oid,
                               sizeof(ieee8021STAdminGateStates_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminGateStates",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "{1 1}");

    // ieee8021STOperGateStates
    oid ieee8021STOperGateStates_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 3 };
    snmp_mib_redefine_register(ieee8021STOperGateStates_variables_oid,
                               sizeof(ieee8021STOperGateStates_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperGateStates",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "{1 1}");

    // ieee8021STAdminControlListLength
    oid ieee8021STAdminControlListLength_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 4 };
    snmp_mib_redefine_register(ieee8021STAdminControlListLength_variables_oid,
                               sizeof(ieee8021STAdminControlListLength_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminControlListLength",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021STOperControlListLength
    oid ieee8021STOperControlListLength_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 5 };
    snmp_mib_redefine_register(ieee8021STOperControlListLength_variables_oid,
                               sizeof(ieee8021STOperControlListLength_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperControlListLength",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STAdminControlList
    oid ieee8021STAdminControlList_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 6 };
    snmp_mib_redefine_register(ieee8021STAdminControlList_variables_oid,
                               sizeof(ieee8021STAdminControlList_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminControlList",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021STOperControlList
    oid ieee8021STOperControlList_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 7 };
    snmp_mib_redefine_register(ieee8021STOperControlList_variables_oid,
                               sizeof(ieee8021STOperControlList_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperControlList",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STAdminCycleTimeNumerator
    oid ieee8021STAdminCycleTimeNumerator_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 8 };
    snmp_mib_redefine_register(ieee8021STAdminCycleTimeNumerator_variables_oid,
                               sizeof(ieee8021STAdminCycleTimeNumerator_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminCycleTimeNumerator",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021STAdminCycleTimeDenominator
    oid ieee8021STAdminCycleTimeDenominator_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 9 };
    snmp_mib_redefine_register(ieee8021STAdminCycleTimeDenominator_variables_oid,
                               sizeof(ieee8021STAdminCycleTimeDenominator_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminCycleTimeDenominator",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021STOperCycleTimeNumerator
    oid ieee8021STOperCycleTimeNumerator_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 10 };
    snmp_mib_redefine_register(ieee8021STOperCycleTimeNumerator_variables_oid,
                               sizeof(ieee8021STOperCycleTimeNumerator_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperCycleTimeNumerator",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STOperCycleTimeDenominator
    oid ieee8021STOperCycleTimeDenominator_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 11 };
    snmp_mib_redefine_register(ieee8021STOperCycleTimeDenominator_variables_oid,
                               sizeof(ieee8021STOperCycleTimeDenominator_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperCycleTimeDenominator",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STAdminCycleTimeExtension
    oid ieee8021STAdminCycleTimeExtension_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 12 };
    snmp_mib_redefine_register(ieee8021STAdminCycleTimeExtension_variables_oid,
                               sizeof(ieee8021STAdminCycleTimeExtension_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminCycleTimeExtension",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "");

    // ieee8021STOperCycleTimeExtension
    oid ieee8021STOperCycleTimeExtension_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 13 };
    snmp_mib_redefine_register(ieee8021STOperCycleTimeExtension_variables_oid,
                               sizeof(ieee8021STOperCycleTimeExtension_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperCycleTimeExtension",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STAdminBaseTime
    oid ieee8021STAdminBaseTime_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 14 };
    snmp_mib_redefine_register(ieee8021STAdminBaseTime_variables_oid,
                               sizeof(ieee8021STAdminBaseTime_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STAdminBaseTime",
                               "IEEE8021STPTPtimeValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "{10 10}");

    // ieee8021STOperBaseTime
    oid ieee8021STOperBaseTime_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 15 };
    snmp_mib_redefine_register(ieee8021STOperBaseTime_variables_oid,
                               sizeof(ieee8021STOperBaseTime_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STOperBaseTime",
                               "IEEE8021STPTPtimeValue",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "{10 10}");

    // ieee8021STConfigChange
    oid ieee8021STConfigChange_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 16 };
    snmp_mib_redefine_register(ieee8021STConfigChange_variables_oid,
                               sizeof(ieee8021STConfigChange_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STConfigChange",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               FALSE,
                               "\
{1 true} \
{2 false} \
");

    // ieee8021STConfigChangeTime
    oid ieee8021STConfigChangeTime_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 17 };
    snmp_mib_redefine_register(ieee8021STConfigChangeTime_variables_oid,
                               sizeof(ieee8021STConfigChangeTime_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STConfigChangeTime",
                               "IEEE8021STPTPtimeValue",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "{10 10}");

    // ieee8021STTickGranularity
    oid ieee8021STTickGranularity_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 18 };
    snmp_mib_redefine_register(ieee8021STTickGranularity_variables_oid,
                               sizeof(ieee8021STTickGranularity_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STTickGranularity",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STCurrentTime
    oid ieee8021STCurrentTime_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 19 };
    snmp_mib_redefine_register(ieee8021STCurrentTime_variables_oid,
                               sizeof(ieee8021STCurrentTime_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STCurrentTime",
                               "IEEE8021STPTPtimeValue",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "{10 10}");

    // ieee8021STConfigPending
    oid ieee8021STConfigPending_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 20 };
    snmp_mib_redefine_register(ieee8021STConfigPending_variables_oid,
                               sizeof(ieee8021STConfigPending_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STConfigPending",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "\
{1 true} \
{2 false} \
");

    // ieee8021STConfigChangeError
    oid ieee8021STConfigChangeError_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 21 };
    snmp_mib_redefine_register(ieee8021STConfigChangeError_variables_oid,
                               sizeof(ieee8021STConfigChangeError_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STConfigChangeError",
                               "COUNTER64",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    // ieee8021STSupportedListMax
    oid ieee8021STSupportedListMax_variables_oid[] = { 1, 3, 111, 2, 802, 1, 1, 30, 1, 2, 1, 1, 22 };
    snmp_mib_redefine_register(ieee8021STSupportedListMax_variables_oid,
                               sizeof(ieee8021STSupportedListMax_variables_oid) / sizeof(oid),
                               "IEEE8021-ST-MIB : ieee8021STSupportedListMax",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                               "");

    T_D("exit");
}


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/
static BOOL IEEE8021_STMaxSDU_TableEntry_get(ieee8021STMaxSDUTable_entry_t *table_entry, int getnext)
{
    vtss_appl_tsn_tas_max_sdu_t max_sdu;
    vtss_ifindex_t              ifindex;
    mesa_prio_t                 queue;
    vtss_ifindex_t              next_ifindex;
    mesa_prio_t                 next_queue;
    mesa_rc                     rc;
    vtss_ifindex_elm_t          ife;

    if (table_entry->ieee8021BridgeBasePort == 0) {
        // get the first table entry index
        rc = vtss_appl_tsn_tas_per_q_max_sdu_itr(NULL, &ifindex, NULL, &queue);
    } else {
        if ((rc = vtss_ifindex_from_usid_uport(VTSS_USID_START, table_entry->ieee8021BridgeBasePort, &ifindex)) != VTSS_RC_OK) {
            T_W("Cannot get the interface index for port %ld: %s\n", table_entry->ieee8021BridgeBasePort, error_txt(rc));
            return FALSE;
        }
    }
    queue = table_entry->ieee8021STTrafficClass;

    if (getnext) {
        // get the next table entry index
        if ((rc = vtss_appl_tsn_tas_per_q_max_sdu_itr(&ifindex, &next_ifindex, &queue, &next_queue)) != VTSS_RC_OK) {
            return FALSE;
        }
        ifindex = next_ifindex;
        queue = next_queue;
    }
    if ((rc = vtss_appl_tsn_tas_per_q_max_sdu_get(ifindex, queue, &max_sdu)) != VTSS_RC_OK) {
        T_W("Cannot get the ieee8021STMaxSDU parameter: %s\n", error_txt(rc));
        return FALSE;
    }
    VTSS_RC(vtss_ifindex_decompose(ifindex, &ife));
    table_entry->ieee8021BridgeBaseComponentId      = IEEE8021BRIDGECOMPONENTID;
    table_entry->ieee8021BridgeBasePort             = ife.ordinal + 1;
    table_entry->ieee8021STTrafficClass             = queue;
    table_entry->ieee8021STMaxSDU                   = max_sdu.max_sdu;
    vtss_snmp_u64_to_counter64(&table_entry->ieee8021TransmissionOverrun, 0);

    return TRUE;
}

static BOOL IEEE8021_STParameters_TableEntry_get(ieee8021STParametersTable_entry_t *table_entry, int getnext)
{
    vtss_ifindex_t                 ifindex;
    vtss_ifindex_t                 next_ifindex;
    vtss_appl_tsn_tas_cfg_t        cfg;
    vtss_gcl_index_t               gcl_index;
    vtss_gcl_index_t               next_gcl_index;
    vtss_appl_tsn_tas_gcl_t        gcl;
    vtss_appl_tsn_tas_oper_state_t status;
    mesa_rc                        rc;
    vtss_ifindex_elm_t             ife;


    if (table_entry->ieee8021BridgeBasePort == 1) {
        // get the first table entry index
        vtss_appl_tsn_tas_cfg_itr(NULL, &ifindex);
    } else {
        if ((rc = vtss_ifindex_from_usid_uport(VTSS_USID_START, table_entry->ieee8021BridgeBasePort, &ifindex)) != VTSS_RC_OK) {
            T_W("Cannot get the interface index : %s\n", error_txt(rc));
            return FALSE;
        }
    }

    if (getnext) {
        // get the next table entry index
        if ((rc = vtss_appl_tsn_tas_cfg_itr(&ifindex, &next_ifindex)) != VTSS_RC_OK) {
            return FALSE;
        }
        ifindex = next_ifindex;
    }

    if ((rc = vtss_appl_tsn_tas_cfg_get(ifindex, &cfg)) != VTSS_RC_OK) {
        T_W("Cannot get the TAS configuration parameters: %s\n", error_txt(rc));
        return FALSE;
    }

    if ((rc = vtss_appl_tsn_tas_status_get(ifindex, &status)) != VTSS_RC_OK) {
        T_W("Cannot get the TAS Status parameters: %s\n", error_txt(rc));
        return FALSE;
    }

    VTSS_RC(vtss_ifindex_decompose(ifindex, &ife));
    table_entry->ieee8021BridgeBasePort = ife.ordinal + 1;
    table_entry->ieee8021STGateEnabled = cfg.gate_enabled ? SNMP_TRUE : SNMP_FALSE;
    table_entry->ieee8021STAdminGateStates[0] = cfg.admin_gate_states;
    table_entry->ieee8021STAdminGateStates_len = 1;
    table_entry->ieee8021STOperGateStates[0] = status.oper_gate_states;
    table_entry->ieee8021STOperGateStates_len = 1;
    table_entry->ieee8021STAdminControlListLength = cfg.admin_control_list_length;
    table_entry->ieee8021STOperControlListLength = status.oper_control_list_length;

    /* \The ieee8021STAdminControlList is administrative value of the ControlList parameter for the Port.
       The octet string value represents the contents of the control list as
       an ordered list of entries, each encoded as a TLV, as follows.
       The first octet of each TLV is interpreted as an
       unsigned integer representing a gate operation name:
       0: SetGateStates
       1-255: Reserved for future gate operations
       The second octet of the TLV is the length field,
       interpreted as an unsigned integer, indicating the number of
       octets of the value that follows the length. A length of
       zero indicates that there is no value
       (i.e., the gate operation has no parameters).
    */
    int length_tlv = ST_SET_GATE_STATES_TLV_LENGTH + 2; // per TLV length in octets is the length of the value field plus the first two octet fields
    int length_total = 0; // total TLV length in octets, used for counting
    gcl_index = 0;
    for (int i = 0; i < table_entry->ieee8021STAdminControlListLength; i++) {
        if (i == 0) {
            // Get the first gce under this interface
            if (vtss_appl_tsn_tas_gcl_admin_itr(&ifindex, &next_ifindex, NULL, &next_gcl_index) != VTSS_RC_OK) {
                break;
            }
        } else {
            // Get the next gce under this interface
            if (vtss_appl_tsn_tas_gcl_admin_itr(&ifindex, &next_ifindex, &gcl_index, &next_gcl_index) != VTSS_RC_OK) {
                break;
            }
        }
        if (ifindex != next_ifindex) {
            // Reached the end of gce list under this interface.
            break;
        }
        if ((rc = vtss_appl_tsn_tas_gcl_admin_get(ifindex, next_gcl_index, &gcl)) != VTSS_RC_OK) {
            T_W("Cannot get the per TLV setting : %s\n", error_txt(rc));
            break;
        }
        gcl_index = next_gcl_index;

        table_entry->ieee8021STAdminControlList[i * length_tlv] = ST_CONTROL_SET_GATE_STATES; // TLV type setGateStates
        table_entry->ieee8021STAdminControlList[i * length_tlv + 1] = ST_SET_GATE_STATES_TLV_LENGTH; // TLV length in octets
        table_entry->ieee8021STAdminControlList[i * length_tlv + 2] = gcl.gate_state;

        if ((i * length_tlv + 7) < (sizeof(table_entry->ieee8021STAdminControlList) - 1)) {
            table_entry->ieee8021STAdminControlList[i * length_tlv + 3] =  (gcl.time_interval >> 24) & 0xff;
            table_entry->ieee8021STAdminControlList[i * length_tlv + 4] =  (gcl.time_interval >> 16) & 0xff;
            table_entry->ieee8021STAdminControlList[i * length_tlv + 5] =  (gcl.time_interval >> 8) & 0xff;
            table_entry->ieee8021STAdminControlList[i * length_tlv + 6] =   gcl.time_interval & 0xff;

            length_total += length_tlv;
        } else {
            break;
        }
    }
    table_entry->ieee8021STAdminControlList_len = length_total;

    length_total = 0;
    gcl_index = 0;
    for (int i = 0; i < table_entry->ieee8021STOperControlListLength; i++) {
        if (i == 0) {
            // Get the first gce under this interface
            if (vtss_appl_tsn_tas_gcl_oper_itr(&ifindex, &next_ifindex, NULL, &next_gcl_index) != VTSS_RC_OK) {
                break;
            }
        } else {
            // Get the next gce under this interface
            if (vtss_appl_tsn_tas_gcl_oper_itr(&ifindex, &next_ifindex, &gcl_index, &next_gcl_index) != VTSS_RC_OK) {
                break;
            }
        }
        if (ifindex != next_ifindex) {
            // Reached the end of gce list under this interface.
            break;
        }
        if ((rc = vtss_appl_tsn_tas_gcl_oper_get(ifindex, next_gcl_index, &gcl)) != VTSS_RC_OK) {
            T_W("Cannot get the per TLV setting : %s\n", error_txt(rc));
            break;
        }
        gcl_index = next_gcl_index;
        table_entry->ieee8021STOperControlList[i * length_tlv]      = ST_CONTROL_SET_GATE_STATES; // TLV type setGateStates
        table_entry->ieee8021STOperControlList[i * length_tlv + 1]  = ST_SET_GATE_STATES_TLV_LENGTH; // TLV length in octets
        table_entry->ieee8021STOperControlList[i * length_tlv + 2]  = gcl.gate_state;

        if ((i * length_tlv + 7) < (sizeof(table_entry->ieee8021STAdminControlList) - 1)) {
            table_entry->ieee8021STOperControlList[i * length_tlv + 3] =  (gcl.time_interval >> 24) & 0xff;
            table_entry->ieee8021STOperControlList[i * length_tlv + 4] =  (gcl.time_interval >> 16) & 0xff;;
            table_entry->ieee8021STOperControlList[i * length_tlv + 5] =  (gcl.time_interval >> 8) & 0xff;;
            table_entry->ieee8021STOperControlList[i * length_tlv + 6] =  gcl.time_interval & 0xff;;
            length_total += length_tlv;
        } else {
            break;
        }
    }
    table_entry->ieee8021STOperControlList_len          = length_total;

    table_entry->ieee8021STAdminCycleTimeNumerator      = cfg.admin_cycle_time_numerator;
    table_entry->ieee8021STAdminCycleTimeDenominator    = cfg.admin_cycle_time_denominator;
    table_entry->ieee8021STOperCycleTimeNumerator       = status.oper_cycle_time_numerator;
    table_entry->ieee8021STOperCycleTimeDenominator     = status.oper_cycle_time_denominator;
    table_entry->ieee8021STAdminCycleTimeExtension      = cfg.admin_cycle_time_extension;
    table_entry->ieee8021STOperCycleTimeExtension       = status.oper_cycle_time_extension;

    table_entry->ieee8021STAdminBaseTime[0]     = (cfg.admin_base_time.sec_msb >> 8)  & 0xff;
    table_entry->ieee8021STAdminBaseTime[1]     =  cfg.admin_base_time.sec_msb  & 0xff;
    table_entry->ieee8021STAdminBaseTime[2]     = (cfg.admin_base_time.seconds >> 24) & 0xff;
    table_entry->ieee8021STAdminBaseTime[3]     = (cfg.admin_base_time.seconds >> 16) & 0xff;
    table_entry->ieee8021STAdminBaseTime[4]     = (cfg.admin_base_time.seconds >> 8) & 0xff;
    table_entry->ieee8021STAdminBaseTime[5]     =  cfg.admin_base_time.seconds & 0xff;
    table_entry->ieee8021STAdminBaseTime[6]     = (cfg.admin_base_time.nanoseconds >> 24) & 0xff;
    table_entry->ieee8021STAdminBaseTime[7]     = (cfg.admin_base_time.nanoseconds >> 16) & 0xff;
    table_entry->ieee8021STAdminBaseTime[8]     = (cfg.admin_base_time.nanoseconds >> 8) & 0xff;
    table_entry->ieee8021STAdminBaseTime[9]     =  cfg.admin_base_time.nanoseconds & 0xff;
    table_entry->ieee8021STAdminBaseTime_len    = 10;

    table_entry->ieee8021STOperBaseTime[0]      = (status.oper_base_time.sec_msb >> 8)  & 0xff;
    table_entry->ieee8021STOperBaseTime[1]      =  status.oper_base_time.sec_msb  & 0xff;
    table_entry->ieee8021STOperBaseTime[2]      = (status.oper_base_time.seconds >> 24) & 0xff;
    table_entry->ieee8021STOperBaseTime[3]      = (status.oper_base_time.seconds >> 16) & 0xff;
    table_entry->ieee8021STOperBaseTime[4]      = (status.oper_base_time.seconds >> 8) & 0xff;
    table_entry->ieee8021STOperBaseTime[5]      =  status.oper_base_time.seconds & 0xff;
    table_entry->ieee8021STOperBaseTime[6]      = (status.oper_base_time.nanoseconds >> 24) & 0xff;
    table_entry->ieee8021STOperBaseTime[7]      = (status.oper_base_time.nanoseconds >> 16) & 0xff;
    table_entry->ieee8021STOperBaseTime[8]      = (status.oper_base_time.nanoseconds >> 8) & 0xff;
    table_entry->ieee8021STOperBaseTime[9]      =  status.oper_base_time.nanoseconds & 0xff;
    table_entry->ieee8021STOperBaseTime_len     = 10;

    table_entry->ieee8021STConfigChange         = cfg.config_change ? SNMP_TRUE : SNMP_FALSE;  // Convert to SNMP Truth value

    table_entry->ieee8021STConfigChangeTime[0]  = (status.config_change_time.sec_msb >> 8)  & 0xff;
    table_entry->ieee8021STConfigChangeTime[1]  =  status.config_change_time.sec_msb  & 0xff;
    table_entry->ieee8021STConfigChangeTime[2]  = (status.config_change_time.seconds >> 24) & 0xff;
    table_entry->ieee8021STConfigChangeTime[3]  = (status.config_change_time.seconds >> 16) & 0xff;
    table_entry->ieee8021STConfigChangeTime[4]  = (status.config_change_time.seconds >> 8) & 0xff;
    table_entry->ieee8021STConfigChangeTime[5]  =  status.config_change_time.seconds & 0xff;
    table_entry->ieee8021STConfigChangeTime[6]  = (status.config_change_time.nanoseconds >> 24) & 0xff;
    table_entry->ieee8021STConfigChangeTime[7]  = (status.config_change_time.nanoseconds >> 16) & 0xff;
    table_entry->ieee8021STConfigChangeTime[8]  = (status.config_change_time.nanoseconds >> 8) & 0xff;
    table_entry->ieee8021STConfigChangeTime[9]  =  status.config_change_time.nanoseconds & 0xff;
    table_entry->ieee8021STConfigChangeTime_len = 10;

    table_entry->ieee8021STTickGranularity      = status.tick_granularity;

    table_entry->ieee8021STCurrentTime[0]       = (status.current_time.sec_msb >> 8)  & 0xff;
    table_entry->ieee8021STCurrentTime[1]       =  status.current_time.sec_msb & 0xff;
    table_entry->ieee8021STCurrentTime[2]       = (status.current_time.seconds >> 24) & 0xff;
    table_entry->ieee8021STCurrentTime[3]       = (status.current_time.seconds >> 16) & 0xff;
    table_entry->ieee8021STCurrentTime[4]       = (status.current_time.seconds >> 8) & 0xff;
    table_entry->ieee8021STCurrentTime[5]       =  status.current_time.seconds & 0xff;
    table_entry->ieee8021STCurrentTime[6]       = (status.current_time.nanoseconds >> 24) & 0xff;
    table_entry->ieee8021STCurrentTime[7]       = (status.current_time.nanoseconds >> 16) & 0xff;
    table_entry->ieee8021STCurrentTime[8]       = (status.current_time.nanoseconds >> 8) & 0xff;
    table_entry->ieee8021STCurrentTime[9]       =  status.current_time.nanoseconds & 0xff;
    table_entry->ieee8021STCurrentTime_len      = 10;

    table_entry->ieee8021STConfigPending        = status.config_pending ? SNMP_TRUE : SNMP_FALSE;  // Convert to SNMP Truth value
    vtss_snmp_u64_to_counter64(&table_entry->ieee8021STConfigChangeError, status.config_change_error);
    table_entry->ieee8021STSupportedListMax     = status.supported_list_max;

    return TRUE;
}

/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021STMaxSDUTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STMaxSDUTableEntry_getfirst(ieee8021STMaxSDUTable_entry_t *table_entry)
{
    ieee8021STMaxSDUTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));

    T_D("enter");
    buf.ieee8021BridgeBaseComponentId   = IEEE8021BRIDGECOMPONENTID;
    buf.ieee8021BridgeBasePort          = 1;
    buf.ieee8021STTrafficClass          = 0;
    if (!IEEE8021_STMaxSDU_TableEntry_get(&buf, 0)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(ieee8021STMaxSDUTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021STMaxSDUTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STMaxSDUTableEntry_get(ieee8021STMaxSDUTable_entry_t *table_entry, int getnext)
{
    ieee8021STMaxSDUTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if ((table_entry->ieee8021BridgeBaseComponentId == 0 || table_entry->ieee8021BridgeBaseComponentId > IEEE8021BRIDGECOMPONENTID)) {
        return -1;
    }

    buf.ieee8021BridgeBaseComponentId   = table_entry->ieee8021BridgeBaseComponentId;
    buf.ieee8021BridgeBasePort          = table_entry->ieee8021BridgeBasePort;
    buf.ieee8021STTrafficClass          = table_entry->ieee8021STTrafficClass;

    if (!IEEE8021_STMaxSDU_TableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(ieee8021STMaxSDUTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021STMaxSDUTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STMaxSDUTableEntry_set(ieee8021STMaxSDUTable_entry_t *table_entry)
{
    vtss_appl_tsn_tas_max_sdu_t max_sdu;
    vtss_ifindex_t              ifindex;
    mesa_prio_t                 queue;
    mesa_rc                     rc;

    T_D("enter");

    if ((rc = vtss_ifindex_from_usid_uport(VTSS_USID_START, table_entry->ieee8021BridgeBasePort, &ifindex)) != VTSS_RC_OK) {
        T_W("Cannot get the interface index : %s baseport %u\n", error_txt(rc), table_entry->ieee8021BridgeBasePort);
        return -1;
    }

    queue = table_entry->ieee8021STTrafficClass;

    if ((rc = vtss_appl_tsn_tas_per_q_max_sdu_get(ifindex, queue, &max_sdu)) != VTSS_RC_OK) {
        T_W("Cannot get the ieee8021STMaxSDU parameter: %s\n", error_txt(rc));
        return -1;
    }

    max_sdu.max_sdu = table_entry->ieee8021STMaxSDU;

    if ( VTSS_RC_OK != vtss_appl_tsn_tas_per_q_max_sdu_set(ifindex, queue, &max_sdu) ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021STParametersTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STParametersTableEntry_getfirst(ieee8021STParametersTable_entry_t *table_entry)
{
    ieee8021STParametersTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));

    T_D("enter");
    buf.ieee8021BridgeBaseComponentId = IEEE8021BRIDGECOMPONENTID;
    buf.ieee8021BridgeBasePort        = 1;

    if (!IEEE8021_STParameters_TableEntry_get(&buf, 0)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(ieee8021STParametersTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021STParametersTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STParametersTableEntry_get(ieee8021STParametersTable_entry_t *table_entry, int getnext)
{
    ieee8021STParametersTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));

    T_D("enter");

    buf.ieee8021BridgeBaseComponentId = table_entry->ieee8021BridgeBaseComponentId;
    buf.ieee8021BridgeBasePort = table_entry->ieee8021BridgeBasePort;

    if (!IEEE8021_STParameters_TableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(ieee8021STParametersTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021STParametersTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ieee8021STParametersTableEntry_set(ieee8021STParametersTable_entry_t *table_entry)
{
    vtss_ifindex_t                 ifindex;
    vtss_appl_tsn_tas_cfg_t        cfg;
    vtss_gcl_index_t               gcl_index = 0;
    vtss_appl_tsn_tas_gcl_t        gcl;
    mesa_rc                        rc;

    T_D("enter");
    if ((rc = vtss_ifindex_from_usid_uport(VTSS_USID_START, table_entry->ieee8021BridgeBasePort, &ifindex)) != VTSS_RC_OK) {
        T_W("Cannot get the interface index : %s\n", error_txt(rc));
        return -1;
    }

    if ((rc = vtss_appl_tsn_tas_cfg_get(ifindex, &cfg)) != VTSS_RC_OK) {
        T_W("Cannot get the TAS configuration parameters: %s\n", error_txt(rc));
        return -1;
    }

    cfg.gate_enabled = table_entry->ieee8021STGateEnabled == SNMP_TRUE ? true : false; // Convert SNMP BOOL to mesa_bool
    cfg.admin_gate_states = table_entry->ieee8021STAdminGateStates[0];
    cfg.admin_control_list_length = table_entry->ieee8021STAdminControlListLength;

    int index = 0, length_tlv = 0, type_tlv = 0;
    for (int i = 0; i < table_entry->ieee8021STAdminControlListLength; i++) {
        //read each TLV type and length value
        type_tlv = table_entry->ieee8021STAdminControlList[index];
        length_tlv = table_entry->ieee8021STAdminControlList[index + 1];

        if ((type_tlv != 0) | (length_tlv != 5)) {
            // if the tlv type is not SetGateStates, ignore
            index += length_tlv + 2;
            continue;
        }
        if ((rc = vtss_appl_tsn_tas_gcl_admin_get(ifindex, gcl_index, &gcl)) != VTSS_RC_OK) {
            T_W("Cannot get the per TLV setting : %s\n", error_txt(rc));
            break;
        }
        gcl.gate_state = table_entry->ieee8021STAdminControlList[index + 2];
        if ((index + 7) < (sizeof(table_entry->ieee8021STAdminControlList) - 1)) {
            gcl.time_interval = ((table_entry->ieee8021STAdminControlList[index + 3] & 0xff ) << 24) |
                                ((table_entry->ieee8021STAdminControlList[index + 4] & 0xff ) << 16) |
                                ((table_entry->ieee8021STAdminControlList[index + 5] & 0xff ) << 8 ) |
                                (table_entry->ieee8021STAdminControlList[index + 6] & 0xff );
        } else {
            break;
        }

        if ((rc = vtss_appl_tsn_tas_gcl_admin_set(ifindex, gcl_index, &gcl)) != VTSS_RC_OK) {
            T_W("Cannot set the per TLV setting : %s\n", error_txt(rc));
            break;
        }
        index += length_tlv + 2;

        gcl_index ++;
    }

    cfg.admin_cycle_time_numerator  = table_entry->ieee8021STAdminCycleTimeNumerator;
    cfg.admin_cycle_time_denominator = table_entry->ieee8021STAdminCycleTimeDenominator;
    cfg.admin_cycle_time_extension  = table_entry->ieee8021STAdminCycleTimeExtension;

    cfg.admin_base_time.sec_msb     = ((table_entry->ieee8021STAdminBaseTime[0] & 0xff ) << 8) |
                                      (table_entry->ieee8021STAdminBaseTime[1] & 0xff);

    cfg.admin_base_time.seconds     = ((table_entry->ieee8021STAdminBaseTime[2] & 0xff ) << 24) |
                                      ((table_entry->ieee8021STAdminBaseTime[3] & 0xff ) << 16) |
                                      ((table_entry->ieee8021STAdminBaseTime[4] & 0xff ) << 8 ) |
                                      (table_entry->ieee8021STAdminBaseTime[5] & 0xff );

    cfg.admin_base_time.nanoseconds = ((table_entry->ieee8021STAdminBaseTime[6] & 0xff ) << 24) |
                                      ((table_entry->ieee8021STAdminBaseTime[7] & 0xff ) << 16) |
                                      ((table_entry->ieee8021STAdminBaseTime[8] & 0xff ) << 8)  |
                                      (table_entry->ieee8021STAdminBaseTime[9] & 0xff );

    cfg.config_change = table_entry->ieee8021STConfigChange == SNMP_TRUE ? true : false;  // Convert SNMP BOOL to mesa_bool

    if ((rc = vtss_appl_tsn_tas_cfg_set(ifindex, &cfg)) != VTSS_RC_OK) {
        T_W("Cannot get the TAS configuration parameters: %s\n", error_txt(rc));
        return -1;
    }

    T_D("exit");
    return 0;
}


