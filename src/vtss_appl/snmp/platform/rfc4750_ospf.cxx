/*

 Copyright (c) 2006-2021 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "rfc4750_ospf.h"
#include "ucd_snmp_ospf.h"
#include "mibContextTable.h" // mibContextTable_register()
// FIXME: Remove the include file if your implementation don't need to redefine the standard standard MIB objects
#include "snmp_mib_redefine.h"  // snmp_mib_redefine_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>

#include "frr_ospf_api.hxx"
#include "ip_utils.hxx"

/****************************************************************************/
/** Module default trace group declaration                                  */
/****************************************************************************/
#define VTSS_TRACE_DEFAULT_GROUP FRR_TRACE_GRP_SNMP
#include "frr_trace.hxx"  // For module trace group definitions

#define VTSS_OSPF_VERSION           2

#define OSPF_SNMP_TRUE      1
#define OSPF_SNMP_FALSE     2
#define OSPF_SNMP_ADMIN_ENABLE      OSPF_SNMP_TRUE
#define OSPF_SNMP_ADMIN_DISABLE     OSPF_SNMP_FALSE
#define OSPF_SNMP_SUPPORTED         OSPF_SNMP_TRUE
#define OSPF_SNMP_UNSUPPORTED       OSPF_SNMP_FALSE

#define OSPF_SNMP_AUTH_TYPE_NONE 0
#define OSPF_SNMP_AUTH_TYPE_SIMPLE_PASSWD 1
#define OSPF_SNMP_AUTH_TYPE_MD5 2

enum {
    OSPF_SNMP_INTF_STATE_DOWN = 1,
    OSPF_SNMP_INTF_STATE_LOOPBACK,
    OSPF_SNMP_INTF_STATE_WAITING,
    OSPF_SNMP_INTF_STATE_POINT2POINT,
    OSPF_SNMP_INTF_STATE_DR,
    OSPF_SNMP_INTF_STATE_BDR,
    OSPF_SNMP_INTF_STATE_DROTHER
};
/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the OSPF-MIB:ospf.
  **/
void rfc4750_ospf_init(void)
{
    VTSS_TRACE(DEBUG) << "enter";
    ucd_snmp_init_ospf();

    /* Register snmpMibRedefineTable */

    // --- ospfGeneralGroup
    // ospfAreaBdrRtrStatus
    oid ospfAreaBdrRtrStatus_variables_oid[] = { 1,3,6,1,2,1,14, 1,4 };
    snmp_mib_redefine_register(ospfAreaBdrRtrStatus_variables_oid,
                               sizeof(ospfAreaBdrRtrStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaBdrRtrStatus",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfASBdrRtrStatus
    oid ospfASBdrRtrStatus_variables_oid[] = { 1,3,6,1,2,1,14, 1,5 };
    snmp_mib_redefine_register(ospfASBdrRtrStatus_variables_oid,
                               sizeof(ospfASBdrRtrStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfASBdrRtrStatus",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfTOSSupport
    oid ospfTOSSupport_variables_oid[] = { 1,3,6,1,2,1,14, 1,8 };
    snmp_mib_redefine_register(ospfTOSSupport_variables_oid,
                               sizeof(ospfTOSSupport_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfTOSSupport",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfOriginateNewLsas
    oid ospfOriginateNewLsas_variables_oid[] = { 1,3,6,1,2,1,14, 1,9 };
    snmp_mib_redefine_register(ospfOriginateNewLsas_variables_oid,
                               sizeof(ospfOriginateNewLsas_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfOriginateNewLsas",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfRxNewLsas
    oid ospfRxNewLsas_variables_oid[] = { 1,3,6,1,2,1,14, 1,10 };
    snmp_mib_redefine_register(ospfRxNewLsas_variables_oid,
                               sizeof(ospfRxNewLsas_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRxNewLsas",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbLimit
    oid ospfExtLsdbLimit_variables_oid[] = { 1,3,6,1,2,1,14, 1,11 };
    snmp_mib_redefine_register(ospfExtLsdbLimit_variables_oid,
                               sizeof(ospfExtLsdbLimit_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbLimit",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{-1 2147483647}" /* redefine_descr */);

    // ospfMulticastExtensions
    oid ospfMulticastExtensions_variables_oid[] = { 1,3,6,1,2,1,14, 1,12 };
    snmp_mib_redefine_register(ospfMulticastExtensions_variables_oid,
                               sizeof(ospfMulticastExtensions_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfMulticastExtensions",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExitOverflowInterval
    oid ospfExitOverflowInterval_variables_oid[] = { 1,3,6,1,2,1,14, 1,13 };
    snmp_mib_redefine_register(ospfExitOverflowInterval_variables_oid,
                               sizeof(ospfExitOverflowInterval_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExitOverflowInterval",
                               "PositiveInteger",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 2147483647}" /* redefine_descr */);

    // ospfDemandExtensions
    oid ospfDemandExtensions_variables_oid[] = { 1,3,6,1,2,1,14, 1,14 };
    snmp_mib_redefine_register(ospfDemandExtensions_variables_oid,
                               sizeof(ospfDemandExtensions_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfDemandExtensions",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfRFC1583Compatibility
    oid ospfRFC1583Compatibility_variables_oid[] = { 1,3,6,1,2,1,14, 1,15 };
    snmp_mib_redefine_register(ospfRFC1583Compatibility_variables_oid,
                               sizeof(ospfRFC1583Compatibility_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRFC1583Compatibility",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfReferenceBandwidth
    oid ospfReferenceBandwidth_variables_oid[] = { 1,3,6,1,2,1,14, 1,17 };
    snmp_mib_redefine_register(ospfReferenceBandwidth_variables_oid,
                               sizeof(ospfReferenceBandwidth_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfReferenceBandwidth",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfRestartSupport
    oid ospfRestartSupport_variables_oid[] = { 1,3,6,1,2,1,14, 1,18 };
    snmp_mib_redefine_register(ospfRestartSupport_variables_oid,
                               sizeof(ospfRestartSupport_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartSupport",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 none} \
{2 plannedOnly} \
{3 plannedAndUnplanned} \
" /* redefine_descr */);

    // ospfRestartInterval
    oid ospfRestartInterval_variables_oid[] = { 1,3,6,1,2,1,14, 1,19 };
    snmp_mib_redefine_register(ospfRestartInterval_variables_oid,
                               sizeof(ospfRestartInterval_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartInterval",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 1800}" /* redefine_descr */);

    // ospfRestartStrictLsaChecking
    oid ospfRestartStrictLsaChecking_variables_oid[] = { 1,3,6,1,2,1,14, 1,20 };
    snmp_mib_redefine_register(ospfRestartStrictLsaChecking_variables_oid,
                               sizeof(ospfRestartStrictLsaChecking_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartStrictLsaChecking",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);

    // ospfRestartStatus
    oid ospfRestartStatus_variables_oid[] = { 1,3,6,1,2,1,14, 1,21 };
    snmp_mib_redefine_register(ospfRestartStatus_variables_oid,
                               sizeof(ospfRestartStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartStatus",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 notRestarting} \
{2 plannedRestart} \
{3 unplannedRestart} \
" /* redefine_descr */);

    // ospfRestartAge
    oid ospfRestartAge_variables_oid[] = { 1,3,6,1,2,1,14, 1,22 };
    snmp_mib_redefine_register(ospfRestartAge_variables_oid,
                               sizeof(ospfRestartAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartAge",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfRestartExitReason
    oid ospfRestartExitReason_variables_oid[] = { 1,3,6,1,2,1,14, 1,23 };
    snmp_mib_redefine_register(ospfRestartExitReason_variables_oid,
                               sizeof(ospfRestartExitReason_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfRestartExitReason",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 none} \
{2 inProgress} \
{3 completed} \
{4 timedOut} \
{5 topologyChanged} \
" /* redefine_descr */);

    // ospfAsLsaCount
    oid ospfAsLsaCount_variables_oid[] = { 1,3,6,1,2,1,14, 1,24 };
    snmp_mib_redefine_register(ospfAsLsaCount_variables_oid,
                               sizeof(ospfAsLsaCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsaCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAsLsaCksumSum
    oid ospfAsLsaCksumSum_variables_oid[] = { 1,3,6,1,2,1,14, 1,25 };
    snmp_mib_redefine_register(ospfAsLsaCksumSum_variables_oid,
                               sizeof(ospfAsLsaCksumSum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsaCksumSum",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfDiscontinuityTime
    oid ospfDiscontinuityTime_variables_oid[] = { 1,3,6,1,2,1,14, 1,28 };
    snmp_mib_redefine_register(ospfDiscontinuityTime_variables_oid,
                               sizeof(ospfDiscontinuityTime_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfDiscontinuityTime",
                               "TimeStamp",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // --- ospfAreaTable
    // ospfAreaBdrRtrCount
    oid ospfAreaBdrRtrCount_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 5 };
    snmp_mib_redefine_register(ospfAreaBdrRtrCount_variables_oid,
                               sizeof(ospfAreaBdrRtrCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaBdrRtrCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "importNssa(3) is unspported" /* redefine_descr */);

    // ospfAsBdrRtrCount
    oid ospfAsBdrRtrCount_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 6 };
    snmp_mib_redefine_register(ospfAsBdrRtrCount_variables_oid,
                               sizeof(ospfAsBdrRtrCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsBdrRtrCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaLsaCount
    oid ospfAreaLsaCount_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 7 };
    snmp_mib_redefine_register(ospfAreaLsaCount_variables_oid,
                               sizeof(ospfAreaLsaCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaLsaCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaLsaCksumSum
    oid ospfAreaLsaCksumSum_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 8 };
    snmp_mib_redefine_register(ospfAreaLsaCksumSum_variables_oid,
                               sizeof(ospfAreaLsaCksumSum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaLsaCksumSum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaStatus
    oid ospfAreaStatus_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 10 };
    snmp_mib_redefine_register(ospfAreaStatus_variables_oid,
                               sizeof(ospfAreaStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 active} \
{2 notInService} \
{3 notReady} \
{4 createAndGo} \
{5 createAndWait} \
{6 destroy} \
" /* redefine_descr */);

    // ospfAreaNssaTranslatorEvents
    oid ospfAreaNssaTranslatorEvents_variables_oid[] = { 1,3,6,1,2,1,14, 2, 1, 14 };
    snmp_mib_redefine_register(ospfAreaNssaTranslatorEvents_variables_oid,
                               sizeof(ospfAreaNssaTranslatorEvents_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaNssaTranslatorEvents",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

#if 0 // Not supported
    // --- ospfStubAreaTable
    // ospfStubAreaId
    oid ospfStubAreaId_variables_oid[] = { 1,3,6,1,2,1,14, 3, 1, 1 };
    snmp_mib_redefine_register(ospfStubAreaId_variables_oid,
                               sizeof(ospfStubAreaId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfStubAreaId",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfStubTOS
    oid ospfStubTOS_variables_oid[] = { 1,3,6,1,2,1,14, 3, 1, 2 };
    snmp_mib_redefine_register(ospfStubTOS_variables_oid,
                               sizeof(ospfStubTOS_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfStubTOS",
                               "TOSType",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 30}" /* redefine_descr */);

    // ospfStubMetric
    oid ospfStubMetric_variables_oid[] = { 1,3,6,1,2,1,14, 3, 1, 3 };
    snmp_mib_redefine_register(ospfStubMetric_variables_oid,
                               sizeof(ospfStubMetric_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfStubMetric",
                               "BigMetric",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 16777215}" /* redefine_descr */);

    // ospfStubStatus
    oid ospfStubStatus_variables_oid[] = { 1,3,6,1,2,1,14, 3, 1, 4 };
    snmp_mib_redefine_register(ospfStubStatus_variables_oid,
                               sizeof(ospfStubStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfStubStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 active} \
{2 notInService} \
{3 notReady} \
{4 createAndGo} \
{5 createAndWait} \
{6 destroy} \
" /* redefine_descr */);

    // ospfStubMetricType
    oid ospfStubMetricType_variables_oid[] = { 1,3,6,1,2,1,14, 3, 1, 5 };
    snmp_mib_redefine_register(ospfStubMetricType_variables_oid,
                               sizeof(ospfStubMetricType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfStubMetricType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 ospfMetric} \
{2 comparableCost} \
{3 nonComparable} \
" /* redefine_descr */);
#endif // --- ospfStubAreaTable

#if 0
    // --- ospfLsdbTable
    // ospfLsdbAreaId
    oid ospfLsdbAreaId_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 1 };
    snmp_mib_redefine_register(ospfLsdbAreaId_variables_oid,
                               sizeof(ospfLsdbAreaId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbAreaId",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbType
    oid ospfLsdbType_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 2 };
    snmp_mib_redefine_register(ospfLsdbType_variables_oid,
                               sizeof(ospfLsdbType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 routerLink} \
{2 networkLink} \
{3 summaryLink} \
{4 asSummaryLink} \
{5 asExternalLink} \
{6 multicastLink} \
{7 nssaExternalLink} \
{10 areaOpaqueLink} \
" /* redefine_descr */);

    // ospfLsdbLsid
    oid ospfLsdbLsid_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 3 };
    snmp_mib_redefine_register(ospfLsdbLsid_variables_oid,
                               sizeof(ospfLsdbLsid_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbLsid",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbRouterId
    oid ospfLsdbRouterId_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 4 };
    snmp_mib_redefine_register(ospfLsdbRouterId_variables_oid,
                               sizeof(ospfLsdbRouterId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbRouterId",
                               "RouterID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbSequence
    oid ospfLsdbSequence_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 5 };
    snmp_mib_redefine_register(ospfLsdbSequence_variables_oid,
                               sizeof(ospfLsdbSequence_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbSequence",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbAge
    oid ospfLsdbAge_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 6 };
    snmp_mib_redefine_register(ospfLsdbAge_variables_oid,
                               sizeof(ospfLsdbAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbAge",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbChecksum
    oid ospfLsdbChecksum_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 7 };
    snmp_mib_redefine_register(ospfLsdbChecksum_variables_oid,
                               sizeof(ospfLsdbChecksum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbChecksum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLsdbAdvertisement
    oid ospfLsdbAdvertisement_variables_oid[] = { 1,3,6,1,2,1,14, 4, 1, 8 };
    snmp_mib_redefine_register(ospfLsdbAdvertisement_variables_oid,
                               sizeof(ospfLsdbAdvertisement_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLsdbAdvertisement",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 65535}" /* redefine_descr */);
#endif

#if 0 // obsolete
    // --- ospfAreaRangeTable
    // ospfAreaRangeAreaId
    oid ospfAreaRangeAreaId_variables_oid[] = { 1,3,6,1,2,1,14, 5, 1, 1 };
    snmp_mib_redefine_register(ospfAreaRangeAreaId_variables_oid,
                               sizeof(ospfAreaRangeAreaId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaRangeAreaId",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaRangeNet
    oid ospfAreaRangeNet_variables_oid[] = { 1,3,6,1,2,1,14, 5, 1, 2 };
    snmp_mib_redefine_register(ospfAreaRangeNet_variables_oid,
                               sizeof(ospfAreaRangeNet_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaRangeNet",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaRangeMask
    oid ospfAreaRangeMask_variables_oid[] = { 1,3,6,1,2,1,14, 5, 1, 3 };
    snmp_mib_redefine_register(ospfAreaRangeMask_variables_oid,
                               sizeof(ospfAreaRangeMask_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaRangeMask",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAreaRangeStatus
    oid ospfAreaRangeStatus_variables_oid[] = { 1,3,6,1,2,1,14, 5, 1, 4 };
    snmp_mib_redefine_register(ospfAreaRangeStatus_variables_oid,
                               sizeof(ospfAreaRangeStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaRangeStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 active} \
{2 notInService} \
{3 notReady} \
{4 createAndGo} \
{5 createAndWait} \
{6 destroy} \
" /* redefine_descr */);
#endif // --- ospfAreaRangeTable

    // ospfAreaRangeEffect
    oid ospfAreaRangeEffect_variables_oid[] = { 1,3,6,1,2,1,14, 5, 1, 5 };
    snmp_mib_redefine_register(ospfAreaRangeEffect_variables_oid,
                               sizeof(ospfAreaRangeEffect_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaRangeEffect",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 advertiseMatching} \
{2 doNotAdvertiseMatching} \
" /* redefine_descr */);

#if 0 // Not supported
    // --- ospfHostTable
    // ospfHostIpAddress
    oid ospfHostIpAddress_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 1 };
    snmp_mib_redefine_register(ospfHostIpAddress_variables_oid,
                               sizeof(ospfHostIpAddress_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostIpAddress",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfHostTOS
    oid ospfHostTOS_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 2 };
    snmp_mib_redefine_register(ospfHostTOS_variables_oid,
                               sizeof(ospfHostTOS_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostTOS",
                               "TOSType",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 30}" /* redefine_descr */);

    // ospfHostMetric
    oid ospfHostMetric_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 3 };
    snmp_mib_redefine_register(ospfHostMetric_variables_oid,
                               sizeof(ospfHostMetric_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostMetric",
                               "Metric",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 65535}" /* redefine_descr */);

    // ospfHostStatus
    oid ospfHostStatus_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 4 };
    snmp_mib_redefine_register(ospfHostStatus_variables_oid,
                               sizeof(ospfHostStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 active} \
{2 notInService} \
{3 notReady} \
{4 createAndGo} \
{5 createAndWait} \
{6 destroy} \
" /* redefine_descr */);

    // ospfHostAreaID
    oid ospfHostAreaID_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 5 };
    snmp_mib_redefine_register(ospfHostAreaID_variables_oid,
                               sizeof(ospfHostAreaID_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostAreaID",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfHostCfgAreaID
    oid ospfHostCfgAreaID_variables_oid[] = { 1,3,6,1,2,1,14, 6, 1, 6 };
    snmp_mib_redefine_register(ospfHostCfgAreaID_variables_oid,
                               sizeof(ospfHostCfgAreaID_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfHostCfgAreaID",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);
#endif // --- ospfHostTable

    // --- ospfIfTable
    // ospfIfType
    oid ospfIfType_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 4 };
    snmp_mib_redefine_register(ospfIfType_variables_oid,
                               sizeof(ospfIfType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 broadcast}" /* redefine_descr */);

    // ospfIfAdminStat
    oid ospfIfAdminStat_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 5 };
    snmp_mib_redefine_register(ospfIfAdminStat_variables_oid,
                               sizeof(ospfIfAdminStat_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfAdminStat",
                               "Status",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{1 enabled} {2 disabled}" /* redefine_descr */);

    // ospfIfTransitDelay
    oid ospfIfTransitDelay_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 7 };
    snmp_mib_redefine_register(ospfIfTransitDelay_variables_oid,
                               sizeof(ospfIfTransitDelay_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfTransitDelay",
                               "UpToMaxAge",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 3600}" /* redefine_descr */);

    // ospfIfPollInterval
    oid ospfIfPollInterval_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 11 };
    snmp_mib_redefine_register(ospfIfPollInterval_variables_oid,
                               sizeof(ospfIfPollInterval_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfPollInterval",
                               "PositiveInteger",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 2147483647}" /* redefine_descr */);

    // ospfIfEvents
    oid ospfIfEvents_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 15 };
    snmp_mib_redefine_register(ospfIfEvents_variables_oid,
                               sizeof(ospfIfEvents_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfEvents",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfIfAuthKey
    oid ospfIfAuthKey_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 16 };
    snmp_mib_redefine_register(ospfIfAuthKey_variables_oid,
                               sizeof(ospfIfAuthKey_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfAuthKey",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 256}" /* redefine_descr */);

    // ospfIfStatus
    oid ospfIfStatus_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 17 };
    snmp_mib_redefine_register(ospfIfStatus_variables_oid,
                               sizeof(ospfIfStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // ospfIfMulticastForwarding
    oid ospfIfMulticastForwarding_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 18 };
    snmp_mib_redefine_register(ospfIfMulticastForwarding_variables_oid,
                               sizeof(ospfIfMulticastForwarding_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfMulticastForwarding",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 blocked}" /* redefine_descr */);

    // ospfIfDemand
    oid ospfIfDemand_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 19 };
    snmp_mib_redefine_register(ospfIfDemand_variables_oid,
                               sizeof(ospfIfDemand_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfDemand",
                               "TruthValue",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 true} \
{2 false} \
" /* redefine_descr */);


    // ospfIfLsaCount
    oid ospfIfLsaCount_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 21 };
    snmp_mib_redefine_register(ospfIfLsaCount_variables_oid,
                               sizeof(ospfIfLsaCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfLsaCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfIfLsaCksumSum
    oid ospfIfLsaCksumSum_variables_oid[] = { 1,3,6,1,2,1,14, 7, 1, 22 };
    snmp_mib_redefine_register(ospfIfLsaCksumSum_variables_oid,
                               sizeof(ospfIfLsaCksumSum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfLsaCksumSum",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // --- ospfIfMetricTable
    // ospfIfMetricStatus
    oid ospfIfMetricStatus_variables_oid[] = { 1,3,6,1,2,1,14, 8, 1, 5 };
    snmp_mib_redefine_register(ospfIfMetricStatus_variables_oid,
                               sizeof(ospfIfMetricStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfIfMetricStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // --- ospfVirtIfTable
    // ospfVirtIfTransitDelay
    oid ospfVirtIfTransitDelay_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 3 };
    snmp_mib_redefine_register(ospfVirtIfTransitDelay_variables_oid,
                               sizeof(ospfVirtIfTransitDelay_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfTransitDelay",
                               "UpToMaxAge",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{0 3600}" /* redefine_descr */);

    // ospfVirtIfEvents
    oid ospfVirtIfEvents_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 8 };
    snmp_mib_redefine_register(ospfVirtIfEvents_variables_oid,
                               sizeof(ospfVirtIfEvents_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfEvents",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtIfAuthKey
    oid ospfVirtIfAuthKey_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 9 };
    snmp_mib_redefine_register(ospfVirtIfAuthKey_variables_oid,
                               sizeof(ospfVirtIfAuthKey_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfAuthKey",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 256}" /* redefine_descr */);

    // ospfVirtIfStatus
    oid ospfVirtIfStatus_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 10 };
    snmp_mib_redefine_register(ospfVirtIfStatus_variables_oid,
                               sizeof(ospfVirtIfStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // ospfVirtIfLsaCount
    oid ospfVirtIfLsaCount_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 12 };
    snmp_mib_redefine_register(ospfVirtIfLsaCount_variables_oid,
                               sizeof(ospfVirtIfLsaCount_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfLsaCount",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtIfLsaCksumSum
    oid ospfVirtIfLsaCksumSum_variables_oid[] = { 1,3,6,1,2,1,14, 9, 1, 13 };
    snmp_mib_redefine_register(ospfVirtIfLsaCksumSum_variables_oid,
                               sizeof(ospfVirtIfLsaCksumSum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtIfLsaCksumSum",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // --- ospfNbrTable

    // ospfNbrPriority
    oid ospfNbrPriority_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 5 };
    snmp_mib_redefine_register(ospfNbrPriority_variables_oid,
                               sizeof(ospfNbrPriority_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbrPriority",
                               "DesignatedRouterPriority",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{0 255}" /* redefine_descr */);

    // ospfNbrEvents
    oid ospfNbrEvents_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 7 };
    snmp_mib_redefine_register(ospfNbrEvents_variables_oid,
                               sizeof(ospfNbrEvents_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbrEvents",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfNbrLsRetransQLen
    oid ospfNbrLsRetransQLen_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 8 };
    snmp_mib_redefine_register(ospfNbrLsRetransQLen_variables_oid,
                               sizeof(ospfNbrLsRetransQLen_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbrLsRetransQLen",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfNbmaNbrStatus
    oid ospfNbmaNbrStatus_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 9 };
    snmp_mib_redefine_register(ospfNbmaNbrStatus_variables_oid,
                               sizeof(ospfNbmaNbrStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbmaNbrStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // ospfNbrRestartHelperAge
    oid ospfNbrRestartHelperAge_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 13 };
    snmp_mib_redefine_register(ospfNbrRestartHelperAge_variables_oid,
                               sizeof(ospfNbrRestartHelperAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbrRestartHelperAge",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfNbrRestartHelperExitReason
    oid ospfNbrRestartHelperExitReason_variables_oid[] = { 1,3,6,1,2,1,14, 10, 1, 14 };
    snmp_mib_redefine_register(ospfNbrRestartHelperExitReason_variables_oid,
                               sizeof(ospfNbrRestartHelperExitReason_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfNbrRestartHelperExitReason",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 none} \
{2 inProgress} \
{3 completed} \
{4 timedOut} \
{5 topologyChanged} \
" /* redefine_descr */);

    // --- ospfVirtNbrTable
    // ospfVirtNbrArea
    oid ospfVirtNbrArea_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 1 };
    snmp_mib_redefine_register(ospfVirtNbrArea_variables_oid,
                               sizeof(ospfVirtNbrArea_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrArea",
                               "AreaID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrRtrId
    oid ospfVirtNbrRtrId_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 2 };
    snmp_mib_redefine_register(ospfVirtNbrRtrId_variables_oid,
                               sizeof(ospfVirtNbrRtrId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrRtrId",
                               "RouterID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrIpAddr
    oid ospfVirtNbrIpAddr_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 3 };
    snmp_mib_redefine_register(ospfVirtNbrIpAddr_variables_oid,
                               sizeof(ospfVirtNbrIpAddr_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrIpAddr",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrOptions
    oid ospfVirtNbrOptions_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 4 };
    snmp_mib_redefine_register(ospfVirtNbrOptions_variables_oid,
                               sizeof(ospfVirtNbrOptions_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrOptions",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrState
    oid ospfVirtNbrState_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 5 };
    snmp_mib_redefine_register(ospfVirtNbrState_variables_oid,
                               sizeof(ospfVirtNbrState_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrState",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 down} \
{2 attempt} \
{3 init} \
{4 twoWay} \
{5 exchangeStart} \
{6 exchange} \
{7 loading} \
{8 full} \
" /* redefine_descr */);

    // ospfVirtNbrEvents
    oid ospfVirtNbrEvents_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 6 };
    snmp_mib_redefine_register(ospfVirtNbrEvents_variables_oid,
                               sizeof(ospfVirtNbrEvents_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrEvents",
                               "COUNTER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrLsRetransQLen
    oid ospfVirtNbrLsRetransQLen_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 7 };
    snmp_mib_redefine_register(ospfVirtNbrLsRetransQLen_variables_oid,
                               sizeof(ospfVirtNbrLsRetransQLen_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrLsRetransQLen",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrRestartHelperAge
    oid ospfVirtNbrRestartHelperAge_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 10 };
    snmp_mib_redefine_register(ospfVirtNbrRestartHelperAge_variables_oid,
                               sizeof(ospfVirtNbrRestartHelperAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrRestartHelperAge",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtNbrRestartHelperExitReason
    oid ospfVirtNbrRestartHelperExitReason_variables_oid[] = { 1,3,6,1,2,1,14, 11, 1, 11 };
    snmp_mib_redefine_register(ospfVirtNbrRestartHelperExitReason_variables_oid,
                               sizeof(ospfVirtNbrRestartHelperExitReason_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtNbrRestartHelperExitReason",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{1 none} \
{2 inProgress} \
{3 completed} \
{4 timedOut} \
{5 topologyChanged} \
" /* redefine_descr */);

#if 0
    // --- ospfExtLsdbTable
    // ospfExtLsdbType
    oid ospfExtLsdbType_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 1 };
    snmp_mib_redefine_register(ospfExtLsdbType_variables_oid,
                               sizeof(ospfExtLsdbType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "\
{5 asExternalLink} \
" /* redefine_descr */);

    // ospfExtLsdbLsid
    oid ospfExtLsdbLsid_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 2 };
    snmp_mib_redefine_register(ospfExtLsdbLsid_variables_oid,
                               sizeof(ospfExtLsdbLsid_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbLsid",
                               "IPADDR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbRouterId
    oid ospfExtLsdbRouterId_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 3 };
    snmp_mib_redefine_register(ospfExtLsdbRouterId_variables_oid,
                               sizeof(ospfExtLsdbRouterId_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbRouterId",
                               "RouterID",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbSequence
    oid ospfExtLsdbSequence_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 4 };
    snmp_mib_redefine_register(ospfExtLsdbSequence_variables_oid,
                               sizeof(ospfExtLsdbSequence_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbSequence",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbAge
    oid ospfExtLsdbAge_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 5 };
    snmp_mib_redefine_register(ospfExtLsdbAge_variables_oid,
                               sizeof(ospfExtLsdbAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbAge",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbChecksum
    oid ospfExtLsdbChecksum_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 6 };
    snmp_mib_redefine_register(ospfExtLsdbChecksum_variables_oid,
                               sizeof(ospfExtLsdbChecksum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbChecksum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfExtLsdbAdvertisement
    oid ospfExtLsdbAdvertisement_variables_oid[] = { 1,3,6,1,2,1,14, 12, 1, 7 };
    snmp_mib_redefine_register(ospfExtLsdbAdvertisement_variables_oid,
                               sizeof(ospfExtLsdbAdvertisement_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfExtLsdbAdvertisement",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{36 36}" /* redefine_descr */);
#endif

    // --- ospfAreaAggregateTable
    // ospfAreaAggregateLsdbType
    oid ospfAreaAggregateLsdbType_variables_oid[] = { 1,3,6,1,2,1,14, 14, 1, 2 };
    snmp_mib_redefine_register(ospfAreaAggregateLsdbType_variables_oid,
                               sizeof(ospfAreaAggregateLsdbType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaAggregateLsdbType",
                               "INTEGER",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{3 summaryLink}" /* redefine_descr */);

    // ospfAreaAggregateStatus
    oid ospfAreaAggregateStatus_variables_oid[] = { 1,3,6,1,2,1,14, 14, 1, 5 };
    snmp_mib_redefine_register(ospfAreaAggregateStatus_variables_oid,
                               sizeof(ospfAreaAggregateStatus_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaAggregateStatus",
                               "RowStatus",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{1 active}" /* redefine_descr */);

    // ospfAreaAggregateExtRouteTag
    oid ospfAreaAggregateExtRouteTag_variables_oid[] = { 1,3,6,1,2,1,14, 14, 1, 7 };
    snmp_mib_redefine_register(ospfAreaAggregateExtRouteTag_variables_oid,
                               sizeof(ospfAreaAggregateExtRouteTag_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaAggregateExtRouteTag",
                               "UNSIGNED32",
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_NOT_IMPLEMENTED, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

#if 0 // Not supported
    // --- ospfLocalLsdbTable
    // ospfLocalLsdbSequence
    oid ospfLocalLsdbSequence_variables_oid[] = { 1,3,6,1,2,1,14, 17, 1, 6 };
    snmp_mib_redefine_register(ospfLocalLsdbSequence_variables_oid,
                               sizeof(ospfLocalLsdbSequence_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLocalLsdbSequence",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLocalLsdbAge
    oid ospfLocalLsdbAge_variables_oid[] = { 1,3,6,1,2,1,14, 17, 1, 7 };
    snmp_mib_redefine_register(ospfLocalLsdbAge_variables_oid,
                               sizeof(ospfLocalLsdbAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLocalLsdbAge",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLocalLsdbChecksum
    oid ospfLocalLsdbChecksum_variables_oid[] = { 1,3,6,1,2,1,14, 17, 1, 8 };
    snmp_mib_redefine_register(ospfLocalLsdbChecksum_variables_oid,
                               sizeof(ospfLocalLsdbChecksum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLocalLsdbChecksum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfLocalLsdbAdvertisement
    oid ospfLocalLsdbAdvertisement_variables_oid[] = { 1,3,6,1,2,1,14, 17, 1, 9 };
    snmp_mib_redefine_register(ospfLocalLsdbAdvertisement_variables_oid,
                               sizeof(ospfLocalLsdbAdvertisement_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfLocalLsdbAdvertisement",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 65535}" /* redefine_descr */);

    // --- ospfVirtLocalLsdbTable
    // ospfVirtLocalLsdbSequence
    oid ospfVirtLocalLsdbSequence_variables_oid[] = { 1,3,6,1,2,1,14, 18, 1, 6 };
    snmp_mib_redefine_register(ospfVirtLocalLsdbSequence_variables_oid,
                               sizeof(ospfVirtLocalLsdbSequence_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtLocalLsdbSequence",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtLocalLsdbAge
    oid ospfVirtLocalLsdbAge_variables_oid[] = { 1,3,6,1,2,1,14, 18, 1, 7 };
    snmp_mib_redefine_register(ospfVirtLocalLsdbAge_variables_oid,
                               sizeof(ospfVirtLocalLsdbAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtLocalLsdbAge",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtLocalLsdbChecksum
    oid ospfVirtLocalLsdbChecksum_variables_oid[] = { 1,3,6,1,2,1,14, 18, 1, 8 };
    snmp_mib_redefine_register(ospfVirtLocalLsdbChecksum_variables_oid,
                               sizeof(ospfVirtLocalLsdbChecksum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtLocalLsdbChecksum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfVirtLocalLsdbAdvertisement
    oid ospfVirtLocalLsdbAdvertisement_variables_oid[] = { 1,3,6,1,2,1,14, 18, 1, 9 };
    snmp_mib_redefine_register(ospfVirtLocalLsdbAdvertisement_variables_oid,
                               sizeof(ospfVirtLocalLsdbAdvertisement_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfVirtLocalLsdbAdvertisement",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 65535}" /* redefine_descr */);
#endif // --- ospfLocalLsdbTable

#if 0 // Not supported
    // --- ospfAsLsdbTable
    // ospfAsLsdbSequence
    oid ospfAsLsdbSequence_variables_oid[] = { 1,3,6,1,2,1,14, 19, 1, 4 };
    snmp_mib_redefine_register(ospfAsLsdbSequence_variables_oid,
                               sizeof(ospfAsLsdbSequence_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsdbSequence",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAsLsdbAge
    oid ospfAsLsdbAge_variables_oid[] = { 1,3,6,1,2,1,14, 19, 1, 5 };
    snmp_mib_redefine_register(ospfAsLsdbAge_variables_oid,
                               sizeof(ospfAsLsdbAge_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsdbAge",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAsLsdbChecksum
    oid ospfAsLsdbChecksum_variables_oid[] = { 1,3,6,1,2,1,14, 19, 1, 6 };
    snmp_mib_redefine_register(ospfAsLsdbChecksum_variables_oid,
                               sizeof(ospfAsLsdbChecksum_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsdbChecksum",
                               "INTEGER32",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "" /* redefine_descr */);

    // ospfAsLsdbAdvertisement
    oid ospfAsLsdbAdvertisement_variables_oid[] = { 1,3,6,1,2,1,14, 19, 1, 7 };
    snmp_mib_redefine_register(ospfAsLsdbAdvertisement_variables_oid,
                               sizeof(ospfAsLsdbAdvertisement_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAsLsdbAdvertisement",
                               "OCTETSTR",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               FALSE, /* redefine_size, TRUE if size is redefined. */
                               "{1 65535}" /* redefine_descr */);
#endif //  --- ospfAsLsdbTable

    // --- ospfAreaLsaCountTable
    // ospfAreaLsaCountLsaType
    oid ospfAreaLsaCountLsaType_variables_oid[] = { 1,3,6,1,2,1,14, 20, 1, 2 };
    snmp_mib_redefine_register(ospfAreaLsaCountLsaType_variables_oid,
                               sizeof(ospfAreaLsaCountLsaType_variables_oid) / sizeof(oid),
                               "OSPF-MIB : ospfAreaLsaCountLsaType",
                               "GAUGE",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY, /* redefine_access_type */
                               TRUE, /* redefine_size, TRUE if size is redefined. */
                               "{1 routerLink} {2 networkLink} {3 summaryLink} {4 asSummaryLink}" /* redefine_descr */);

    // Register mibContextTable
    oid ospfGeneralGroup_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 1};
    mibContextTable_register(ospfGeneralGroup_variables_oid,
                             sizeof(ospfGeneralGroup_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfGeneralGroup");

    oid ospfAreaTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 2};
    mibContextTable_register(ospfAreaTable_variables_oid,
                             sizeof(ospfAreaTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfAreaTable");

    oid ospfLsdbTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 4};
    mibContextTable_register(ospfLsdbTable_variables_oid,
                             sizeof(ospfLsdbTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfLsdbTable");

    oid ospfIfTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 7};
    mibContextTable_register(ospfIfTable_variables_oid,
                             sizeof(ospfIfTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfIfTable");

    oid ospfIfMetricTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 8};
    mibContextTable_register(ospfIfMetricTable_variables_oid,
                             sizeof(ospfIfMetricTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfIfMetricTable");

    oid ospfVirtIfTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 9};
    mibContextTable_register(ospfVirtIfTable_variables_oid,
                             sizeof(ospfVirtIfTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfVirtIfTable");

    oid ospfNbrTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 10};
    mibContextTable_register(ospfNbrTable_variables_oid,
                             sizeof(ospfNbrTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfNbrTable");

    oid ospfVirtNbrTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 11};
    mibContextTable_register(ospfVirtNbrTable_variables_oid,
                             sizeof(ospfVirtNbrTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfVirtNbrTable");

    oid ospfExtLsdbTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 12};
    mibContextTable_register(ospfExtLsdbTable_variables_oid,
                             sizeof(ospfExtLsdbTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfExtLsdbTable");

    oid ospfAreaAggregateTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 14};
    mibContextTable_register(ospfAreaAggregateTable_variables_oid,
                             sizeof(ospfAreaAggregateTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfAreaAggregateTable");

    oid ospfAreaLsaCountTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14, 20};
    mibContextTable_register(ospfAreaLsaCountTable_variables_oid,
                             sizeof(ospfAreaLsaCountTable_variables_oid) / sizeof(oid),
                             "OSPF-MIB : ospfAreaLsaCountTable");

    VTSS_TRACE(DEBUG) << "exit";
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/
/**
  * \brief Get scalar data of ospfGeneralGroupScalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfGeneralGroupScalar_get(ospfGeneralGroup_scalar_t *scalar_entry)
{
    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_router_conf_t conf;
    vtss_appl_ospf_router_status_t status;
    mesa_rc rc = VTSS_RC_OK;

    VTSS_TRACE(DEBUG) << "enter";

    /* 1. Get the original configuraiton or refer to the default setting when the current OSPF process isn't running. */
    if (vtss_appl_ospf_get(id) != VTSS_RC_OK) {
        if ((rc = frr_ospf_router_conf_def(&id, &conf)) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get default config fail!";
            return rc;
        }

        // we don't enable the ospf, set the status value to default.
        memset(&status, 0, sizeof(vtss_appl_ospf_router_status_t));
    } else {
        if ((rc = vtss_appl_ospf_router_conf_get(id, &conf)) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get router config fail!";
            return rc;
        }
        if ((rc = vtss_appl_ospf_router_status_get(id, &status)) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get router status fail!";
            return rc;
        }
    }

    /* 2. Update the MIB parameter values */
    scalar_entry->ospfRouterId = conf.router_id.id;
    scalar_entry->ospfAdminStat = vtss_appl_ospf_get(id) == VTSS_RC_OK ? OSPF_SNMP_ADMIN_ENABLE : OSPF_SNMP_ADMIN_DISABLE;
    scalar_entry->ospfVersionNumber = VTSS_OSPF_VERSION;

    /* Not supported, TODO
       It is supported in FRR but not in OSPF public APIs.
       See show_ip_ospf_common() in \quagga-layer\build\all\mips\frr\ospfd\ospf_vty.c
       if (CHECK_FLAG(ospf->flags, OSPF_FLAG_ABR)) {
	   if (CHECK_FLAG(ospf->flags, OSPF_FLAG_ASBR)) {

    scalar_entry->ospfAreaBdrRtrStatus = OSPF_SNMP_FALSE;
    scalar_entry->ospfASBdrRtrStatus = OSPF_SNMP_FALSE;
    */

    scalar_entry->ospfExternLsaCount = status.external_lsa_count;
    scalar_entry->ospfExternLsaCksumSum = status.external_lsa_checksum;

    /* TOS is not supported. */
    scalar_entry->ospfTOSSupport = OSPF_SNMP_UNSUPPORTED;

    /* Not supported
    scalar_entry->ospfOriginateNewLsas = 0;
    scalar_entry->ospfRxNewLsas = 0;
    */

    /* There is no limit for the number of non-default
	   AS-external-LSAs. */
    scalar_entry->ospfExtLsdbLimit = -1;

    /* Multicast Extensions to OSPF is not supported. */
    scalar_entry->ospfMulticastExtensions = 0;

    /* Overflow is not supported. */
    scalar_entry->ospfExitOverflowInterval = 0;

    /* Demand routing is not supported. */
    scalar_entry->ospfDemandExtensions = OSPF_SNMP_UNSUPPORTED;

    scalar_entry->ospfRFC1583Compatibility = OSPF_SNMP_FALSE;
    scalar_entry->ospfOpaqueLsaSupport = OSPF_SNMP_UNSUPPORTED;

    /* The MSCC default value is 1,000,000 KBPS (1G). */
    scalar_entry->ospfReferenceBandwidth = 1000000;

    scalar_entry->ospfRestartSupport = 1; // {1 none}, {2 plannedOnly}, {3 plannedAndUnplanned}

    /* Not supported
    scalar_entry->ospfRestartInterval = 1;
    scalar_entry->ospfRestartStrictLsaChecking = OSPF_SNMP_FALSE;
    scalar_entry->ospfRestartStatus = 1; // {1 notRestarting}, {2 plannedRestart}, {3 unplannedRestart}
    scalar_entry->ospfRestartAge = 0;
    scalar_entry->ospfRestartExitReason = 1; //{1 none}, {2 inProgress}, {3 completed}, {4 timedOut}, {5 topologyChanged}

    scalar_entry->ospfAsLsaCount = 0;
    scalar_entry->ospfAsLsaCksumSum = 0;
    */

    scalar_entry->ospfStubRouterSupport = OSPF_SNMP_SUPPORTED;
    scalar_entry->ospfStubRouterAdvertisement = conf.stub_router.is_administrative ? 2 : 1; // {1 doNotAdvertise} {2 advertise}

    /* Not supported
    scalar_entry->ospfDiscontinuityTime = 0;
    */

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set scalar data of ospfGeneralGroupScalar
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfGeneralGroupScalar_set(ospfGeneralGroup_scalar_t *scalar_entry)
{
    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_router_conf_t conf;
    mesa_rc rc = VTSS_RC_OK;

    VTSS_TRACE(DEBUG) << "enter";

    // check null access on the scalar entry.
    if (!scalar_entry) {
        VTSS_TRACE(DEBUG) << "null access!";
        return 0;
    }

    /* 1. Get OSPF process status. */
    // If the ospfAdminStat is disabled, we need to eanble it before apply the new configuation.
    if (vtss_appl_ospf_get(id) == VTSS_RC_OK) { // Enabled
        if (scalar_entry->ospfAdminStat == OSPF_SNMP_ADMIN_DISABLE) {
            rc = vtss_appl_ospf_del(id);
            return 0;
        }
    } else { // Disabled
        if (scalar_entry->ospfAdminStat == OSPF_SNMP_ADMIN_ENABLE) {
            rc = vtss_appl_ospf_add(id);
            if (rc != VTSS_RC_OK) {
                VTSS_TRACE(DEBUG) << "add ospf config fail!";
                return -1;
            }
        }
    }

    /* 2. Get the original configuration */
    if ((rc = vtss_appl_ospf_router_conf_get(id, &conf)) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get router config fail!";
        return rc;
    }

    /* 3. Apply the new configuration if any change */
    if (conf.router_id.id != scalar_entry->ospfRouterId ||
        conf.stub_router.is_administrative != (scalar_entry->ospfStubRouterAdvertisement == 2 ? true : false)) {
        // Assign the new parameter value
        conf.router_id.is_specific_id = scalar_entry->ospfRouterId ? TRUE : FALSE;
        conf.router_id.id = scalar_entry->ospfRouterId;
        conf.stub_router.is_administrative = scalar_entry->ospfStubRouterAdvertisement == 2 ? true : false;

        // Apply the new configuration
        rc = vtss_appl_ospf_router_conf_set(id, &conf);
        if (rc != VTSS_RC_OK && rc != VTSS_APPL_FRR_OSPF_ERROR_ROUTER_ID_CHANGE_NOT_TAKE_EFFECT) {
            return -1;
        }
    }

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ospfAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaTableEntry_getfirst(ospfAreaTable_entry_t *table_entry)
{

    VTSS_TRACE(DEBUG) << "enter";

    // Try to find if the first entry (area_id = 0) is existing
    table_entry->ospfAreaId = 0;
    if (ospfAreaTableEntry_get(table_entry, false) == 0) {
         // Found the first entry
        return 0;
    }

    VTSS_TRACE(DEBUG) << "exit";
    return ospfAreaTableEntry_get(table_entry, true);
}

/**
  * \brief Get/Getnext table entry of ospfAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaTableEntry_get(ospfAreaTable_entry_t *table_entry, int getnext)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID, next_id;
    vtss_appl_ospf_area_id_t area_id;
    vtss_appl_ospf_area_status_t status;
    mesa_rc rc;

    VTSS_TRACE(DEBUG) << "enter";

    /* Get next entry key. */
    if (getnext) {
        rc = vtss_appl_ospf_area_status_itr(&cur_id, &next_id, &table_entry->ospfAreaId, &area_id);
        if (rc != VTSS_RC_OK) {
            return rc;
        }
        table_entry->ospfAreaId = area_id;
    }

   /* Get entry data. */
    area_id = table_entry->ospfAreaId;
    rc = vtss_appl_ospf_area_status_get(cur_id, area_id, &status);
    if (rc != VTSS_RC_OK) {
        return rc;
    }

    /* Update the MIB parameter values */

    /* Obsolete
    vtss_appl_ospf_auth_type_t auth_type;
    rc = vtss_appl_ospf_area_auth_conf_get(cur_id, area_id, &auth_type);
    if (rc != VTSS_RC_OK) {
        return rc;
    }
    table_entry->ospfAuthType = auth_type == VTSS_APPL_OSPF_AUTH_TYPE_NULL ? 0 :
                                auth_type == VTSS_APPL_OSPF_AUTH_TYPE_SIMPLE_PASSWORD ? 1 :
                                auth_type == VTSS_APPL_OSPF_AUTH_TYPE_MD5 ? 2 : 3;
    */

    // {1 importExternal}, {2 importNoExternal}, {3 importNssa}
    table_entry->ospfImportAsExtern = status.area_type == VTSS_APPL_OSPF_AREA_NORMAL ? 1 : status.area_type == VTSS_APPL_OSPF_AREA_NSSA ? 3 : 2;

    table_entry->ospfSpfRuns = status.spf_executed_count;

    /* Not supported
    table_entry->ospfAreaBdrRtrCount = 0;
    table_entry->ospfAsBdrRtrCount = 0;
    table_entry->ospfAreaLsaCount = 0;
    table_entry->ospfAreaLsaCksumSum = 0;
    */

    /* Get Current configuration */
    vtss_appl_ospf_stub_area_conf_t conf;
    if (vtss_appl_ospf_stub_area_conf_get(cur_id, area_id, &conf) != VTSS_RC_OK) {
        if ((rc = frr_ospf_stub_area_conf_def(&cur_id, &area_id, &conf)) != VTSS_RC_OK) {
            return rc;
        }
    }

    // {1 noAreaSummary}, {2 sendAreaSummary}
    table_entry->ospfAreaSummary = status.area_type == VTSS_APPL_OSPF_AREA_NORMAL ? 2 : conf.no_summary ? 1 : 2;

    table_entry->ospfAreaStatus = SNMP_ROW_ACTIVE;

    // ospfAreaNssaTranslatorRole {1 always}, {2 candidate}
    if (status.area_type != VTSS_APPL_OSPF_AREA_NORMAL) {
        table_entry->ospfAreaNssaTranslatorRole = conf.nssa_translator_role == VTSS_APPL_OSPF_NSSA_TRANSLATOR_ROLE_ALWAYS ? 1 : 2;
    } else {
        table_entry->ospfAreaNssaTranslatorRole = 2;
    }

    // ospfAreaNssaTranslatorState {1 enabled}, {2 elected}, {3 disabled}
    if (status.nssa_trans_state == VTSS_APPL_OSPF_NSSA_TRANSLATOR_STATE_ENABLED) {
        table_entry->ospfAreaNssaTranslatorState = 1;
    } else if (status.nssa_trans_state == VTSS_APPL_OSPF_NSSA_TRANSLATOR_STATE_ELECTED) {
        table_entry->ospfAreaNssaTranslatorState = 2;
    } else {
        table_entry->ospfAreaNssaTranslatorState = 3;
    }


    /* Refer to FRR 4.0 ospfd.h Line#48
     * #define OSPF_NSSA_TRANS_STABLE_DEFAULT		40
     */
    table_entry->ospfAreaNssaTranslatorStabilityInterval = 40;

    /* Not supported
    table_entry->ospfAreaNssaTranslatorEvents = 0;
    */

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of ospfAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaTableEntry_set(ospfAreaTable_entry_t *table_entry)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id = table_entry->ospfAreaId;
    mesa_rc rc;
    bool is_existing = false;

    VTSS_TRACE(DEBUG) << "enter";

    /* Get current configuration */
    vtss_appl_ospf_stub_area_conf_t conf, new_conf;
    if (vtss_appl_ospf_stub_area_conf_get(cur_id, area_id, &conf) != VTSS_RC_OK) {
        if ((rc = frr_ospf_stub_area_conf_def(&cur_id, &area_id, &conf)) != VTSS_RC_OK) {
            return rc;
        }
    } else {
        is_existing = true;
    }
    new_conf = conf;

    // {1 importExternal}, {2 importNoExternal}, {3 importNssa}
    if (table_entry->ospfImportAsExtern == 1) {
        (void) vtss_appl_ospf_stub_area_conf_del(cur_id, area_id);
    } else {
        /* Update new configuration */
        new_conf.is_nssa = table_entry->ospfImportAsExtern == 3;
        new_conf.no_summary = table_entry->ospfAreaSummary == 1;
        if (new_conf.is_nssa) {
            // {1 always}, {2 candidate}
            new_conf.nssa_translator_role = table_entry->ospfAreaNssaTranslatorRole == 1 ? VTSS_APPL_OSPF_NSSA_TRANSLATOR_ROLE_ALWAYS : VTSS_APPL_OSPF_NSSA_TRANSLATOR_ROLE_CANDIDATE;
        } else {
            new_conf.nssa_translator_role = VTSS_APPL_OSPF_NSSA_TRANSLATOR_ROLE_CANDIDATE;
        }

        /* Apply the new configuration if any change */
        if (memcmp(&new_conf, &conf, sizeof(conf))) {
            if (is_existing) {
                rc = vtss_appl_ospf_stub_area_conf_set(cur_id, area_id, &new_conf);
            } else {
                rc = vtss_appl_ospf_stub_area_conf_add(cur_id, area_id, &new_conf);
            }
        }
    }

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfStubAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfStubAreaTableEntry_getfirst(ospfStubAreaTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfStubAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfStubAreaTableEntry_get(ospfStubAreaTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Set table entry of ospfStubAreaTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfStubAreaTableEntry_set(ospfStubAreaTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/* Mapping xxx to vtss_appl_ospf_lsdb_type_t */
static vtss_appl_ospf_lsdb_type_t frr_ospf_db_type_mapping(const int32_t lsdb_type) {
    switch (lsdb_type) {
    case 1:
        return VTSS_APPL_OSPF_LSDB_TYPE_ROUTER;

    case 2:
        return VTSS_APPL_OSPF_LSDB_TYPE_NETWORK;

    case 3:
        return VTSS_APPL_OSPF_LSDB_TYPE_SUMMARY;

    case 4:
        return VTSS_APPL_OSPF_LSDB_TYPE_ASBR_SUMMARY;

    case 5:
        return VTSS_APPL_OSPF_LSDB_TYPE_EXTERNAL;

    case 7:
        return VTSS_APPL_OSPF_LSDB_TYPE_NSSA_EXTERNAL;

    default:  // 'RT_DiscardIA' doens't support
        break;
    }

    return VTSS_APPL_OSPF_LSDB_TYPE_NONE;
}

/**
  * \brief Get first table entry of ospfLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfLsdbTableEntry_getfirst(ospfLsdbTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // Try to find if the first entry is existing
    table_entry->ospfLsdbAreaId = 0;
    table_entry->ospfLsdbType = VTSS_APPL_OSPF_LSDB_TYPE_ROUTER;
    table_entry->ospfLsdbLsid = 0;
    table_entry->ospfLsdbRouterId = 0;

    if (ospfLsdbTableEntry_get(table_entry, false) == 0) {
        // Found the first entry
        VTSS_TRACE(DEBUG) << "exit";
        return 0;
    }

    VTSS_TRACE(DEBUG) << "exit";
    return ospfLsdbTableEntry_get(table_entry, true);
}

/**
  * \brief Get/Getnext table entry of ospfLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfLsdbTableEntry_get(ospfLsdbTable_entry_t *table_entry, int getnext)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID, next_id;
    vtss_appl_ospf_area_id_t area_id;
    vtss_appl_ospf_lsdb_type_t cur_type;
    vtss_appl_ospf_lsdb_type_t type;
    mesa_ipv4_t link_state_id;
    vtss_appl_ospf_router_id_t router_id;
    vtss_appl_ospf_db_general_info_t info;
    mesa_rc rc;

    VTSS_TRACE(DEBUG) << "enter";

    /* Get next entry key. */
    if (getnext) {
        cur_type = frr_ospf_db_type_mapping(table_entry->ospfLsdbType);
        rc = vtss_appl_ospf_db_itr(&cur_id, &next_id, &table_entry->ospfLsdbAreaId, &area_id,
                                   &cur_type, &type, &table_entry->ospfLsdbLsid,
                                   &link_state_id, &table_entry->ospfLsdbRouterId, &router_id);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "exit";
            return rc;
        }

        // for type 5, we don't display the data on LsdbTable
        while(type == VTSS_APPL_OSPF_LSDB_TYPE_EXTERNAL) {
            rc = vtss_appl_ospf_db_itr(&cur_id, &next_id, &table_entry->ospfLsdbAreaId, &area_id,
                                       &cur_type, &type, &table_entry->ospfLsdbLsid,
                                       &link_state_id, &table_entry->ospfLsdbRouterId, &router_id);
            if (rc != VTSS_RC_OK) {
                VTSS_TRACE(DEBUG) << "exit";
                return rc;
            }
        }

        table_entry->ospfLsdbAreaId = area_id;
        table_entry->ospfLsdbType = type;
        table_entry->ospfLsdbLsid = link_state_id;
        table_entry->ospfLsdbRouterId = router_id;
    }

    /* Get entry data. */
    area_id = table_entry->ospfLsdbAreaId;
    type = frr_ospf_db_type_mapping(table_entry->ospfLsdbType);
    link_state_id = table_entry->ospfLsdbLsid;
    router_id = table_entry->ospfLsdbRouterId;
    rc = vtss_appl_ospf_db_get(cur_id, area_id, type, link_state_id, router_id, &info);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "exit";
        return rc;
    }

    /* Update the MIB parameter values */

    /* Sequence */
    table_entry->ospfLsdbSequence = info.sequence;

    /* Age */
    table_entry->ospfLsdbAge = info.age;

    /* Checksum */
    table_entry->ospfLsdbChecksum = info.checksum;

    /* Advertisement */
    table_entry->ospfLsdbAdvertisement[0] = '\0';

    /* Advertisement Count */
    table_entry->ospfLsdbAdvertisement_len = info.router_link_count;

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfAreaRangeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaRangeTableEntry_getfirst(ospfAreaRangeTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfAreaRangeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaRangeTableEntry_get(ospfAreaRangeTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Set table entry of ospfAreaRangeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaRangeTableEntry_set(ospfAreaRangeTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get first table entry of ospfHostTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfHostTableEntry_getfirst(ospfHostTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfHostTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfHostTableEntry_get(ospfHostTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Set table entry of ospfHostTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfHostTableEntry_set(ospfHostTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get first table entry of ospfIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfTableEntry_getfirst(ospfIfTable_entry_t *table_entry)
{
   VTSS_TRACE(DEBUG) << __func__ << " enter";

    table_entry->ospfAddressLessIf = 0;
    table_entry->ospfIfIpAddress = 0;

    return ospfIfTableEntry_get(table_entry, true);
}

int auth_type_mapping[][2] = {
        {VTSS_APPL_OSPF_AUTH_TYPE_NULL, OSPF_SNMP_AUTH_TYPE_NONE},
        {VTSS_APPL_OSPF_AUTH_TYPE_SIMPLE_PASSWORD,
         OSPF_SNMP_AUTH_TYPE_SIMPLE_PASSWD},
        {VTSS_APPL_OSPF_AUTH_TYPE_MD5, OSPF_SNMP_AUTH_TYPE_MD5}};

int if_state_mapping[][2] = {
        {VTSS_APPL_OSPF_INTERFACE_DOWN, OSPF_SNMP_INTF_STATE_DOWN},
        {VTSS_APPL_OSPF_INTERFACE_WAITING, OSPF_SNMP_INTF_STATE_WAITING},
        {VTSS_APPL_OSPF_INTERFACE_POINT2POINT, OSPF_SNMP_INTF_STATE_POINT2POINT},
        {VTSS_APPL_OSPF_INTERFACE_DR_OTHER, OSPF_SNMP_INTF_STATE_DROTHER},
        {VTSS_APPL_OSPF_INTERFACE_DR, OSPF_SNMP_INTF_STATE_DR},
        {VTSS_APPL_OSPF_INTERFACE_BDR, OSPF_SNMP_INTF_STATE_BDR}};
/**
  * \brief Get/Getnext table entry of ospfIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfTableEntry_get(ospfIfTable_entry_t *table_entry, int getnext)
{
    vtss_ifindex_t ifindex;
    vtss_appl_ospf_interface_status_t entry = {};
    VTSS_TRACE(DEBUG) << __func__ << " enter getnext:" << getnext;
    VTSS_TRACE(DEBUG) << " key:" << vtss::AsIpv4(table_entry->ospfIfIpAddress);

    /* MIB uses intf address and intf index as key */
    if(!getnext) {
        /* 1. get case - try to get the ifindex */
        if (table_entry->ospfIfIpAddress != 0 && table_entry->ospfAddressLessIf == 0) {
            mesa_ip_addr_t if_ip;
            vtss_appl_ip_if_status_t if_status = {};

            if_ip.type = MESA_IP_TYPE_IPV4;
            if_ip.addr.ipv4 = (mesa_ipv4_t)table_entry->ospfIfIpAddress;
            /* Find out ifindex from the ip addr */
            if (vtss_appl_ip_if_status_find(&if_ip, &if_status) != VTSS_RC_OK) {
                VTSS_TRACE(DEBUG) << "get ip if from addr " << vtss::AsIpv4(table_entry->ospfIfIpAddress) << " failed";
                return -1;
            }

            if (!vtss_ifindex_is_vlan(if_status.ifindex)) {
                VTSS_TRACE(DEBUG) << "ifindex (" << if_status.ifindex << ") is not a VLAN";
                return -1;
            }

            ifindex = if_status.ifindex;
        } else if (table_entry->ospfIfIpAddress == 0 && table_entry->ospfAddressLessIf != 0) {
            ifindex = vtss_ifindex_cast_from_u32_0(table_entry->ospfAddressLessIf);
            VTSS_TRACE(DEBUG) << "ifindex:" << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex));
        } else {
            VTSS_TRACE(DEBUG) << "get function param error";
            return -1;
        }
    } else {
        /* 2. get next case - try to find the next valid entry's ifindex */
        vtss_ifindex_t ifindex_1 = vtss_ifindex_cast_from_u32_0(table_entry->ospfAddressLessIf);
        mesa_ipv4_t if_addr;
        mesa_ipv4_t if_addr_1 = table_entry->ospfIfIpAddress;

        if (table_entry->ospfIfIpAddress != 0) {
            // if ip address is not zero, set ifindex to the max value
            ifindex_1 = vtss_ifindex_cast_from_u32_0(0xFFFFFFFF);
        }

        VTSS_TRACE(DEBUG) << "get next from intf " << vtss::AsIpv4(if_addr_1)
                          << "/ " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex_1));
        if ((vtss_appl_ospf_interface_itr2( &if_addr_1, &if_addr, &ifindex_1, &ifindex)) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get next intf from intf " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex_1)) << " failed";
            return -1;
        }
    }

    /* 3. from the above the ifindex is got, now get the intf status. */
    VTSS_TRACE(DEBUG) << "get intf "
                      << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " status";
    if (vtss_appl_ospf_interface_status_get(ifindex, &entry) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get intf " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " status failed";
        return -1;
    }

    VTSS_TRACE(DEBUG) << "intf " << ifindex << " fill data";

    /* 4. fillin the key according to the target intf staus */

    /*Descr. For the purpose of easing the instancing of
    addressed and addressless interfaces;this
    variable takes the value 0 on interfaces with
    IP addresses and the corresponding value of
    ifIndex for interfaces having no IP address.*/
    if (entry.status == false || vtss_ifindex_is_frr_vlink(ifindex) ) {
        table_entry->ospfIfIpAddress = 0;
        table_entry->ospfAddressLessIf =
                (int32_t)vtss_ifindex_cast_to_u32(ifindex);
    } else {
        table_entry->ospfIfIpAddress = entry.network.address;
        table_entry->ospfAddressLessIf = 0;
    }

    /* 5. fillin the data */
    table_entry->ospfIfAreaId = entry.area_id;
    table_entry->ospfIfType =
            1;  //{1 broadcast} {2 nbma} {3 pointToPoint} {5 pointToMultipoint}
    table_entry->ospfIfAdminStat =
            entry.status ? OSPF_SNMP_ADMIN_ENABLE : OSPF_SNMP_ADMIN_DISABLE;
    table_entry->ospfIfRtrPriority = entry.priority;
    table_entry->ospfIfTransitDelay = entry.transmit_delay;
    table_entry->ospfIfRetransInterval = entry.retransmit_time;
    table_entry->ospfIfHelloInterval = entry.hello_time;

    table_entry->ospfIfRtrDeadInterval = entry.dead_time;

    int row = sizeof(if_state_mapping) / sizeof(if_state_mapping[0]);
    for (int i = 0; i < row; i++) {
        if (if_state_mapping[i][0] == entry.state) {
            table_entry->ospfIfState = if_state_mapping[i][1];
            break;
        }
    }

    table_entry->ospfIfDesignatedRouter = entry.dr_addr;
    table_entry->ospfIfDesignatedRouterId = entry.dr_id;
    table_entry->ospfIfBackupDesignatedRouter = entry.bdr_addr;
    table_entry->ospfIfBackupDesignatedRouterId = entry.bdr_id;
    table_entry->ospfIfStatus = 1;  // {1 active} {2 notInService} {3 notReady}
                                    // {4 createAndGo} {5 createAndWait} {6
                                    // destroy}
    table_entry->ospfIfMulticastForwarding =
            1;  //{1 blocked} {2 multicast} {3 unicast}

    /* Descr. When read, ospfIfAuthKey always returns an octet
        string of length zero. */
    strcpy(table_entry->ospfIfAuthKey, "");
    table_entry->ospfIfAuthKey_len = strlen(table_entry->ospfIfAuthKey);

                /* unsupport */
    // table_entry->ospfIfPollInterval = ;
    // table_entry->ospfIfEvents = ;
    // table_entry->ospfIfDemand = ;
    // table_entry->ospfIfLsaCount = ;
    // table_entry->ospfIfLsaCksumSum = ;

    if (vtss_ifindex_is_frr_vlink(ifindex)) {
        VTSS_TRACE(DEBUG) << "exit return vlink intf " << ifindex;
        return 0;
    }
    // get interface configuration to fillin data
    vtss_appl_ospf_intf_conf_t intf_conf;
    if (vtss_appl_ospf_intf_conf_get(ifindex, &intf_conf) != VTSS_RC_OK) {
        VTSS_TRACE(WARNING) << "get intf " << ifindex << " config failed";
        return -1;
    }

    row = sizeof(auth_type_mapping) / sizeof(auth_type_mapping[0]);
    for (int i = 0; i < row; i++) {
        if (auth_type_mapping[i][0] == intf_conf.auth_type) {
            table_entry->ospfIfAuthType = auth_type_mapping[i][1];
            break;
        }
    }

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of ospfIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfTableEntry_set(ospfIfTable_entry_t *table_entry)
{
    vtss_ifindex_t ifindex;
    VTSS_TRACE(DEBUG) << __func__ << " enter";
    /* MIB uses intf address and intf index as key */

    /* 1. get the ifindex */
    if (table_entry->ospfIfIpAddress != 0) {
        /* got ospfIfIpAddress. ospfAddressLessIf(ifindex) is 0.
           appl uses ifindex as key. Find out ifindex from the ip addr */
        mesa_ip_addr_t if_addr;
        vtss_appl_ip_if_status_t if_status = {};
        if_addr.type = MESA_IP_TYPE_IPV4;
        if_addr.addr.ipv4 = (mesa_ipv4_t)table_entry->ospfIfIpAddress;

        if (vtss_appl_ip_if_status_find(&if_addr, &if_status) != VTSS_RC_OK) {
            VTSS_TRACE(WARNING) << "get intf status from addr " << vtss::AsIpv4(table_entry->ospfIfIpAddress) << " failed";
            return -1;
        }

        if (!vtss_ifindex_is_vlan(if_status.ifindex)) {
            VTSS_TRACE(WARNING) << "ifindex (" << if_status.ifindex << ") is not a VLAN";
            return -1;
        }

        ifindex = if_status.ifindex;
    } else {
        /* got ospfAddressLessIf(ifindex). ospfIfIpAddress is 0. */
        ifindex = vtss_ifindex_cast_from_u32_0(table_entry->ospfAddressLessIf);
    }

    /* goto ospfVirtIfTable to setup virtual link instead of ospfIfTable */
    if (vtss_ifindex_is_frr_vlink(ifindex)) {
        VTSS_TRACE(DEBUG) << "exit return vlink intf " << ifindex;
        return -1;
    }

    /* 2. get the target intf config and assign the new value. */
    vtss_appl_ospf_intf_conf_t conf, orig_conf;
    if (vtss_appl_ospf_intf_conf_get(ifindex, &conf) != VTSS_RC_OK) {
        VTSS_TRACE(WARNING) << "get intf " << ifindex << " config failed";
        return -1;
    }

    orig_conf = conf;

    if (conf.dead_interval != table_entry->ospfIfRtrDeadInterval) {
        conf.dead_interval = table_entry->ospfIfRtrDeadInterval;
    }
    if (conf.hello_interval != table_entry->ospfIfHelloInterval) {
        conf.hello_interval = table_entry->ospfIfHelloInterval;
    }
    if (conf.retransmit_interval != table_entry->ospfIfRetransInterval) {
        conf.retransmit_interval = table_entry->ospfIfRetransInterval;
    }
    if (conf.priority != table_entry->ospfIfRtrPriority) {
        conf.priority = table_entry->ospfIfRtrPriority;
    }

    int row = sizeof(auth_type_mapping) / sizeof(auth_type_mapping[0]);
    for (int i = 0; i < row; i++) {
        if (auth_type_mapping[i][1] == table_entry->ospfIfAuthType) {
            conf.auth_type = (vtss_appl_ospf_auth_type_t)auth_type_mapping[i][0];
            break;
        }
    }

    VTSS_TRACE(DEBUG) << "cur intf " << ifindex
                      << " key is:" << table_entry->ospfIfAuthKey;
    if (strlen(table_entry->ospfIfAuthKey) != 0) {
        strncpy(conf.auth_key, table_entry->ospfIfAuthKey,
                VTSS_APPL_OSPF_AUTH_SIMPLE_KEY_MAX_LEN);
        conf.auth_key[VTSS_APPL_OSPF_AUTH_SIMPLE_KEY_MAX_LEN] = '\0';
        VTSS_TRACE(DEBUG) << "set intf " << ifindex << " key "
                          << table_entry->ospfIfAuthKey;
    }

    /* 3. set the target intf config */
    if (memcmp(&orig_conf, &conf, sizeof(orig_conf))) {
        if ((vtss_appl_ospf_intf_conf_set(ifindex, &conf)) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "set intf " << ifindex << " config failed";
            return -1;
        }
    }

    // Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfIfMetricTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfMetricTableEntry_getfirst(ospfIfMetricTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << __func__ << " enter";

    table_entry->ospfIfMetricAddressLessIf = 0;
    table_entry->ospfIfMetricIpAddress = 0;
    table_entry->ospfIfMetricTOS = 0;

    return ospfIfMetricTableEntry_get(table_entry, true);
}

/**
  * \brief Get/Getnext table entry of ospfIfMetricTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfMetricTableEntry_get(ospfIfMetricTable_entry_t *table_entry, int getnext)
{
    vtss_ifindex_t ifindex;
    vtss_appl_ospf_interface_status_t entry = {};
    VTSS_TRACE(DEBUG) << __func__ << " enter getnext:" << getnext;
    VTSS_TRACE(DEBUG) << " key:"
                      << vtss::AsIpv4(table_entry->ospfIfMetricIpAddress);
    /* MIB uses intf address and intf index as key */
    /* The key handling is the same as ospfIfTable */

    if(!getnext) {
        if (table_entry->ospfIfMetricTOS != 0){
            VTSS_TRACE(DEBUG) << "get TOS failed";
            return -1;
        }
        /* 1. get case - try to get the ifindex from ip addr or ifindex */
        if (table_entry->ospfIfMetricIpAddress != 0 &&
            table_entry->ospfIfMetricAddressLessIf == 0) {

            mesa_ip_addr_t if_ip;
            vtss_appl_ip_if_status_t if_status = {};

            if_ip.type = MESA_IP_TYPE_IPV4;
            if_ip.addr.ipv4 = (mesa_ipv4_t)table_entry->ospfIfMetricIpAddress;

            /* Find out ifindex from the ip addr */
            if (vtss_appl_ip_if_status_find(&if_ip, &if_status) != VTSS_RC_OK) {
                VTSS_TRACE(DEBUG) << "get ip if from addr " << vtss::AsIpv4(table_entry->ospfIfMetricIpAddress) << " failed";
                return -1;
            }

            if (!vtss_ifindex_is_vlan(if_status.ifindex)) {
                VTSS_TRACE(DEBUG) << "ifindex (" << if_status.ifindex << ") is not a VLAN";
                return -1;
            }

            ifindex = if_status.ifindex;
        } else if (table_entry->ospfIfMetricIpAddress == 0 && table_entry->ospfIfMetricAddressLessIf != 0) {
            ifindex = vtss_ifindex_cast_from_u32_0(table_entry->ospfIfMetricAddressLessIf);
        } else {
            VTSS_TRACE(DEBUG)
                << "get function param error";
            return -1;
        }
    } else {
        /* 2. get next case - try to find the next valid entry's ifindex */
        vtss_ifindex_t ifindex_1 =
            vtss_ifindex_cast_from_u32_0(table_entry->ospfIfMetricAddressLessIf);
        mesa_ipv4_t if_addr,if_addr_1;
        if_addr_1 = table_entry->ospfIfMetricIpAddress;

        if (table_entry->ospfIfMetricIpAddress != 0) {
            // if ip address is not zero, set ifindex to the max value
            ifindex_1 = vtss_ifindex_cast_from_u32_0(0xFFFFFFFF);
        }

        VTSS_TRACE(DEBUG) << "get next from intf " << vtss::AsIpv4(if_addr_1) << "/ " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex_1));

        if (vtss_appl_ospf_interface_itr2(&if_addr_1, &if_addr, &ifindex_1, &ifindex) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get next intf from intf " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex_1)) << " failed";
            return -1;
        }
    }

    /* 3. from the above the ifindex is got, now get the intf status. */
    VTSS_TRACE(DEBUG) << "get intf " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " status";
    if (vtss_appl_ospf_interface_status_get(ifindex, &entry) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get intf " << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " status failed";
        return -1;
    }

    VTSS_TRACE(DEBUG) << "intf " << ifindex << " fill data";

    /* 4. fillin the key */

    /*Descr. For the purpose of easing the instancing of
    addressed and addressless interfaces;this
    variable takes the value 0 on interfaces with
    IP addresses and the corresponding value of
    ifIndex for interfaces having no IP address.*/
    if (entry.status == false || vtss_ifindex_is_frr_vlink(ifindex)) {
        table_entry->ospfIfMetricIpAddress = 0;
        table_entry->ospfIfMetricAddressLessIf =
                (int32_t)vtss_ifindex_cast_to_u32(ifindex);
    } else {
        table_entry->ospfIfMetricIpAddress = entry.network.address;
        table_entry->ospfIfMetricAddressLessIf = 0;
    }

    /* 5. fillin the data */

    /*descr.  The metric of using this Type of Service on
      this interface.  The default value of the TOS 0
      metric is 10^8 / ifSpeed. */
    table_entry->ospfIfMetricValue = entry.cost;  // get it from status

    table_entry->ospfIfMetricStatus = 1;  // {1 active} {2 notInService} {3
                                          // notReady} {4 createAndGo} {5
                                          // createAndWait} {6 destroy}
    table_entry->ospfIfMetricTOS = 0;     // current TOS 0
    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of ospfIfMetricTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfIfMetricTableEntry_set(ospfIfMetricTable_entry_t *table_entry)
{
    vtss_ifindex_t ifindex;

    VTSS_TRACE(DEBUG) << __func__ << " enter";

    /* MIB uses intf address and intf index as key */

    /* 1. get the ifindex */
    if (table_entry->ospfIfMetricIpAddress != 0) {
        mesa_ip_addr_t if_addr;
        /* got ospfIfIpAddress. ospfAddressLessIf(ifindex) is 0.
           appl uses ifindex as key. Find out ifindex from the ip addr */
        vtss_appl_ip_if_status_t if_status = {};
        if_addr.type = MESA_IP_TYPE_IPV4;
        if_addr.addr.ipv4 = (mesa_ipv4_t)table_entry->ospfIfMetricIpAddress;

        if (vtss_appl_ip_if_status_find(&if_addr, &if_status) != VTSS_RC_OK) {
            VTSS_TRACE(WARNING) << "get intf status from addr " << vtss::AsIpv4(table_entry->ospfIfMetricIpAddress) << " failed";
            return -1;
        }

        if (!vtss_ifindex_is_vlan(if_status.ifindex)) {
            VTSS_TRACE(WARNING) << "ifindex (" << if_status.ifindex << ") is not a VLAN";
            return -1;
        }

        ifindex = if_status.ifindex;
    } else {
        /* got ospfAddressLessIf(ifindex). ospfIfIpAddress is 0. */
        ifindex = vtss_ifindex_cast_from_u32_0(
                table_entry->ospfIfMetricAddressLessIf);
    }

    /* 2. get the target intf config and assign the new value. */
    vtss_appl_ospf_intf_conf_t conf, orig_conf;
    if (vtss_appl_ospf_intf_conf_get(ifindex, &conf) != VTSS_RC_OK) {
        VTSS_TRACE(WARNING) << "get intf " << ifindex << " config failed";
        return -1;
    }

    orig_conf = conf;

    if (table_entry->ospfIfMetricValue == 0) {
        conf.is_specific_cost = false;  // auto-cost
        conf.cost = 0;
    } else {
        conf.is_specific_cost = true;  // specified cost
        conf.cost = table_entry->ospfIfMetricValue;
    }

    /* 3. set the target intf config */
    if (memcmp(&orig_conf, &conf, sizeof(orig_conf))) {
        if (vtss_appl_ospf_intf_conf_set(ifindex, &conf) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "set intf " << ifindex << " config failed";
            return -1;
        }
    }

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfVirtIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtIfTableEntry_getfirst(ospfVirtIfTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << __func__ << " enter";

    table_entry->ospfVirtIfAreaId = 0;
    table_entry->ospfVirtIfNeighbor = 0;

    return ospfVirtIfTableEntry_get(table_entry, true);
}

/**
  * \brief Get/Getnext table entry of ospfVirtIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtIfTableEntry_get(ospfVirtIfTable_entry_t *table_entry, int getnext)
{
    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id;
    vtss_appl_ospf_router_id_t router_id;
    VTSS_TRACE(DEBUG) << __func__ << " enter";

    if (getnext) {
        mesa_rc rc = vtss_appl_ospf_vlink_itr(
                &id, &id, &table_entry->ospfVirtIfAreaId, &area_id,
                &table_entry->ospfVirtIfNeighbor, &router_id);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "get next virif from area "
                              << vtss::AsIpv4(table_entry->ospfVirtIfAreaId)
                              << "router id "
                              << vtss::AsIpv4(table_entry->ospfVirtIfNeighbor)
                              << " failed";
            return -1;
        }
    } else {
        area_id = table_entry->ospfVirtIfAreaId;
        router_id = table_entry->ospfVirtIfNeighbor;
    }
    vtss_appl_ospf_vlink_conf_t conf;
    mesa_rc rc = vtss_appl_ospf_vlink_conf_get(id, area_id, router_id, &conf);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "get virif config " << area_id << "/"
                            << router_id << " failed";
        return -1;
    }

    table_entry->ospfVirtIfAreaId = area_id;
    table_entry->ospfVirtIfNeighbor = router_id;
    table_entry->ospfVirtIfHelloInterval = conf.hello_interval;
    table_entry->ospfVirtIfRtrDeadInterval = conf.dead_interval;
    table_entry->ospfVirtIfRetransInterval = conf.retransmit_interval;
    table_entry->ospfVirtIfTransitDelay = 1;  // 1 second

    int row = sizeof(auth_type_mapping) / sizeof(auth_type_mapping[0]);
    for (int i = 0; i < row; i++) {
        if (auth_type_mapping[i][0] == conf.auth_type) {
            table_entry->ospfVirtIfAuthType = auth_type_mapping[i][1];
            break;
        }
    }
    /* Descr. When read, ospfIfAuthKey always returns an octet
        string of length zero. */
    strcpy(table_entry->ospfVirtIfAuthKey, "");
    table_entry->ospfVirtIfAuthKey_len = strlen(table_entry->ospfVirtIfAuthKey);

    table_entry->ospfVirtIfStatus = 1;  //{1 active} {2 notInService} {3
                                        //notReady} {4 createAndGo} {5
                                        //createAndWait} {6 destroy}


    // Lookup IP by Neighbor ID
    table_entry->ospfVirtIfState = 1;  //{1 down} {4 pointToPoint}
    vtss_ifindex_t ifindex = {}, ifindex_1 = {};
    vtss_appl_ospf_interface_status_t entry = {};
    mesa_ipv4_t peer_rid;
    while ((rc = vtss_appl_ospf_interface_itr(&ifindex_1, &ifindex)) == VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "found next ifindex "
                          << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex));
        if (!vtss_ifindex_is_frr_vlink(ifindex)) {
            ifindex_1 = ifindex;
            continue;
        }
        VTSS_TRACE(DEBUG) << "get intf "
                          << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " status";
        rc = vtss_appl_ospf_interface_status_get(ifindex, &entry);
        if (rc != VTSS_RC_OK) {
            /* the virtual link may not build yet */
            VTSS_TRACE(DEBUG)
                    << "get intf " << ifindex << " status failed rc " << rc;
            return 0;
        }
        VTSS_TRACE(DEBUG) << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << "/"
                          << vtss::AsIpv4(entry.vlink_peer_addr) << "/"
                          << vtss::AsIpv4(table_entry->ospfVirtIfNeighbor);
        // find router id for the ip
        peer_rid = vtss_appl_ospf_nbr_lookup_id_by_addr(entry.vlink_peer_addr);
        VTSS_TRACE(DEBUG) << "peer rid " << vtss::AsIpv4(peer_rid);
        if (peer_rid != table_entry->ospfVirtIfNeighbor) {
            ifindex_1 = ifindex;
            continue;
        }
        VTSS_TRACE(DEBUG) << "get intf "
            << vtss::AsInt(vtss_ifindex_cast_to_u32(ifindex)) << " state: " << entry.state;
        table_entry->ospfVirtIfState =
                entry.state == VTSS_APPL_OSPF_INTERFACE_POINT2POINT ? 4 : 1;
        break;
    }

    /* unsupported */
    // table_entry->ospfVirtIfEvents = ;
    // table_entry->ospfVirtIfLsaCount = ;
    // table_entry->ospfVirtIfLsaCksumSum = ;

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of ospfVirtIfTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtIfTableEntry_set(ospfVirtIfTable_entry_t *table_entry)
{
    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id;
    vtss_appl_ospf_router_id_t router_id;
    VTSS_TRACE(DEBUG) << __func__ << " enter";

    area_id = table_entry->ospfVirtIfAreaId;
    router_id = table_entry->ospfVirtIfNeighbor;

    vtss_appl_ospf_vlink_conf_t conf, orig_conf;
    mesa_rc rc = vtss_appl_ospf_vlink_conf_get(id, area_id, router_id, &conf);
    if (rc != VTSS_RC_OK) {
        // Get the default setting
        rc = frr_ospf_vlink_conf_def(&id, &area_id, &router_id, &conf);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(WARNING) << "get vlink default intf config " << area_id << "/"
                            << router_id << " failed";
            return -1;
        }
        // Add new entry
        rc = vtss_appl_ospf_vlink_conf_add(id, area_id, router_id, &conf);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(WARNING) << "add vlink intf config " << area_id << "/"
                            << router_id << " failed";
            return -1;
        }
    }
    orig_conf = conf;

    conf.hello_interval = table_entry->ospfVirtIfHelloInterval;
    conf.dead_interval = table_entry->ospfVirtIfRtrDeadInterval;
    conf.retransmit_interval = table_entry->ospfVirtIfRetransInterval;

    int row = sizeof(auth_type_mapping) / sizeof(auth_type_mapping[0]);
    for (int i = 0; i < row; i++) {
        if (auth_type_mapping[i][1] == table_entry->ospfVirtIfAuthType) {
            conf.auth_type = (vtss_appl_ospf_auth_type_t)auth_type_mapping[i][0];
            break;
        }
    }

    /* 3. set the target intf config */
    if (memcmp(&orig_conf, &conf, sizeof(orig_conf))) {
        rc = vtss_appl_ospf_vlink_conf_set(id, area_id, router_id, &conf);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(WARNING) << "set vlink intf config " << area_id << "/"
                                << router_id << " failed";
            return -1;
        }
    }
    /* unsupported */
    // table_entry->ospfVirtIfAuthKey
    // table_entry->ospfVirtIfTransitDelay

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

static int __ospfNbrTableEntry_get(ospfNbrTable_entry_t *table_entry, int getnext, int getfirst)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID, next_id;
    mesa_ipv4_t *cur_nbr_ip_p = NULL, cur_nbr_ip, next_nbr_ip;
    vtss_ifindex_t *cur_if_p = NULL, cur_if, next_if;
    vtss_appl_ospf_neighbor_status_t entry;
    bool found = false;

    if (!getfirst) {
        cur_nbr_ip_p = &cur_nbr_ip;
        cur_nbr_ip = table_entry->ospfNbrIpAddr;
    }

    // table_entry->ospfNbrAddressLessIndex must be zero for SNMP get operation
    if (!getnext && !getfirst && table_entry->ospfNbrAddressLessIndex) {
        return -1;
    }

    while (vtss_appl_ospf_neighbor_status_itr(&cur_id, &next_id , cur_nbr_ip_p, &next_nbr_ip, cur_if_p, &next_if) == VTSS_RC_OK) {

        if (next_id != cur_id) {
            return -1;
        }
        if (!cur_nbr_ip_p) {
            cur_nbr_ip_p = &cur_nbr_ip;
        }
        if (!cur_if_p) {
            cur_if_p = &cur_if;
        }

        cur_nbr_ip = next_nbr_ip;
        cur_if = next_if;

        if (vtss_ifindex_is_frr_vlink(cur_if)) {
            VTSS_TRACE(DEBUG) << "skip virtual link interface.";
            continue;
        }

        if (getfirst) {
            VTSS_TRACE(DEBUG) << "get first neighbor entry: " << vtss::AsIpv4(cur_nbr_ip);
            found = true;
            break;
        } else if (!getnext && cur_nbr_ip == table_entry->ospfNbrIpAddr) {
            VTSS_TRACE(DEBUG) << "find current neighbor entry: " << vtss::AsIpv4(cur_nbr_ip);
            found = true;
            break;
        } else if (getnext && cur_nbr_ip != table_entry->ospfNbrIpAddr) {
            VTSS_TRACE(DEBUG) << "find next neighbor entry: " << vtss::AsIpv4(cur_nbr_ip);
            VTSS_ASSERT(cur_nbr_ip >= table_entry->ospfNbrIpAddr);
            found = true;
            break;
        }
    }

    if (!found || vtss_appl_ospf_neighbor_status_get(cur_id, VTSS_APPL_OSPF_DONTCARE_NID, cur_nbr_ip, cur_if,
                                                     &entry) != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "cannot find corresponding neighbor.";
        return -1;
    }

    if (getnext || getfirst) {
        table_entry->ospfNbrIpAddr = entry.ip_addr;
        table_entry->ospfNbrAddressLessIndex = 0; //always with IP
    }

    table_entry->ospfNbrRtrId = entry.neighbor_id;
    table_entry->ospfNbrOptions = entry.options;
    table_entry->ospfNbrPriority = entry.priority;
    table_entry->ospfNbrState = (entry.state > 1) ? (entry.state - 1) : 0; /* map to the MIB value */
    table_entry->ospfNbrEvents = 0; /* state_change_counter is not implemented in the access layer */
    table_entry->ospfNbrLsRetransQLen = 0; /* link_state_retransmission_list_counter is not implemented in the access layer */
    table_entry->ospfNbmaNbrStatus = 1;
    table_entry->ospfNbmaNbrPermanence = 2; /* static */
    table_entry->ospfNbrHelloSuppressed = 2; /* false */
    table_entry->ospfNbrRestartHelperStatus = 1; /* not supported, fixed value */
    table_entry->ospfNbrRestartHelperAge = 0; /* not supported */
    table_entry->ospfNbrRestartHelperExitReason = 1; /* not supported, fixed value as none */

    return 0;
}

/**
  * \brief Get first table entry of ospfNbrTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfNbrTableEntry_getfirst(ospfNbrTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    if (__ospfNbrTableEntry_get(table_entry, false, true) < 0) {
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";

    return 0;
}

/**
  * \brief Get/Getnext table entry of ospfNbrTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfNbrTableEntry_get(ospfNbrTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    if (__ospfNbrTableEntry_get(table_entry, getnext, false) < 0) {
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";

    return 0;
}

/**
  * \brief Set table entry of ospfNbrTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfNbrTableEntry_set(ospfNbrTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    return -1;
}


static int __ospfVirtNbrTableEntry_get(ospfVirtNbrTable_entry_t *table_entry, int getnext, int getfirst)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID, next_id;
    vtss_appl_ospf_area_id_t *cur_transit_area_id_p = NULL, cur_transit_area_id, next_transit_area_id;
    vtss_appl_ospf_router_id_t *cur_nbr_id_p = NULL, cur_nbr_id, next_nbr_id;
    mesa_ipv4_t *cur_nbr_ip_p = NULL, cur_nbr_ip, next_nbr_ip;
    vtss_ifindex_t *cur_if_p = NULL, cur_if, next_if;
    vtss_appl_ospf_neighbor_status_t entry;
    bool found = false;

    if (!getfirst) {
        cur_nbr_id_p = &cur_nbr_id;
        cur_nbr_id = table_entry->ospfVirtNbrRtrId;

        cur_transit_area_id_p = &cur_transit_area_id;
        cur_transit_area_id = table_entry->ospfVirtNbrArea;
    }

    while (vtss_appl_ospf_neighbor_status_itr3(&cur_id, &next_id , cur_transit_area_id_p, &next_transit_area_id, cur_nbr_id_p, &next_nbr_id, cur_nbr_ip_p, &next_nbr_ip, cur_if_p, &next_if) == VTSS_RC_OK) {

        if (next_id != cur_id) {
            return -1;
        }
        if (!cur_nbr_id_p) {
            cur_nbr_id_p = &cur_nbr_id;
        }
        if (!cur_transit_area_id_p) {
            cur_transit_area_id_p = &cur_transit_area_id;
        }
        if (!cur_nbr_ip_p) {
            cur_nbr_ip_p = &cur_nbr_ip;
        }
        if (!cur_if_p) {
            cur_if_p = &cur_if;
        }

        cur_nbr_id = next_nbr_id;
        cur_transit_area_id = next_transit_area_id;
        cur_nbr_ip = next_nbr_ip;
        cur_if = next_if;

        VTSS_TRACE(DEBUG) << "iterator result, id: " << cur_nbr_id << " ip: " << cur_nbr_ip;
        if (vtss_appl_ospf_neighbor_status_get(cur_id, cur_nbr_id, cur_nbr_ip, cur_if, &entry) != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "cannot get corresponding neighbor.";
            return -1;
        }

        if (!vtss_ifindex_is_frr_vlink(cur_if)) {
            VTSS_TRACE(DEBUG) << "skip none-virtual link interface.";
            continue;
        }

        if (getfirst) {
            VTSS_TRACE(DEBUG) << "get first neighbor entry, transit area:" << cur_transit_area_id << " id:" << vtss::AsIpv4(cur_nbr_id);
            found = true;
            break;
        } else if (!getnext && cur_transit_area_id == table_entry->ospfVirtNbrArea && cur_nbr_id == table_entry->ospfVirtNbrRtrId) {
            VTSS_TRACE(DEBUG) << "find current neighbor entry, transit area:" << cur_transit_area_id << " id:" << vtss::AsIpv4(cur_nbr_id);
            found = true;
            break;
        } else if (getnext && ((cur_transit_area_id != table_entry->ospfVirtNbrArea) || (cur_nbr_id != table_entry->ospfVirtNbrRtrId))) {
            VTSS_TRACE(DEBUG) << "find next neighbor entry, transit area:" << cur_transit_area_id << " id:" << vtss::AsIpv4(cur_nbr_id);
            VTSS_ASSERT((cur_transit_area_id >= table_entry->ospfVirtNbrArea) || (cur_nbr_id >= table_entry->ospfVirtNbrRtrId));
            found = true;
            break;
        }
    }

    if (!found) {
        VTSS_TRACE(DEBUG) << "cannot find corresponding neighbor.";
        return -1;
    }

    if (getnext || getfirst) {
        table_entry->ospfVirtNbrRtrId = entry.neighbor_id;
        table_entry->ospfVirtNbrArea = entry.transit_id;
    } else {
        if ((table_entry->ospfVirtNbrArea != entry.transit_id) || (table_entry->ospfVirtNbrRtrId != entry.neighbor_id)) {
            VTSS_TRACE(DEBUG) << "key is not matched.";
            return -1;
        }
    }

    table_entry->ospfVirtNbrIpAddr = entry.ip_addr;
    table_entry->ospfVirtNbrOptions = entry.options;
    table_entry->ospfVirtNbrState = (entry.state > 1) ? (entry.state - 1) : 0; /* map to the MIB value */
    table_entry->ospfVirtNbrEvents = 0; /* state_change_counter is not implemented in the access layer */
    table_entry->ospfVirtNbrLsRetransQLen = 0; /* link_state_retransmission_list_counter is not implemented in the access layer */
    table_entry->ospfVirtNbrHelloSuppressed = 2; /* false */
    table_entry->ospfVirtNbrRestartHelperStatus = 1; /* not supported, fixed value */
    table_entry->ospfVirtNbrRestartHelperAge = 0; /* not supported */
    table_entry->ospfVirtNbrRestartHelperExitReason = 1; /* not supported, fixed value as none */

    return 0;
}


/**
  * \brief Get first table entry of ospfVirtNbrTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtNbrTableEntry_getfirst(ospfVirtNbrTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    if (__ospfVirtNbrTableEntry_get(table_entry, false, true) < 0) {
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";

    return 0;
}

/**
  * \brief Get/Getnext table entry of ospfVirtNbrTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtNbrTableEntry_get(ospfVirtNbrTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    if (__ospfVirtNbrTableEntry_get(table_entry, getnext, false) < 0) {
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";

    return 0;
}

/**
  * \brief Get first table entry of ospfExtLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfExtLsdbTableEntry_getfirst(ospfExtLsdbTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // Try to find if the first entry is existing
    table_entry->ospfExtLsdbType = VTSS_APPL_OSPF_LSDB_TYPE_EXTERNAL;
    table_entry->ospfExtLsdbLsid = 0;
    table_entry->ospfExtLsdbRouterId = 0;

    if (ospfExtLsdbTableEntry_get(table_entry, false) == 0) {
        // Found the first entry
        VTSS_TRACE(DEBUG) << "exit";
        return 0;
    }

    VTSS_TRACE(DEBUG) << "exit";
    return ospfExtLsdbTableEntry_get(table_entry, true);
}

/**
  * \brief Get/Getnext table entry of ospfExtLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfExtLsdbTableEntry_get(ospfExtLsdbTable_entry_t *table_entry, int getnext)
{
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID, next_id;
    vtss_appl_ospf_area_id_t cur_area_id;
    vtss_appl_ospf_area_id_t area_id;
    vtss_appl_ospf_lsdb_type_t cur_type;
    vtss_appl_ospf_lsdb_type_t type;
    mesa_ipv4_t link_state_id;
    vtss_appl_ospf_router_id_t router_id;
    vtss_appl_ospf_db_general_info_t info;
    mesa_rc rc;

    VTSS_TRACE(DEBUG) << "enter";

    /* Get next entry key. */
    if (getnext) {
        cur_type = frr_ospf_db_type_mapping(table_entry->ospfExtLsdbType);
        rc = vtss_appl_ospf_db_itr(&cur_id, &next_id, &cur_area_id, &area_id,
                                   &cur_type, &type, &table_entry->ospfExtLsdbLsid,
                                   &link_state_id, &table_entry->ospfExtLsdbRouterId, &router_id);
        if (rc != VTSS_RC_OK) {
            VTSS_TRACE(DEBUG) << "exit";
            return rc;
        } else {
            while(type != VTSS_APPL_OSPF_LSDB_TYPE_EXTERNAL) {
                cur_type = frr_ospf_db_type_mapping(table_entry->ospfExtLsdbType);
                rc = vtss_appl_ospf_db_itr(&cur_id, &next_id, &cur_area_id, &area_id,
                                           &cur_type, &type, &table_entry->ospfExtLsdbLsid,
                                           &link_state_id, &table_entry->ospfExtLsdbRouterId, &router_id);
                if (rc != VTSS_RC_OK) {
                    VTSS_TRACE(DEBUG) << "exit";
                    return rc;
                }
            }
        }
        table_entry->ospfExtLsdbType = type;
        table_entry->ospfExtLsdbLsid = link_state_id;
        table_entry->ospfExtLsdbRouterId = router_id;
    }

    /* Get entry data. */
    area_id = 0;
    type = frr_ospf_db_type_mapping(table_entry->ospfExtLsdbType);
    link_state_id = table_entry->ospfExtLsdbLsid;
    router_id = table_entry->ospfExtLsdbRouterId;
    rc = vtss_appl_ospf_db_get(cur_id, area_id, type, link_state_id, router_id, &info);
    if (rc != VTSS_RC_OK) {
        VTSS_TRACE(DEBUG) << "exit";
        return rc;
    }

    /* Update the MIB parameter values */

    /* Sequence */
    table_entry->ospfExtLsdbSequence = info.sequence;

    /* Age */
    table_entry->ospfExtLsdbAge = info.age;

    /* Checksum */
    table_entry->ospfExtLsdbChecksum = info.checksum;

    /* Advertisement */
    table_entry->ospfExtLsdbAdvertisement[0] = '\0';

    /* Advertisement Count */
    table_entry->ospfExtLsdbAdvertisement_len = info.router_link_count;

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfAreaAggregateTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaAggregateTableEntry_getfirst(ospfAreaAggregateTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    VTSS_TRACE(DEBUG) << "exit";
    return ospfAreaAggregateTableEntry_get(table_entry, TRUE);
}

/**
  * \brief Get/Getnext table entry of ospfAreaAggregateTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaAggregateTableEntry_get(ospfAreaAggregateTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";
    BOOL k4_is_valid = true;

    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id = table_entry->ospfAreaAggregateAreaID;
    mesa_ipv4_network_t network = {table_entry->ospfAreaAggregateNet, 0};
    vtss_appl_ospf_area_range_conf_t conf;
    mesa_rc rc = VTSS_RC_ERROR;

    if (vtss_conv_ipv4mask_to_prefix(table_entry->ospfAreaAggregateMask, &network.prefix_size)) {
        if (!getnext) {
            VTSS_TRACE(DEBUG) << "Error on converting 'ospfAreaAggregateMask' {"
                << vtss::AsIpv4(table_entry->ospfAreaAggregateMask) << "} to prefix";
            return -1;
        }
        k4_is_valid = false;
    }

    /* OSPF isn't enabled. */
    if (vtss_appl_ospf_get(id) != VTSS_RC_OK) {
        return -1;
    }

    if (!getnext) { // get
        if (table_entry->ospfAreaAggregateLsdbType != 3) {
            T_DG(FRR_TRACE_GRP_SNMP, "rc: %s", error_txt(rc));
            return -1;
        }
    } else {    // get next
        vtss_appl_ospf_id_t *cur_id_p = &id;
        vtss_appl_ospf_area_id_t *cur_area_id_p = &area_id;
        mesa_ipv4_network_t *cur_network_p = &network;
        int32_t   cur_lsdb_type = table_entry->ospfAreaAggregateLsdbType;

        if (cur_lsdb_type > 3) { // use area_id++ and network with null as the keys
            area_id++;
            cur_network_p = NULL;
        } else if (cur_lsdb_type < 3){ // use area_id and network with null as key
            cur_network_p = NULL;
        } else  if (!k4_is_valid) {
            // find the largest prefix smaller than table_entry->ospfAreaAggregateMask
            u32 prefix = 0;
            u32 test_mask = 0;

            VTSS_TRACE(INFO)
                << ", table_entry->ospfAreaAggregateMask = "
                <<  vtss::AsIpv4(table_entry->ospfAreaAggregateMask);
            for (int i = 31; i >= 0; --i) {
                test_mask |= 1 << i;
                VTSS_TRACE(DEBUG) << "test_mask = 0x"
                    << vtss::FormatHex<const uint32_t>(test_mask, 'a', 0, 0, '0');
                if (test_mask > table_entry->ospfAreaAggregateMask) {
                    // to get the prefix smaller than table_entry->ospfAreaAggregateMask,
                    //'prefix' need to minus 1
                    prefix = 32 - i - 1;
                    VTSS_TRACE(INFO) << "prefix = " << prefix;
                    break;
                }
            }
            network.prefix_size = prefix;
            VTSS_TRACE(INFO) << "'ospfAreaAggregateMask' {"
                << vtss::AsIpv4(table_entry->ospfAreaAggregateMask) << "} can't"
                " be converted to prefix, choose {" << network.prefix_size
                << "} for iteration";
        }

        if (vtss_appl_ospf_area_range_conf_itr(cur_id_p, &id, cur_area_id_p, &area_id, cur_network_p, &network)) {
            return -1;
        }

        /* output the keys */
        table_entry->ospfAreaAggregateMask = vtss_ipv4_prefix_to_mask(network.prefix_size);
        table_entry->ospfAreaAggregateAreaID = area_id;
        table_entry->ospfAreaAggregateLsdbType = 3;
        table_entry->ospfAreaAggregateNet = network.address;
    }

    if (vtss_appl_ospf_area_range_conf_get(id, area_id, network, &conf)) {
        return -1;
    }

    table_entry->ospfAreaAggregateStatus = 1;
    table_entry->ospfAreaAggregateEffect = conf.is_advertised ? 1 : 2;

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Set table entry of ospfAreaAggregateTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaAggregateTableEntry_set(ospfAreaAggregateTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    vtss_appl_ospf_id_t id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id = table_entry->ospfAreaAggregateAreaID;
    mesa_ipv4_network_t network = {table_entry->ospfAreaAggregateNet, 0};
    vtss_appl_ospf_area_range_conf_t conf;
    mesa_rc rc = VTSS_RC_ERROR;

    (void)vtss_conv_ipv4mask_to_prefix(table_entry->ospfAreaAggregateMask, &network.prefix_size);

    if ((rc = vtss_appl_ospf_area_range_conf_get(id, area_id, network, &conf))) {
        T_EG(FRR_TRACE_GRP_SNMP, "get 'OSPF area range' failed: %s", error_txt(rc));
        return -1;
    }

    conf.is_advertised = table_entry->ospfAreaAggregateEffect == 1 ? true : false;
    if ((rc = vtss_appl_ospf_area_range_conf_set(id, area_id, network, &conf))) {
        T_EG(FRR_TRACE_GRP_SNMP, "set 'is_advertised' failed: %s", error_txt(rc));
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";
    return 0;
}

/**
  * \brief Get first table entry of ospfLocalLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfLocalLsdbTableEntry_getfirst(ospfLocalLsdbTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfLocalLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfLocalLsdbTableEntry_get(ospfLocalLsdbTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get first table entry of ospfVirtLocalLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtLocalLsdbTableEntry_getfirst(ospfVirtLocalLsdbTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfVirtLocalLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfVirtLocalLsdbTableEntry_get(ospfVirtLocalLsdbTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get first table entry of ospfAsLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAsLsdbTableEntry_getfirst(ospfAsLsdbTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

/**
  * \brief Get/Getnext table entry of ospfAsLsdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAsLsdbTableEntry_get(ospfAsLsdbTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    VTSS_TRACE(DEBUG) << "exit";
    return -1;
}

static BOOL lsa_count_get_by_type(
        const vtss_appl_ospf_area_status_t *const status,
        const int32_t type, uint32_t *const count)
{
    switch (type) {
    case 1:
        *count = status->router_lsa_count;
        break;
    case 2:
        *count = status->network_lsa_count;
        break;
    case 3:
        *count = status->summary_lsa_count;
        break;
    case 4:
        *count = status->asbr_summary_lsa_count;
        break;
    default:
        VTSS_TRACE(ERROR) << "unknown type-" << (uint32_t)type;
        return FALSE;
        /* ignore default case to catch compile warning if any prtocol is
         * missing */
    }
    return TRUE;
}

/**
  * \brief Get first table entry of ospfAreaLsaCountTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaLsaCountTableEntry_getfirst(ospfAreaLsaCountTable_entry_t *table_entry)
{
    VTSS_TRACE(DEBUG) << "enter";

    VTSS_TRACE(DEBUG) << "invoke get function and return";
    return ospfAreaLsaCountTableEntry_get(table_entry, TRUE);
}

/**
  * \brief Get/Getnext table entry of ospfAreaLsaCountTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ospfAreaLsaCountTableEntry_get(ospfAreaLsaCountTable_entry_t *table_entry, int getnext)
{
    VTSS_TRACE(DEBUG) << "enter";
    vtss_appl_ospf_id_t cur_id = FRR_OSPF_DEFAULT_INSTANCE_ID;
    vtss_appl_ospf_area_id_t area_id = table_entry->ospfAreaLsaCountAreaId;
    vtss_appl_ospf_area_status_t status;
#define MIN_TYPE 1
#define MAX_TYPE 4

    VTSS_TRACE(INFO) << "getnext = " << getnext
        << " key " << vtss::AsIpv4(table_entry->ospfAreaLsaCountAreaId) << "."
        << (uint32_t)table_entry->ospfAreaLsaCountLsaType;
    if (!getnext) { // get
        // supported types are {routerLink (1), networkLink (2),
        //summaryLink (3), asSummaryLink (4)}
        if (table_entry->ospfAreaLsaCountLsaType < MIN_TYPE ||
                table_entry->ospfAreaLsaCountLsaType > MAX_TYPE) {
            return -1;
        }
    } else {    // get next
        vtss_appl_ospf_area_id_t *cur_area_id_p = &area_id;
        int32_t   tmp_type = table_entry->ospfAreaLsaCountLsaType;
        if (table_entry->ospfAreaLsaCountLsaType >= MAX_TYPE) {
            // use area_id to iterate and assign 1 to
            // ospfAreaLsaCountLsaType for output
            tmp_type = 1;
        } else if (table_entry->ospfAreaLsaCountLsaType < MIN_TYPE){
            // use previous area_id to iterate next key and assign 1 to
            // ospfAreaLsaCountLsaType for output
            if (area_id) {
                --area_id;
            } else {
                cur_area_id_p = NULL;
            }
            tmp_type = 1;
        } else {
            // use the area_id to get the status and return the output if successful
            if (!vtss_appl_ospf_area_status_get(cur_id, area_id, &status)) {
                table_entry->ospfAreaLsaCountLsaType++;

                VTSS_TRACE(INFO) << "get type-" << (uint32_t)table_entry->ospfAreaLsaCountLsaType
                                << " LSAs' count";
                if (!lsa_count_get_by_type(&status, table_entry->ospfAreaLsaCountLsaType,
                            &table_entry->ospfAreaLsaCountNumber)){
                    return -1;
                }
                return 0;
            }
        }

        VTSS_TRACE(INFO) << "iterate from  {" << cur_id << ", "
                        << vtss::AsIpv4(*cur_area_id_p)
                        <<"}";
        if (vtss_appl_ospf_area_status_itr(&cur_id, &cur_id, cur_area_id_p,
                                            &area_id)) {
            return -1;
        }
        table_entry->ospfAreaLsaCountAreaId = area_id;
        table_entry->ospfAreaLsaCountLsaType =  tmp_type;
    }

    VTSS_TRACE(INFO) << "get stastus from  {" << cur_id << ", "
                    << vtss::AsIpv4(area_id) << "}";
    if (vtss_appl_ospf_area_status_get(cur_id, area_id, &status)) {
        return -1;
    }

    VTSS_TRACE(INFO) << "get type-" << (uint32_t)table_entry->ospfAreaLsaCountLsaType
                    << " LSAs' count";
    if (!lsa_count_get_by_type(&status, table_entry->ospfAreaLsaCountLsaType,
                &table_entry->ospfAreaLsaCountNumber)){
        return -1;
    }

    VTSS_TRACE(DEBUG) << "exit";
#undef MIN_TYPE
#undef MAX_TYPE
    return 0;
}


