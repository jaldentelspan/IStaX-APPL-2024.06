/*
 Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.2 2007/09/04 06:33:18 pchen Exp $
 */

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include "vtss_os_wrapper_snmp.h"
#include "msg_api.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"
#include "vtss_appl_serialize.hxx"
#ifdef VTSS_SW_OPTION_ETH_LINK_OAM
#include "vtss_eth_link_oam_api.h"
#include "vtss_eth_link_oam_base_api.h"
#include "eth_link_oam_api.h"
#include "vtss_eth_link_oam_control_api.h"
#include "cli_trace_def.h"
#include "dot3OamMIB.h"
#endif
#include "mibContextTable.h"  // For mibContextTable_register()
#include "port_api.h"         // For port_ifindex_valid()

/*
 * +++ Start (Internal implementation declarations)
 */

/*
 * Get interface information from ifindex for tables which are indexing by ifIndex.
 */
int _dot3OamMib_get_ifTableIndex_info(int ifindex, iftable_info_t  *iftable_info)
{
    if (get_ifTableIndex_info (ifindex, iftable_info) == FALSE) {
        return SNMP_NOSUCHINSTANCE;
    }
    if (iftable_info->type != IFTABLE_IFINDEX_TYPE_PORT) {
        return SNMP_NOSUCHINSTANCE;
    }
    if (msg_switch_exists (iftable_info->isid) == FALSE) {
        return SNMP_NOSUCHINSTANCE;
    }

    return SNMP_ERR_NOERROR;
}

/*******************************************************************************
*Purpose    : Retrieves the Local OAM Table entries for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamTable_entry(iftable_info_t *iftable_info, dot3OamTable_entry_t *table_entry)
{
    vtss_eth_link_oam_conf_t            conf;
    vtss_eth_link_oam_info_tlv_t        local_info;
    vtss_eth_link_oam_discovery_state_t state;
    u16                                 mtu_size;
    u16                                 temp;
    u8                                  func_support = 0;

    memset(&conf, 0, sizeof(conf));
    memset(&local_info, 0, sizeof(local_info));
    memset(table_entry, 0, sizeof(dot3OamTable_entry_t));

    if (eth_link_oam_mgmt_port_conf_get(iftable_info->isid, iftable_info->if_id, &conf) == VTSS_RC_OK) {
        if (eth_link_oam_client_port_local_info_get (iftable_info->isid, iftable_info->if_id, &local_info) == VTSS_RC_OK) {
            table_entry->dot3OamAdminState = conf.oam_control ? LINK_OAM_ADMIN_ENABLED : LINK_OAM_ADMIN_DISABLED;
            if (eth_link_oam_control_layer_port_discovery_state_get(iftable_info->isid, iftable_info->if_id, &state) != VTSS_RC_OK) {
                return FALSE;
            } else {
                switch (state) {
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_FAULT:
                    table_entry->dot3OamOperStatus = LINK_OAM_LINK_FAULT;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_ACTIVE_SEND_LOCAL:
                    table_entry->dot3OamOperStatus = LINK_OAM_ACTIVE_SEND_LOCAL;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_PASSIVE_WAIT:
                    table_entry->dot3OamOperStatus = LINK_OAM_PASSIVE_WAIT;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_LOCAL_REMOTE:
                    table_entry->dot3OamOperStatus = LINK_OAM_SEND_LOCAL_AND_REMOTE;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_LOCAL_REMOTE_OK:
                    table_entry->dot3OamOperStatus = LINK_OAM_SEND_LOCAL_AND_REMOTE_OK;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_ANY:
                    table_entry->dot3OamOperStatus = LINK_OAM_OPERATIONAL;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_LAST:
                    table_entry->dot3OamOperStatus = LINK_OAM_DISABLED;
                    break;
                default:
                    table_entry->dot3OamOperStatus = LINK_OAM_DISABLED;
                }
            }
            table_entry->dot3OamMode = IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_MODE) ? LINK_OAM_ACTIVE : LINK_OAM_PASSIVE;
            memcpy(&mtu_size, local_info.oampdu_conf, sizeof(u16));
            mtu_size = NET2HOSTS(mtu_size);
            table_entry->dot3OamMaxOamPduSize = mtu_size;
            memcpy(&temp, local_info.revision, sizeof(temp));
            temp = NET2HOSTS(temp);
            table_entry->dot3OamConfigRevision = temp;
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_UNI_DIRECTIONAL_SUPPORT)) {
                func_support |= LINK_OAM_UNI_DIRECTIONAL_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_REMOTE_LOOP_BACK_CONTROL_SUPPORT)) {
                func_support |= LINK_OAM_LOOPBACK_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_LINK_EVENTS_SUPPORT)) {
                func_support |= LINK_OAM_EVENT_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_VARIABLE_RETRIEVAL_SUPPORT)) {
                func_support |= LINK_OAM_VARIABLE_SUPPORT;
            }
            table_entry->dot3OamFunctionsSupported = func_support;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}
/*******************************************************************************
*Purpose    : Retrieves the Peer OAM Table entries for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamPeerTable_entry(iftable_info_t *iftable_info, dot3OamPeerTable_entry_t *table_entry)
{
    vtss_eth_link_oam_info_tlv_t        remote_info;
    u8                                  func_support    = 0;
    u16                                 remote_temp     = 0;
    u16                                 remote_mtu_size = 0;

    memset(&remote_info, 0, sizeof(remote_info));

    memset(table_entry, 0, sizeof(dot3OamPeerTable_entry_t));
    if (eth_link_oam_client_port_remote_info_get(iftable_info->isid, iftable_info->if_id,
                                                 &remote_info) != VTSS_RC_OK) {
        return FALSE;
    } else {
        if (eth_link_oam_client_port_remote_mac_addr_info_get(iftable_info->isid, iftable_info->if_id,
                                                              table_entry->dot3OamPeerMacAddress) != VTSS_RC_OK) {
            return FALSE;
        }
        memcpy(&remote_temp, remote_info.revision, sizeof(remote_temp));
        remote_temp = NET2HOSTS(remote_temp);
        memcpy(&remote_mtu_size, remote_info.oampdu_conf, sizeof(u16));
        remote_mtu_size = NET2HOSTS(remote_mtu_size);
    }
    memcpy(table_entry->dot3OamPeerVendorOui, remote_info.oui,
           sizeof(table_entry->dot3OamPeerVendorOui));
    table_entry->dot3OamPeerMode = IS_CONF_ACTIVE(remote_info.oam_conf,
                                                  VTSS_ETH_LINK_OAM_CONF_MODE) ? LINK_OAM_ACTIVE : LINK_OAM_PASSIVE ;
    table_entry->dot3OamPeerMaxOamPduSize = remote_mtu_size;
    table_entry->dot3OamPeerConfigRevision = remote_temp;
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_UNI_DIRECTIONAL_SUPPORT)) {
        func_support |= LINK_OAM_UNI_DIRECTIONAL_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_REMOTE_LOOP_BACK_CONTROL_SUPPORT)) {
        func_support |= LINK_OAM_LOOPBACK_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_LINK_EVENTS_SUPPORT)) {
        func_support |= LINK_OAM_EVENT_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_VARIABLE_RETRIEVAL_SUPPORT)) {
        func_support |= LINK_OAM_VARIABLE_SUPPORT;
    }
    table_entry->dot3OamPeerFunctionsSupported = func_support;
    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM Loopback configuration for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamLoopbackTable_entry(iftable_info_t *iftable_info, dot3OamLoopbackTable_entry_t *table_entry)
{
    vtss_eth_link_oam_loopback_status_t loop_status;
    BOOL                                lb_sup = FALSE;

    memset(table_entry, 0, sizeof(dot3OamLoopbackTable_entry_t));
    if ((eth_link_oam_port_loopback_oper_status_get(iftable_info->isid, iftable_info->if_id, &loop_status) != VTSS_RC_OK) ||
        (eth_link_oam_mgmt_port_remote_loopback_conf_get(iftable_info->isid, iftable_info->if_id, &lb_sup) != VTSS_RC_OK)) {
        return FALSE;
    } else {
        table_entry->dot3OamLoopbackStatus = loop_status;
        table_entry->dot3OamLoopbackIgnoreRx = lb_sup ? LINK_OAM_LOOPBACK_PROCESS : LINK_OAM_LOOPBACK_IGNORE;
    }

    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM statistics information for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamStatsTable_entry(iftable_info_t *iftable_info, dot3OamStatsTable_entry_t *table_entry)
{
    mesa_rc                               rc;
    vtss_eth_link_oam_control_port_conf_t port_stats;


    memset(&port_stats, 0, sizeof(port_stats));
    rc = eth_link_oam_control_layer_port_pdu_stats_get(iftable_info->isid, iftable_info->if_id, &port_stats.oam_stats);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    table_entry->dot3OamInformationRx = port_stats.oam_stats.information_rx;
    table_entry->dot3OamInformationTx = port_stats.oam_stats.information_tx;
    table_entry->dot3OamUniqueEventNotificationRx = port_stats.oam_stats.unique_event_notification_rx;
    table_entry->dot3OamUniqueEventNotificationTx = port_stats.oam_stats.unique_event_notification_tx;
    table_entry->dot3OamDuplicateEventNotificationRx = port_stats.oam_stats.duplicate_event_notification_rx;
    table_entry->dot3OamDuplicateEventNotificationTx = port_stats.oam_stats.duplicate_event_notification_tx;
    table_entry->dot3OamLoopbackControlRx = port_stats.oam_stats.loopback_control_rx;
    table_entry->dot3OamLoopbackControlTx = port_stats.oam_stats.loopback_control_tx;
    table_entry->dot3OamVariableRequestRx = port_stats.oam_stats.variable_request_rx;
    table_entry->dot3OamVariableRequestTx = port_stats.oam_stats.variable_request_tx;
    table_entry->dot3OamVariableResponseRx = port_stats.oam_stats.variable_response_rx;
    table_entry->dot3OamVariableResponseTx = port_stats.oam_stats.variable_response_tx;
    table_entry->dot3OamOrgSpecificRx = port_stats.oam_stats.org_specific_rx;
    table_entry->dot3OamOrgSpecificTx = port_stats.oam_stats.org_specific_tx;
    table_entry->dot3OamUnsupportedCodesRx = port_stats.oam_stats.unsupported_codes_rx;
    table_entry->dot3OamUnsupportedCodesTx = port_stats.oam_stats.unsupported_codes_tx;
    table_entry->dot3OamFramesLostDueToOam = 0;

    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM Event specific Configuration information for a
              particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamEventConfigTable_entry(iftable_info_t *iftable_info, dot3OamEventConfigTable_entry_t *table_entry)
{
    mesa_rc                                                 rc;
    const int                                               endian = 1;
    char                                                    *p = (char *)&endian;
    u64                                                     temp_symbol_period;
    u64                                                     temp_symbol_threshold;
    u8                                                      *temp_ptr = (u8 *)&temp_symbol_period;
    BOOL                                                    little_endian;
    u16                                                     temp_err_frame_secs_summary_window = 0;
    vtss_eth_link_oam_error_frame_event_tlv_t               error_frame_tlv;
    vtss_eth_link_oam_error_frame_event_tlv_t               remote_error_frame_tlv;
    vtss_eth_link_oam_error_frame_period_event_tlv_t        error_frame_period_tlv;
    vtss_eth_link_oam_error_frame_period_event_tlv_t        remote_error_frame_period_tlv;
    vtss_eth_link_oam_error_symbol_period_event_tlv_t       error_symbol_period_tlv;
    vtss_eth_link_oam_error_symbol_period_event_tlv_t       remote_error_symbol_period_tlv;
    vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t  local_secs_info;
    vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t  remote_secs_info;

    memset(&error_symbol_period_tlv, 0, sizeof(error_symbol_period_tlv));
    memset(&remote_error_symbol_period_tlv, 0, sizeof(remote_error_symbol_period_tlv));
    memset(&error_frame_period_tlv, 0, sizeof(error_frame_period_tlv));
    memset(&remote_error_frame_period_tlv, 0, sizeof(remote_error_frame_period_tlv));
    memset(&error_frame_tlv, 0, sizeof(error_frame_tlv));
    memset(&remote_error_frame_tlv, 0, sizeof(remote_error_frame_tlv));
    memset(&local_secs_info, 0, sizeof(local_secs_info));
    memset(&remote_secs_info, 0, sizeof(remote_secs_info));


    rc = eth_link_oam_client_port_symbol_period_error_info_get(iftable_info->isid, iftable_info->if_id,
                                                               &error_symbol_period_tlv,
                                                               &remote_error_symbol_period_tlv);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_client_port_frame_error_info_get(iftable_info->isid, iftable_info->if_id,
                                                       &error_frame_tlv,
                                                       &remote_error_frame_tlv);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_client_port_frame_period_error_info_get(iftable_info->isid, iftable_info->if_id,
                                                              &error_frame_period_tlv,
                                                              &remote_error_frame_period_tlv);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    rc = eth_link_oam_client_port_error_frame_secs_summary_info_get(iftable_info->isid, iftable_info->if_id, &local_secs_info, &remote_secs_info);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    if (*p) {
        little_endian = TRUE;
    } else {
        little_endian = FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(iftable_info->isid, iftable_info->if_id, &temp_symbol_period);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(iftable_info->isid, iftable_info->if_id, &temp_symbol_threshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    if (little_endian) {
        memcpy(&table_entry->dot3OamErrSymPeriodWindowLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowLo));
        temp_ptr = temp_ptr + 4;
        memcpy(&table_entry->dot3OamErrSymPeriodWindowHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowHi));
        temp_ptr = (u8 *)&temp_symbol_threshold;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdLo));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdHi));
    } else {
        memcpy(&table_entry->dot3OamErrSymPeriodWindowHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowHi));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodWindowLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowLo));
        temp_ptr = (u8 *) &temp_symbol_threshold;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdHi));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdLo));
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    table_entry->dot3OamErrSymPeriodEvNotifEnable = TRUE;
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    rc = eth_link_oam_mgmt_port_link_frame_period_error_window_get(iftable_info->isid, iftable_info->if_id, &table_entry->dot3OamErrFramePeriodWindow);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_frame_period_error_threshold_get(iftable_info->isid, iftable_info->if_id, &table_entry->dot3OamErrFramePeriodThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    table_entry->dot3OamErrFramePeriodEvNotifEnable = TRUE;
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    rc = eth_link_oam_mgmt_port_link_error_frame_window_get(iftable_info->isid, iftable_info->if_id, (u16 *)&table_entry->dot3OamErrFrameWindow);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    rc = eth_link_oam_mgmt_port_link_error_frame_threshold_get(iftable_info->isid, iftable_info->if_id, &table_entry->dot3OamErrFrameThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    table_entry->dot3OamErrFrameEvNotifEnable = TRUE;
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_window_get(iftable_info->isid, iftable_info->if_id, &temp_err_frame_secs_summary_window);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->dot3OamErrFrameSecsSummaryWindow = 10 * temp_err_frame_secs_summary_window;
    rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_threshold_get(iftable_info->isid, iftable_info->if_id, (u16 *)&table_entry->dot3OamErrFrameSecsSummaryThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    table_entry->dot3OamErrFrameSecsEvNotifEnable = TRUE;
    table_entry->dot3OamDyingGaspEnable = TRUE;
    table_entry->dot3OamCriticalEventEnable = TRUE;
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    return TRUE;
}
/*
 * --- End (Internal implementation declarations)
 */

/*
 * dot3OamMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3OamMIB_variables_oid[] = { 1, 3, 6, 1, 2, 1, 158 };

/*
 * variable4 dot3OamMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the dot3OamMIB mib section
 */

struct variable4 dot3OamMIB_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3OAMADMINSTATE       1
    {
        DOT3OAMADMINSTATE, ASN_INTEGER, RWRITE, var_dot3OamTable, 4,
        {1, 1, 1, 1}
    },
#define DOT3OAMOPERSTATUS       2
    {
        DOT3OAMOPERSTATUS, ASN_INTEGER, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 2}
    },
#define DOT3OAMMODE     3
    {DOT3OAMMODE, ASN_INTEGER, RWRITE, var_dot3OamTable, 4, {1, 1, 1, 3}},
#define DOT3OAMMAXOAMPDUSIZE        4
    {
        DOT3OAMMAXOAMPDUSIZE, ASN_UNSIGNED, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 4}
    },
#define DOT3OAMCONFIGREVISION       5
    {
        DOT3OAMCONFIGREVISION, ASN_UNSIGNED, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 5}
    },
#define DOT3OAMFUNCTIONSSUPPORTED       6
    {
        DOT3OAMFUNCTIONSSUPPORTED, ASN_OCTET_STR, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 6}
    },
#define DOT3OAMPEERMACADDRESS       7
    {
        DOT3OAMPEERMACADDRESS, ASN_OCTET_STR, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 1}
    },
#define DOT3OAMPEERVENDOROUI        8
    {
        DOT3OAMPEERVENDOROUI, ASN_OCTET_STR, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 2}
    },
#define DOT3OAMPEERVENDORINFO       9
    {
        DOT3OAMPEERVENDORINFO, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 3}
    },
#define DOT3OAMPEERMODE     10
    {
        DOT3OAMPEERMODE, ASN_INTEGER, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 4}
    },
#define DOT3OAMPEERMAXOAMPDUSIZE        11
    {
        DOT3OAMPEERMAXOAMPDUSIZE, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable,
        4, {1, 2, 1, 5}
    },
#define DOT3OAMPEERCONFIGREVISION       12
    {
        DOT3OAMPEERCONFIGREVISION, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable,
        4, {1, 2, 1, 6}
    },
#define DOT3OAMPEERFUNCTIONSSUPPORTED       13
    {
        DOT3OAMPEERFUNCTIONSSUPPORTED, ASN_OCTET_STR, RONLY,
        var_dot3OamPeerTable, 4, {1, 2, 1, 7}
    },
#define DOT3OAMLOOPBACKSTATUS       14
    {
        DOT3OAMLOOPBACKSTATUS, ASN_INTEGER, RWRITE, var_dot3OamLoopbackTable,
        4, {1, 3, 1, 1}
    },
#define DOT3OAMLOOPBACKIGNORERX     15
    {
        DOT3OAMLOOPBACKIGNORERX, ASN_INTEGER, RWRITE,
        var_dot3OamLoopbackTable, 4, {1, 3, 1, 2}
    },
#define DOT3OAMINFORMATIONTX        16
    {
        DOT3OAMINFORMATIONTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 1}
    },
#define DOT3OAMINFORMATIONRX        17
    {
        DOT3OAMINFORMATIONRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 2}
    },
#define DOT3OAMUNIQUEEVENTNOTIFICATIONTX        18
    {
        DOT3OAMUNIQUEEVENTNOTIFICATIONTX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 3}
    },
#define DOT3OAMUNIQUEEVENTNOTIFICATIONRX        19
    {
        DOT3OAMUNIQUEEVENTNOTIFICATIONRX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 4}
    },
#define DOT3OAMDUPLICATEEVENTNOTIFICATIONTX     20
    {
        DOT3OAMDUPLICATEEVENTNOTIFICATIONTX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 5}
    },
#define DOT3OAMDUPLICATEEVENTNOTIFICATIONRX     21
    {
        DOT3OAMDUPLICATEEVENTNOTIFICATIONRX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 6}
    },
#define DOT3OAMLOOPBACKCONTROLTX        22
    {
        DOT3OAMLOOPBACKCONTROLTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 7}
    },
#define DOT3OAMLOOPBACKCONTROLRX        23
    {
        DOT3OAMLOOPBACKCONTROLRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 8}
    },
#define DOT3OAMVARIABLEREQUESTTX        24
    {
        DOT3OAMVARIABLEREQUESTTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 9}
    },
#define DOT3OAMVARIABLEREQUESTRX        25
    {
        DOT3OAMVARIABLEREQUESTRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 10}
    },
#define DOT3OAMVARIABLERESPONSETX       26
    {
        DOT3OAMVARIABLERESPONSETX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 11}
    },
#define DOT3OAMVARIABLERESPONSERX       27
    {
        DOT3OAMVARIABLERESPONSERX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 12}
    },
#define DOT3OAMORGSPECIFICTX        28
    {
        DOT3OAMORGSPECIFICTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 13}
    },
#define DOT3OAMORGSPECIFICRX        29
    {
        DOT3OAMORGSPECIFICRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 14}
    },
#define DOT3OAMUNSUPPORTEDCODESTX       30
    {
        DOT3OAMUNSUPPORTEDCODESTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 15}
    },
#define DOT3OAMUNSUPPORTEDCODESRX       31
    {
        DOT3OAMUNSUPPORTEDCODESRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 16}
    },
#define DOT3OAMFRAMESLOSTDUETOOAM       32
    {
        DOT3OAMFRAMESLOSTDUETOOAM, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 17}
    },
#define DOT3OAMERRSYMPERIODWINDOWHI     33
    {
        DOT3OAMERRSYMPERIODWINDOWHI, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 1}
    },
#define DOT3OAMERRSYMPERIODWINDOWLO     34
    {
        DOT3OAMERRSYMPERIODWINDOWLO, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 2}
    },
#define DOT3OAMERRSYMPERIODTHRESHOLDHI      35
    {
        DOT3OAMERRSYMPERIODTHRESHOLDHI, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 3}
    },
#define DOT3OAMERRSYMPERIODTHRESHOLDLO      36
    {
        DOT3OAMERRSYMPERIODTHRESHOLDLO, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 4}
    },
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
#define DOT3OAMERRSYMPERIODEVNOTIFENABLE        37
    {
        DOT3OAMERRSYMPERIODEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 5}
    },
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
#define DOT3OAMERRFRAMEPERIODWINDOW     38
    {
        DOT3OAMERRFRAMEPERIODWINDOW, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 6}
    },
#define DOT3OAMERRFRAMEPERIODTHRESHOLD      39
    {
        DOT3OAMERRFRAMEPERIODTHRESHOLD, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 7}
    },
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
#define DOT3OAMERRFRAMEPERIODEVNOTIFENABLE      40
    {
        DOT3OAMERRFRAMEPERIODEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 8}
    },
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
#define DOT3OAMERRFRAMEWINDOW       41
    {
        DOT3OAMERRFRAMEWINDOW, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 9}
    },
#define DOT3OAMERRFRAMETHRESHOLD        42
    {
        DOT3OAMERRFRAMETHRESHOLD, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 10}
    },
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
#define DOT3OAMERRFRAMEEVNOTIFENABLE        43
    {
        DOT3OAMERRFRAMEEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 11}
    },
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
#define DOT3OAMERRFRAMESECSSUMMARYWINDOW        44
    {
        DOT3OAMERRFRAMESECSSUMMARYWINDOW, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 12}
    },
#define DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD     45
    {
        DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 13}
    },
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
#define DOT3OAMERRFRAMESECSEVNOTIFENABLE        46
    {
        DOT3OAMERRFRAMESECSEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 14}
    },
#define DOT3OAMDYINGGASPENABLE      47
    {
        DOT3OAMDYINGGASPENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 15}
    },
#define DOT3OAMCRITICALEVENTENABLE  48
    {
        DOT3OAMCRITICALEVENTENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 16}
    },
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
#define DOT3OAMEVENTLOGTIMESTAMP    49
    {
        DOT3OAMEVENTLOGTIMESTAMP, ASN_TIMETICKS, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 2}
    },
#define DOT3OAMEVENTLOGOUI          50
    {
        DOT3OAMEVENTLOGOUI, ASN_OCTET_STR, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 3}
    },
#define DOT3OAMEVENTLOGTYPE         51
    {
        DOT3OAMEVENTLOGTYPE, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 4}
    },
#define DOT3OAMEVENTLOGLOCATION     52
    {
        DOT3OAMEVENTLOGLOCATION, ASN_INTEGER, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 5}
    },
#define DOT3OAMEVENTLOGWINDOWHI     53
    {
        DOT3OAMEVENTLOGWINDOWHI, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 6}
    },
#define DOT3OAMEVENTLOGWINDOWLO     54
    {
        DOT3OAMEVENTLOGWINDOWLO, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 7}
    },
#define DOT3OAMEVENTLOGTHRESHOLDHI  55
    {
        DOT3OAMEVENTLOGTHRESHOLDHI, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 8}
    },
#define DOT3OAMEVENTLOGTHRESHOLDLO  56
    {
        DOT3OAMEVENTLOGTHRESHOLDLO, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 9}
    },
#define DOT3OAMEVENTLOGVALUE        57
    {
        DOT3OAMEVENTLOGVALUE, ASN_COUNTER64, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 10}
    },
#define DOT3OAMEVENTLOGRUNNINGTOTAL 58
    {
        DOT3OAMEVENTLOGRUNNINGTOTAL, ASN_COUNTER64, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 11}
    },
#define DOT3OAMEVENTLOGEVENTTOTAL   59
    {
        DOT3OAMEVENTLOGEVENTTOTAL, ASN_UNSIGNED, RONLY,
        var_dot3OamEventLogTable, 4, {1, 6, 1, 12}
    },
};

/*
 * Initializes the dot3OamMIB module
 */
void
init_dot3OamMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(dot3OamMIB_variables_oid,
                             sizeof(dot3OamMIB_variables_oid) / sizeof(oid),
                             "Dot3-OAM-MIB : dot3OamMIB");

    DEBUGMSGTL(("dot3OamMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3OamMIB", dot3OamMIB_variables, variable4,
                 dot3OamMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_dot3OamMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_dot3OamMIB(struct variable *vp,
               oid *name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod **write_method)
{

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamMIB\n",
                    vp->magic));
    }
    return NULL;
}


/*
 * var_dot3OamTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    int                  table_size;
    int                  idx_num;
    int                  table_index = -1;
    dot3OamTable_entry_t table_entry;
    static u32           ulong_ret;
    static u8            string;
    iftable_info_t       iftable_info;
    u32                  if_types = 0;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];
    iftable_info.ifIndex = (ifIndex_id_t)idx_num - 1;
    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return NULL;
    }

    if (exact) {
        if (iftable_info.ifIndex != idx_num) {
            return NULL;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (get_dot3OamTable_entry(&iftable_info, &table_entry) == FALSE) {
            return NULL;
        }
    } else {
        memset(&table_entry, 0, sizeof(table_entry));
        do {
            if (get_dot3OamTable_entry(&iftable_info, &table_entry) == TRUE) {
                table_index = iftable_info.ifIndex;
                break;
            }
        } while (ifIndex_get_next_by_type(&iftable_info, if_types) == TRUE);

        if (table_index == -1) {
            return NULL;
        }

        /*
         * Save this one as the "next one", if "table_index" is not sequence
         */
        name[(*length) - 1] = table_index;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMADMINSTATE: {
        *write_method = write_dot3OamAdminState;
        ulong_ret = table_entry.dot3OamAdminState;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMOPERSTATUS: {
        ulong_ret = table_entry.dot3OamOperStatus;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMMODE: {
        *write_method = write_dot3OamMode;
        ulong_ret = table_entry.dot3OamMode;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMMAXOAMPDUSIZE: {
        ulong_ret = table_entry.dot3OamMaxOamPduSize;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMCONFIGREVISION: {
        ulong_ret = table_entry.dot3OamConfigRevision;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMFUNCTIONSSUPPORTED: {
        string = table_entry.dot3OamFunctionsSupported;
        *var_len = sizeof(table_entry.dot3OamFunctionsSupported);
        return (u_char *)&string;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamTable\n",
                    vp->magic));
    }
    return NULL;
}


/*
 * var_dot3OamPeerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamPeerTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    dot3OamPeerTable_entry_t table_entry;
    static u32               ulong_ret;
    static u8                string[SPRINT_MAX_LEN];
    static u8                peer_functions;
    int                      table_index = -1;
    iftable_info_t           iftable_info;
    u32                      if_types = 0;
    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];
    iftable_info.ifIndex = (ifIndex_id_t)idx_num - 1;
    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return NULL;
    }

    if (exact) {
        if (iftable_info.ifIndex != idx_num) {
            return NULL;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (get_dot3OamPeerTable_entry(&iftable_info, &table_entry) == FALSE) {
            return NULL;
        }
    } else {
        memset(&table_entry, 0, sizeof(table_entry));
        do {
            if (get_dot3OamPeerTable_entry(&iftable_info, &table_entry) == TRUE) {
                table_index = iftable_info.ifIndex;
                break;
            }
        } while (ifIndex_get_next_by_type(&iftable_info, if_types) == TRUE);

        if (table_index == -1) {
            return NULL;
        }

        /*
         * Save this one as the "next one", if "table_index" is not sequence
         */
        name[(*length) - 1] = table_index;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMPEERMACADDRESS: {
        memset(string, 0, sizeof(string));
        memcpy(string, table_entry.dot3OamPeerMacAddress, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE ;
        return (u_char *)string;
    }
    case DOT3OAMPEERVENDOROUI: {
        memset(string, 0, sizeof(string));
        memcpy(string, table_entry.dot3OamPeerVendorOui, LINK_OAM_VENDOR_OUI_LEN);
        *var_len = LINK_OAM_VENDOR_OUI_LEN;
        return (u_char *)string;
    }
    case DOT3OAMPEERVENDORINFO: {
        /*NOT SUPPORTED*/
        ulong_ret = table_entry.dot3OamPeerVendorInfo;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERMODE: {
        ulong_ret = table_entry.dot3OamPeerMode;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERMAXOAMPDUSIZE: {
        ulong_ret = table_entry.dot3OamPeerMaxOamPduSize;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERCONFIGREVISION: {
        ulong_ret = table_entry.dot3OamPeerConfigRevision;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERFUNCTIONSSUPPORTED: {
        peer_functions = table_entry.dot3OamPeerFunctionsSupported;
        *var_len = sizeof(u8);
        return (u_char *)&peer_functions;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamPeerTable\n",
                    vp->magic));
    }
    return NULL;
}


/*
 * var_dot3OamLoopbackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamLoopbackTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{

    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    dot3OamLoopbackTable_entry_t table_entry;
    int                      table_index = -1;
    iftable_info_t           iftable_info;
    u32                      if_types = 0;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];
    iftable_info.ifIndex = (ifIndex_id_t)idx_num - 1;
    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return NULL;
    }

    if (exact) {
        if (iftable_info.ifIndex != idx_num) {
            return NULL;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (get_dot3OamLoopbackTable_entry(&iftable_info, &table_entry) == FALSE) {
            return NULL;
        }
    } else {
        memset(&table_entry, 0, sizeof(table_entry));
        do {
            if (get_dot3OamLoopbackTable_entry(&iftable_info, &table_entry) == TRUE) {
                table_index = iftable_info.ifIndex;
                break;
            }
        } while (ifIndex_get_next_by_type(&iftable_info, if_types) == TRUE);

        if (table_index == -1) {
            return NULL;
        }

        /*
         * Save this one as the "next one", if "table_index" is not sequence
         */
        name[(*length) - 1] = table_index;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMLOOPBACKSTATUS: {
        *write_method = write_dot3OamLoopbackStatus;
        ulong_ret = table_entry.dot3OamLoopbackStatus;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMLOOPBACKIGNORERX: {
        *write_method = write_dot3OamLoopbackIgnoreRx;
        ulong_ret = table_entry.dot3OamLoopbackIgnoreRx;
        return (u_char *)&ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamLoopbackTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamStatsTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    int                      table_index = -1;
    iftable_info_t           iftable_info;
    u32                      if_types = 0;

    dot3OamStatsTable_entry_t table_entry;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];
    iftable_info.ifIndex = (ifIndex_id_t)idx_num - 1;
    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return NULL;
    }

    if (exact) {
        if (iftable_info.ifIndex != idx_num) {
            return NULL;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (get_dot3OamStatsTable_entry(&iftable_info, &table_entry) == FALSE) {
            return NULL;
        }
    } else {
        memset(&table_entry, 0, sizeof(table_entry));
        do {
            if (get_dot3OamStatsTable_entry(&iftable_info, &table_entry) == TRUE) {
                table_index = iftable_info.ifIndex;
                break;
            }
        } while (ifIndex_get_next_by_type(&iftable_info, if_types) == TRUE);

        if (table_index == -1) {
            return NULL;
        }

        /*
         * Save this one as the "next one", if "table_index" is not sequence
         */
        name[(*length) - 1] = table_index;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMINFORMATIONTX: {
        ulong_ret = table_entry.dot3OamInformationTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMINFORMATIONRX: {
        ulong_ret = table_entry.dot3OamInformationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMUNIQUEEVENTNOTIFICATIONTX: {
        ulong_ret = table_entry.dot3OamUniqueEventNotificationTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNIQUEEVENTNOTIFICATIONRX: {
        ulong_ret = table_entry.dot3OamUniqueEventNotificationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMDUPLICATEEVENTNOTIFICATIONTX: {
        ulong_ret = table_entry.dot3OamDuplicateEventNotificationTx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMDUPLICATEEVENTNOTIFICATIONRX: {
        ulong_ret = table_entry.dot3OamDuplicateEventNotificationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMLOOPBACKCONTROLTX: {
        ulong_ret = table_entry.dot3OamLoopbackControlTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMLOOPBACKCONTROLRX: {
        ulong_ret = table_entry.dot3OamLoopbackControlRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLEREQUESTTX: {
        ulong_ret = table_entry.dot3OamVariableRequestTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMVARIABLEREQUESTRX: {
        ulong_ret = table_entry.dot3OamVariableRequestRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLERESPONSETX: {
        ulong_ret = table_entry.dot3OamVariableResponseTx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLERESPONSERX: {
        ulong_ret = table_entry.dot3OamVariableResponseRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMORGSPECIFICTX: {
        ulong_ret = table_entry.dot3OamOrgSpecificTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMORGSPECIFICRX: {
        ulong_ret = table_entry.dot3OamOrgSpecificRx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNSUPPORTEDCODESTX: {
        ulong_ret = table_entry.dot3OamUnsupportedCodesTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNSUPPORTEDCODESRX: {
        ulong_ret = table_entry.dot3OamUnsupportedCodesRx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMFRAMESLOSTDUETOOAM: {
        ulong_ret = 0;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamEventConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamEventConfigTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    int                      table_index = -1;
    dot3OamEventConfigTable_entry_t table_entry;
    iftable_info_t           iftable_info;
    u32                      if_types = 0;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];
    iftable_info.ifIndex = (ifIndex_id_t)idx_num - 1;
    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return NULL;
    }

    if (exact) {
        if (iftable_info.ifIndex != idx_num) {
            return NULL;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (get_dot3OamEventConfigTable_entry(&iftable_info, &table_entry) == FALSE) {
            return NULL;
        }
    } else {
        memset(&table_entry, 0, sizeof(table_entry));
        do {
            if (get_dot3OamEventConfigTable_entry(&iftable_info, &table_entry) == TRUE) {
                table_index = iftable_info.ifIndex;
                break;
            }
        } while (ifIndex_get_next_by_type(&iftable_info, if_types) == TRUE);

        if (table_index == -1) {
            return NULL;
        }

        /*
         * Save this one as the "next one", if "table_index" is not sequence
         */
        name[(*length) - 1] = table_index;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMERRSYMPERIODWINDOWHI: {
        *write_method = write_dot3OamErrSymPeriodWindowHi;
        ulong_ret = table_entry.dot3OamErrSymPeriodWindowHi;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODWINDOWLO: {
        *write_method = write_dot3OamErrSymPeriodWindowLo;
        ulong_ret = table_entry.dot3OamErrSymPeriodWindowLo;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODTHRESHOLDHI: {
        *write_method = write_dot3OamErrSymPeriodThresholdHi;
        ulong_ret = table_entry.dot3OamErrSymPeriodThresholdHi;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODTHRESHOLDLO: {
        *write_method = write_dot3OamErrSymPeriodThresholdLo;
        ulong_ret = table_entry.dot3OamErrSymPeriodThresholdLo;
        return (u_char *) &ulong_ret;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    case DOT3OAMERRSYMPERIODEVNOTIFENABLE: {
        // *write_method = write_dot3OamErrSymPeriodEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrSymPeriodEvNotifEnable;
        return (u_char *)&ulong_ret;
    }
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    case DOT3OAMERRFRAMEPERIODWINDOW: {
        *write_method = write_dot3OamErrFramePeriodWindow;
        ulong_ret = table_entry.dot3OamErrFramePeriodWindow;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMEPERIODTHRESHOLD: {
        *write_method = write_dot3OamErrFramePeriodThreshold;
        ulong_ret = table_entry.dot3OamErrFramePeriodThreshold;
        return (u_char *) &ulong_ret;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    case DOT3OAMERRFRAMEPERIODEVNOTIFENABLE: {
        // *write_method = write_dot3OamErrFramePeriodEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFramePeriodEvNotifEnable;
        return (u_char *) &ulong_ret;
    }
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    case DOT3OAMERRFRAMEWINDOW: {
        *write_method = write_dot3OamErrFrameWindow;
        ulong_ret = table_entry.dot3OamErrFrameWindow;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMETHRESHOLD: {
        *write_method = write_dot3OamErrFrameThreshold;
        ulong_ret = table_entry.dot3OamErrFrameThreshold;
        return (u_char *)&ulong_ret;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    case DOT3OAMERRFRAMEEVNOTIFENABLE: {
        // *write_method = write_dot3OamErrFrameEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFrameEvNotifEnable;
        return (u_char *) &ulong_ret;
    }
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    case DOT3OAMERRFRAMESECSSUMMARYWINDOW: {
        *write_method = write_dot3OamErrFrameSecsSummaryWindow;
        ulong_ret = table_entry.dot3OamErrFrameSecsSummaryWindow;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD: {
        *write_method = write_dot3OamErrFrameSecsSummaryThreshold;
        ulong_ret = table_entry.dot3OamErrFrameSecsSummaryThreshold;
        return (u_char *) &ulong_ret;
    }
#ifdef DOT3OAM_MIB_NOT_SUPPORTED
    case DOT3OAMERRFRAMESECSEVNOTIFENABLE: {
        // *write_method = write_dot3OamErrFrameSecsEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFrameSecsEvNotifEnable;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMDYINGGASPENABLE: {
        // *write_method = write_dot3OamDyingGaspEnable;
        ulong_ret = table_entry.dot3OamDyingGaspEnable;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMCRITICALEVENTENABLE: {
        // *write_method = write_dot3OamCriticalEventEnable;
        ulong_ret = table_entry.dot3OamCriticalEventEnable;
        return (u_char *) &ulong_ret;
    }
#endif /* DOT3OAM_MIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamEventConfigTable\n",
                    vp->magic));
    }
    return NULL;
}

static mesa_rc dot3OamEventLogType_index_itr(const oid *const prev_index, oid *const next_index)
{
    vtss::expose::snmp::IteratorComposeRange<oid> itr(1, (VTSS_EVENT_LOG_CONV_TBL_SIZE) - 1);
    return itr(prev_index, next_index);
}
static mesa_rc dot3OamEventLog_ifindex_itr(const oid *const prev_ifindex, oid *const next_ifindex)
{
    iftable_info_t           iftable_info;
    u32                      if_types = IFTABLE_IFINDEX_TYPE_PORT;

    iftable_info.ifIndex = (prev_ifindex == NULL) ? 0 : *prev_ifindex;

    IFTABLE_IFINDEX_TYPE_FLAG_SET(if_types, IFTABLE_IFINDEX_TYPE_PORT);
    if (ifIndex_get_next_by_type(&iftable_info, if_types) == FALSE) {
        return VTSS_RC_ERROR;
    }
    VTSS_RC(port_ifindex_valid(vtss_ifindex_cast_from_u32_0(iftable_info.ifIndex)));
    *next_ifindex = iftable_info.ifIndex;
    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogTable_itr(const oid *const prev_ifindex,
                                        oid *const next_ifindex,
                                        const oid *const prev_instance,
                                        oid *const next_instance)
{
    vtss::IteratorComposeN<oid, oid> itr(dot3OamEventLog_ifindex_itr, dot3OamEventLogType_index_itr);
    return itr(prev_ifindex, next_ifindex, prev_instance, next_instance);
}
#define VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry_ptr, SRC) \
    entry_ptr->dot3OamEventLogOui[0]    = 0x01;\
    entry_ptr->dot3OamEventLogOui[1]    = 0x80;\
    entry_ptr->dot3OamEventLogOui[2]    = 0xC2;\
    entry_ptr->dot3OamEventLogLocation  = SRC + 1;

#if !defined(__BIG_ENDIAN__) && !defined(WORDS_BIGENDIAN)
#define SNMP_CAST_U32_TO_U64(V32) ((((u64)V32 & 0x00000000FFFFFFFF) << 32))
#else
#define SNMP_CAST_U32_TO_U64(V32) (u64)V32
#endif

#define LOAM_NTOHS_FRM_BYTES(X) vtss_eth_link_oam_ntohs_from_bytes(X)
#define LOAM_NTOHL_FRM_BYTES(X) vtss_eth_link_oam_ntohl_from_bytes(X)
#define LOAM_SWAP64_FRM_BYTES(X) vtss_eth_link_oam_swap64_from_bytes(X)
#define LOAM_U64_HI_FROM_BYTES(X)   (u32)((LOAM_SWAP64_FRM_BYTES(X) & 0xFFFFFFFF00000000) >> 32)
#define LOAM_U64_LO_FROM_BYTES(X)   (u32)((LOAM_SWAP64_FRM_BYTES(X) & 0x00000000FFFFFFFF) >>  0)

static mesa_rc dot3OamEventLogEntry_err_sysmbol_get(vtss_ifindex_elm_t ife,
                                                    vtss_loam_event_src_t src,
                                                    dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_error_symbol_period_event_tlv_t  error_symbol_period_tlv,
                                                       remote_error_symbol_period_tlv,
                                                       *info;

    VTSS_RC(eth_link_oam_client_port_symbol_period_error_info_get(ife.isid, ife.ordinal,
                                                                  &error_symbol_period_tlv,
                                                                  &remote_error_symbol_period_tlv));

    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    info = (src == VTSS_EVENT_SRC_LOCAL) ? &error_symbol_period_tlv : &remote_error_symbol_period_tlv;

    entry->dot3OamEventLogTimestamp     = LOAM_NTOHS_FRM_BYTES(info->event_time_stamp);
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_ERR_SYMBOL;
    entry->dot3OamEventLogWindowHi      = LOAM_U64_HI_FROM_BYTES(info->error_symbol_window);
    entry->dot3OamEventLogWindowLo      = LOAM_U64_LO_FROM_BYTES(info->error_symbol_window);
    entry->dot3OamEventLogThresholdHi   = LOAM_U64_HI_FROM_BYTES(info->error_symbol_threshold);
    entry->dot3OamEventLogThresholdLo   = LOAM_U64_LO_FROM_BYTES(info->error_symbol_threshold);
    entry->dot3OamEventLogValue.high    = LOAM_U64_HI_FROM_BYTES(info->error_symbols);
    entry->dot3OamEventLogValue.low     = LOAM_U64_LO_FROM_BYTES(info->error_symbols);
    entry->dot3OamEventLogRunningTotal.high  = LOAM_U64_HI_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogRunningTotal.low   = LOAM_U64_LO_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogEventTotal    = LOAM_NTOHL_FRM_BYTES(info->event_running_total);

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_err_frm_period_get(vtss_ifindex_elm_t ife,
                                                       vtss_loam_event_src_t src,
                                                       dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_error_frame_period_event_tlv_t  error_frame_period_tlv, remote_error_frame_period_tlv, *info;

    VTSS_RC(eth_link_oam_client_port_frame_period_error_info_get(ife.isid, ife.ordinal,
                                                                 &error_frame_period_tlv,
                                                                 &remote_error_frame_period_tlv));

    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    info = (src == VTSS_EVENT_SRC_LOCAL) ? &error_frame_period_tlv : &remote_error_frame_period_tlv;

    entry->dot3OamEventLogTimestamp     = LOAM_NTOHS_FRM_BYTES(info->event_time_stamp);
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_ERR_FRM_PERIOD;
    entry->dot3OamEventLogWindowHi      = 0;
    entry->dot3OamEventLogWindowLo      = LOAM_NTOHL_FRM_BYTES(info->error_frame_period_window);
    entry->dot3OamEventLogThresholdHi   = 0;
    entry->dot3OamEventLogThresholdLo   = LOAM_NTOHL_FRM_BYTES(info->error_frame_threshold);
    entry->dot3OamEventLogValue.high         = 0; // vtss_eth_link_oam_error_frame_period_event_tlv_t::error_frames is only 4 bytes long.
    entry->dot3OamEventLogValue.low          = LOAM_NTOHL_FRM_BYTES(info->error_frames);
    entry->dot3OamEventLogRunningTotal.high  = LOAM_U64_HI_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogRunningTotal.low   = LOAM_U64_LO_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogEventTotal    = LOAM_NTOHL_FRM_BYTES(info->event_running_total);

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_err_frm_get(vtss_ifindex_elm_t ife,
                                                vtss_loam_event_src_t src,
                                                dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_error_frame_event_tlv_t  local_error_info, remote_error_info, *info;

    VTSS_RC(eth_link_oam_client_port_frame_error_info_get(ife.isid, ife.ordinal,
                                                          &local_error_info,
                                                          &remote_error_info));

    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    info = (src == VTSS_EVENT_SRC_LOCAL) ? &local_error_info : &remote_error_info;

    entry->dot3OamEventLogTimestamp     = LOAM_NTOHS_FRM_BYTES(info->event_time_stamp);
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_ERR_FRM;
    entry->dot3OamEventLogWindowHi      = 0;
    entry->dot3OamEventLogWindowLo      = LOAM_NTOHS_FRM_BYTES(info->error_frame_window);
    entry->dot3OamEventLogThresholdHi   = 0;
    entry->dot3OamEventLogThresholdLo   = LOAM_NTOHL_FRM_BYTES(info->error_frame_threshold);
    entry->dot3OamEventLogValue.high    = 0; // vtss_eth_link_oam_error_frame_event_tlv_t::error_frames is only 4 bytes long.
    entry->dot3OamEventLogValue.low     = LOAM_NTOHL_FRM_BYTES(info->error_frames);
    entry->dot3OamEventLogRunningTotal.high  = LOAM_U64_HI_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogRunningTotal.low   = LOAM_U64_LO_FROM_BYTES(info->error_running_total);
    entry->dot3OamEventLogEventTotal    = LOAM_NTOHL_FRM_BYTES(info->event_running_total);

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_err_frm_seconds_get(vtss_ifindex_elm_t ife,
                                                        vtss_loam_event_src_t src,
                                                        dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t   local_info, remote_info, *info;

    VTSS_RC(eth_link_oam_client_port_error_frame_secs_summary_info_get(ife.isid,
                                                                       ife.ordinal,
                                                                       &local_info,
                                                                       &remote_info));
    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    info = (src == VTSS_EVENT_SRC_LOCAL) ? &local_info : &remote_info;

    entry->dot3OamEventLogTimestamp     = LOAM_NTOHS_FRM_BYTES(info->event_time_stamp);
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_ERR_FRM_SECONDS;
    entry->dot3OamEventLogWindowHi      = 0;
    entry->dot3OamEventLogWindowLo      = LOAM_NTOHS_FRM_BYTES(info->secs_summary_window);
    entry->dot3OamEventLogThresholdHi   = 0;
    entry->dot3OamEventLogThresholdLo   = LOAM_NTOHS_FRM_BYTES(info->secs_summary_threshold);
    entry->dot3OamEventLogValue.high         = 0; // vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t::secs_summary_events is only 2 bytes long.
    entry->dot3OamEventLogValue.low          = LOAM_NTOHS_FRM_BYTES(info->secs_summary_events);
    entry->dot3OamEventLogRunningTotal.high  = 0; // vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t::error_running_total is only 4 bytes long.
    entry->dot3OamEventLogRunningTotal.low   = LOAM_NTOHL_FRM_BYTES(info->error_running_total);
    entry->dot3OamEventLogEventTotal    = LOAM_NTOHL_FRM_BYTES(info->event_running_total);

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_link_fault_get(vtss_ifindex_elm_t ife,
                                                   vtss_loam_event_src_t src,
                                                   dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_critical_event_pdu_stats_t stats;

    VTSS_RC(eth_link_oam_control_layer_port_critical_event_pdu_stats_get(ife.isid,
                                                                         ife.ordinal,
                                                                         &stats));

    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    u32 total = (src == VTSS_EVENT_SRC_LOCAL) ? stats.link_fault_tx : stats.link_fault_rx;

    entry->dot3OamEventLogTimestamp     = 0;
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_LINK_FAULT;
    entry->dot3OamEventLogWindowHi      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogWindowLo      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdHi   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdLo   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.high    = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.low     = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogRunningTotal.high  = 0;
    entry->dot3OamEventLogRunningTotal.low   = total;
    entry->dot3OamEventLogEventTotal    = total;

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_dying_gasp_event_get(vtss_ifindex_elm_t ife,
                                                         vtss_loam_event_src_t src,
                                                         dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_critical_event_pdu_stats_t stats;

    VTSS_RC(eth_link_oam_control_layer_port_critical_event_pdu_stats_get(ife.isid,
                                                                         ife.ordinal,
                                                                         &stats));

    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    u32 total = (src == VTSS_EVENT_SRC_LOCAL) ? stats.dying_gasp_tx : stats.dying_gasp_rx;

    entry->dot3OamEventLogTimestamp     = 0;
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_DYING_GASP;
    entry->dot3OamEventLogWindowHi      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogWindowLo      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdHi   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdLo   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.high    = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.low     = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogRunningTotal.high  = 0;
    entry->dot3OamEventLogRunningTotal.low   = total;
    entry->dot3OamEventLogEventTotal    = total;

    return VTSS_RC_OK;
}
static mesa_rc dot3OamEventLogEntry_criti_link_event_get(vtss_ifindex_elm_t ife,
                                                         vtss_loam_event_src_t src,
                                                         dot3OamEventLogTable_entry_t *entry)
{
    vtss_eth_link_oam_critical_event_pdu_stats_t  stats;

    VTSS_RC(eth_link_oam_control_layer_port_critical_event_pdu_stats_get(ife.isid,
                                                                         ife.ordinal,
                                                                         &stats));
    VTSS_LOAM_FILL_STD_OUI_N_LOG_LOCATION_FIELDS(entry, src);
    u32 total = (src == VTSS_EVENT_SRC_LOCAL) ? stats.critical_event_tx : stats.critical_event_rx;

    entry->dot3OamEventLogTimestamp     = 0;
    entry->dot3OamEventLogType          = VTSS_EVENT_TYPE_CRITI_LINK;
    entry->dot3OamEventLogWindowHi      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogWindowLo      = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdHi   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogThresholdLo   = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.high    = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogValue.low     = 0xFFFFFFFF;/* 2^32 - 1 */
    entry->dot3OamEventLogRunningTotal.high  = 0;
    entry->dot3OamEventLogRunningTotal.low  = total;
    entry->dot3OamEventLogEventTotal    = total;

    return VTSS_RC_OK;
}
#define DPRINT(ARGS)
#define LOAM_CB_SET(infix) dot3OamEventLogEntry_##infix##_get
static const vtss_loam_event_log_index_t log_index_to_key[VTSS_EVENT_LOG_CONV_TBL_SIZE] = {
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(err_sysmbol)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(err_sysmbol)},
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(err_frm_period)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(err_frm_period)},
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(err_frm)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(err_frm)},
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(err_frm_seconds)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(err_frm_seconds)},

    /* Non-threshold events are listed below */
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(link_fault)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(link_fault)},
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(dying_gasp_event)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(dying_gasp_event)},
    {VTSS_EVENT_SRC_LOCAL, LOAM_CB_SET(criti_link_event)},
    {VTSS_EVENT_SRC_REMOTE, LOAM_CB_SET(criti_link_event)},
};
static mesa_rc dot3OamEventLogEntry_get(oid ifindex, oid index,
                                        dot3OamEventLogTable_entry_t *entry)
{
    if (!entry) {
        return VTSS_RC_ERROR;
    }

    if (index >= VTSS_EVENT_LOG_CONV_TBL_SIZE) {
        return VTSS_RC_ERROR;
    }

    vtss_ifindex_elm_t ife;

    vtss_ifindex_t ifIdx = vtss_ifindex_cast_from_u32_0(ifindex);
    VTSS_RC(port_ifindex_valid(ifIdx));
    vtss_loam_event_log_index_t cindex = log_index_to_key[index];
    VTSS_RC(vtss_ifindex_decompose(ifIdx, &ife));

    VTSS_RC(cindex.cb(ife, cindex.src, entry));

    return VTSS_RC_OK;
}

/**
  * \brief Get first table entry of dot3OamEventLogTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int dot3OamEventLogTableEntry_getfirst(dot3OamEventLogTable_entry_t *table_entry)
{
    oid prev_ifindex = 0, prev_index = 0;
    oid next_ifindex = 0, next_index = 0;

    if (dot3OamEventLogTable_itr(&prev_ifindex, &next_ifindex, &prev_index, &next_index) != VTSS_RC_OK) {
        return -1;  // The operation failed
    }

    table_entry->ifIndex = (u32) next_ifindex;
    table_entry->dot3OamEventLogIndex = (u32) next_index;

    if (dot3OamEventLogEntry_get(next_ifindex, next_index, table_entry) != VTSS_RC_OK) {
        return -1;  // The operation failed
    }

    return 0;   // The operation success
}

/**
  * \brief Get/Getnext table entry of dot3OamEventLogTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int dot3OamEventLogTableEntry_get(dot3OamEventLogTable_entry_t *table_entry, int getnext)
{
    oid prev_ifindex, prev_index;
    oid next_ifindex = 0, next_index = 0;

    if (getnext) {
        prev_ifindex = (oid) table_entry->ifIndex;
        prev_index   = (oid) table_entry->dot3OamEventLogIndex;

        if (dot3OamEventLogTable_itr(&prev_ifindex, &next_ifindex, &prev_index, &next_index) != VTSS_RC_OK) {
            return -1;  // The operation failed
        }

        table_entry->ifIndex = (u32) next_ifindex;
        table_entry->dot3OamEventLogIndex = (u32) next_index;
    }

    if (dot3OamEventLogEntry_get((oid) table_entry->ifIndex, (oid) table_entry->dot3OamEventLogIndex, table_entry) != VTSS_RC_OK) {
        return -1;  // The operation failed
    }

    return 0;   // The operation success
}

/******************************************************************************/
// dot3OamEventLogTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
dot3OamEventLogTable_parse(oid     *name,
                           size_t  *length,
                           int     exact,
                           dot3OamEventLogTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (dot3OamEventLogTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ifIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot3OamEventLogIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// dot3OamEventLogTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
dot3OamEventLogTable_fillobj(oid     *name,
                             size_t  *length,
                             dot3OamEventLogTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ifIndex;
    name[name_pos++] = (oid) table_entry->dot3OamEventLogIndex;

    *length = name_pos;
    return 0;
}

u_char         *
var_dot3OamEventLogTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    static struct counter64  u64_ret;
    static u32               u32_ret;
    static u8                oui_ret[LINK_OAM_VENDOR_OUI_LEN];

    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot3OamEventLogTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = dot3OamEventLogTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (dot3OamEventLogTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (dot3OamEventLogTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (dot3OamEventLogTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMEVENTLOGTIMESTAMP: {
        DPRINT(("TIME_STAMP \n"));
        u32_ret = table_entry.dot3OamEventLogTimestamp;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGOUI: {
        memcpy(&oui_ret, &table_entry.dot3OamEventLogOui, LINK_OAM_VENDOR_OUI_LEN);
        *var_len = LINK_OAM_VENDOR_OUI_LEN;
        return (u_char *) &oui_ret;
    }
    case DOT3OAMEVENTLOGTYPE: {
        u32_ret = table_entry.dot3OamEventLogType;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGLOCATION: {
        u32_ret = table_entry.dot3OamEventLogLocation;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGWINDOWHI: {
        u32_ret = table_entry.dot3OamEventLogWindowHi;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGWINDOWLO: {
        u32_ret = table_entry.dot3OamEventLogWindowLo;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGTHRESHOLDHI: {
        u32_ret = table_entry.dot3OamEventLogThresholdHi;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGTHRESHOLDLO: {
        u32_ret = table_entry.dot3OamEventLogThresholdLo;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    case DOT3OAMEVENTLOGVALUE: {
        u64_ret = table_entry.dot3OamEventLogValue;
        *var_len = sizeof(u64_ret);
        return (u_char *) &u64_ret;
    }
    case DOT3OAMEVENTLOGRUNNINGTOTAL: {
        u64_ret = table_entry.dot3OamEventLogRunningTotal;
        *var_len = sizeof(u64_ret);
        return (u_char *) &u64_ret;
    }
    case DOT3OAMEVENTLOGEVENTTOTAL: {
        u32_ret = table_entry.dot3OamEventLogEventTotal;
        *var_len = sizeof(u32_ret);
        return (u_char *) &u32_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in %s\n",
                    vp->magic, __FUNCTION__));
    }
    return NULL;
}

int
write_dot3OamAdminState(int action,
                        u_char *var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char *statP, oid *name, size_t name_len)
{
    u_long                 *buf, *old_buf;
    u_long                 temp_buf = 0, temp_old_buf = 0;
    int                    log_rc = 0;
    int                    ifindex;
    iftable_info_t         iftable_info;
    mesa_rc                rc;
    size_t                 max_size;
    u_long                 intval;

    ifindex = name[name_len - 1];
    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_ADMIN_ENABLED && intval != LINK_OAM_ADMIN_DISABLED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (intval == LINK_OAM_ADMIN_ENABLED) {
            rc = eth_link_oam_mgmt_port_control_conf_set(iftable_info.isid, iftable_info.if_id, VTSS_APPL_ETH_LINK_OAM_CONTROL_ENABLE );
        } else {
            rc = eth_link_oam_mgmt_port_control_conf_set(iftable_info.isid, iftable_info.if_id, VTSS_APPL_ETH_LINK_OAM_CONTROL_DISABLE );
        }

        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamMode(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u_long          intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamMode: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR, "write to dot3OamMode: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_PASSIVE && intval != LINK_OAM_ACTIVE) {
            log_rc = snmp_log(LOG_ERR, "write to dot3OamMode: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (intval == LINK_OAM_PASSIVE) {
            rc = eth_link_oam_mgmt_port_mode_conf_set(iftable_info.isid, iftable_info.if_id, VTSS_APPL_ETH_LINK_OAM_MODE_PASSIVE);
        } else {
            rc = eth_link_oam_mgmt_port_mode_conf_set(iftable_info.isid, iftable_info.if_id, VTSS_APPL_ETH_LINK_OAM_MODE_ACTIVE);
        }

        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamLoopbackStatus(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    u_long                 *buf, *old_buf;
    u_long                 temp_buf = 0, temp_old_buf = 0;
    size_t                 max_size;
    u_long                 intval;
    mesa_rc                rc;
    int                    log_rc;
    u32                    ifindex;
    iftable_info_t         iftable_info;
    int                    loopback;
    dot3OamLoopbackTable_entry_t table_entry;


    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_INITIATING_LOOPBACK && intval != LINK_OAM_TERMINATING_LOOPBACK) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (!get_dot3OamLoopbackTable_entry(&iftable_info, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (intval == LINK_OAM_INITIATING_LOOPBACK ) {
            loopback = TRUE;
        } else {
            loopback = FALSE;
        }

        if (table_entry.dot3OamLoopbackStatus != LINK_OAM_NO_LOOPBACK &&
            table_entry.dot3OamLoopbackStatus != LINK_OAM_REMOTE_LOOPBACK) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (table_entry.dot3OamLoopbackStatus != LINK_OAM_NO_LOOPBACK &&
            intval == LINK_OAM_INITIATING_LOOPBACK) {
            return SNMP_ERR_COMMITFAILED;
        }
        rc = eth_link_oam_mgmt_port_remote_loopback_oper_conf_set(iftable_info.isid, iftable_info.if_id,
                                                                  loopback);
        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamLoopbackIgnoreRx(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    u_long                 *buf, *old_buf;
    u_long                 temp_buf = 0, temp_old_buf = 0;
    size_t                 max_size;
    u_long                 intval;
    mesa_rc                rc;
    int                    log_rc;
    u32                    ifindex;
    iftable_info_t         iftable_info;
    int                    loopback;
    dot3OamLoopbackTable_entry_t table_entry;


    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackIgnoreRx: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackIgnoreRx: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_LOOPBACK_PROCESS && intval != LINK_OAM_LOOPBACK_IGNORE) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackIgnoreRx: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (!get_dot3OamLoopbackTable_entry(&iftable_info, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (intval == LINK_OAM_LOOPBACK_PROCESS) {
            loopback = TRUE;
        } else {
            loopback = FALSE;
        }

        rc = eth_link_oam_mgmt_port_remote_loopback_conf_set(iftable_info.isid, iftable_info.if_id,
                                                             loopback);
        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodWindowHi(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u_long          intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;
    BOOL            little_endian;
    const int       endian = 1;
    char            *p = (char *)&endian;
    u64             temp_symbol_period;
    u8              *temp_ptr = (u8 *)&temp_symbol_period;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowHi: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowHi: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(iftable_info.isid, iftable_info.if_id, &temp_symbol_period);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_set(iftable_info.isid, iftable_info.if_id, temp_symbol_period);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodWindowLo(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u_long          intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;
    BOOL            little_endian;
    const int       endian = 1;
    char            *p = (char *)&endian;
    u64             temp_symbol_period;
    u8              *temp_ptr = (u8 *)&temp_symbol_period;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowLo: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowLo: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(iftable_info.isid, iftable_info.if_id, &temp_symbol_period);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_set(iftable_info.isid, iftable_info.if_id, temp_symbol_period);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;

    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodThresholdHi(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u_long          intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;
    const int       endian = 1;
    BOOL            little_endian;
    char            *p = (char *)&endian;
    u64             temp_symbol_threshold;
    u8              *temp_ptr = (u8 *)&temp_symbol_threshold;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdHi: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdHi: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }

        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(iftable_info.isid, iftable_info.if_id, &temp_symbol_threshold);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_set(iftable_info.isid, iftable_info.if_id, temp_symbol_threshold);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodThresholdLo(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u_long          intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;
    const int       endian = 1;
    BOOL            little_endian;
    char            *p = (char *)&endian;
    u64             temp_symbol_threshold;
    u8              *temp_ptr = (u8 *)&temp_symbol_threshold;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    ifindex = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdLo: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdLo: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }

        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(iftable_info.isid, iftable_info.if_id, &temp_symbol_threshold);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        }

        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_set(
                 iftable_info.isid, iftable_info.if_id, temp_symbol_threshold);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFramePeriodWindow(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodWindow: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_frame_period_error_window_set(iftable_info.isid, iftable_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFramePeriodThreshold(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodThreshold: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_frame_period_error_threshold_set(iftable_info.isid, iftable_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot3OamErrFrameWindow(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameWindow: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_error_frame_window_set(iftable_info.isid, iftable_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameThreshold(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameThreshold: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_error_frame_threshold_set(iftable_info.isid, iftable_info.if_id, intval);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameSecsSummaryWindow(int action,
                                       u_char *var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char *statP,
                                       oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > LINK_OAM_FRAME_SECS_SUMMARY_WINDOW_MAX || intval < LINK_OAM_FRAME_SECS_SUMMARY_WINDOW_MIN) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;

        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_window_set(iftable_info.isid, iftable_info.if_id, intval / 10);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameSecsSummaryThreshold(int action,
                                          u_char *var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char *statP,
                                          oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf = 0, temp_old_buf = 0;
    size_t          max_size;
    u32             intval;
    mesa_rc         rc;
    int             log_rc;
    u32             ifindex;
    iftable_info_t  iftable_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    ifindex = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > LINK_OAM_FRAME_SECS_SUMMARY_THRESHOLD_MAX || intval <= LINK_OAM_FRAME_SECS_SUMMARY_THRESHOLD_MIN) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (_dot3OamMib_get_ifTableIndex_info(ifindex, &iftable_info) != SNMP_ERR_NOERROR) {
            return SNMP_NOSUCHINSTANCE;
        }

        rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_threshold_set(iftable_info.isid, iftable_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}


