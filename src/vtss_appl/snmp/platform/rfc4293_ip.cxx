/*
 Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
#include "vtss_os_wrapper.h"
#include <sys/param.h>
#include <vtss_snmp_api.h>

#include "vtss_os_wrapper_snmp.h"
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include "ifIndex_api.h"
#include "ip_api.h"
#include "ip_snmp.h"
#include "ip_utils.hxx"
#include "rfc4293_ip.h"
#include "inet_address.h"
#include "mibContextTable.h"  //mibContextTable_register
#include "misc_api.h"         //misc_raw2txt
#include "vtss/basics/trace.hxx"

#define SNMP_ASN_OCTET_STR_MAX_LEN  256 /* FIXME : Re-define it if needed */

#ifdef VTSS_TRACE_MODULE_ID
#undef VTSS_TRACE_MODULE_ID
#endif

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP

/*
 * The entry data structure for ipAddressTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipAddressAddrType;
    char            ipAddressAddr[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t          ipAddressAddr_len;

    /*
     * Entry columns
     */
    long            ipAddressIfIndex;
    long            ipAddressType;
    oid             ipAddressPrefix[MAX_OID_LEN];
    size_t          ipAddressPrefix_len;
    long            ipAddressOrigin;
    long            ipAddressStatus;
    u_long          ipAddressCreated;
    u_long          ipAddressLastChanged;
    long            ipAddressRowStatus;
    long            ipAddressStorageType;
} ipAddressTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    char            string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid             objid_ret[MAX_OID_LEN];
    size_t          objid_len_ret;
    u_long          ulong_ret;
} ipAddressTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */

/*lint -esym(459, ipAddressTable_global_ret) */

/*
 * Process one packet at the same time, therefore unprotected access is acceptable
 */
static ipAddressTable_return_t ipAddressTable_global_ret;       /* static variables for retuning */

/*
 * ipAddressTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ipAddressTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 4, 34 };



/*
 * variable ipAddressTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipAddressTable mib section
 */

struct variable2 ipAddressTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPADDRESSIFINDEX        1
    {IPADDRESSIFINDEX, ASN_INTEGER, RONLY, var_ipAddressTable, 2, {1, 3}},
#define IPADDRESSTYPE       2
    {IPADDRESSTYPE, ASN_INTEGER, RONLY, var_ipAddressTable, 2, {1, 4}},
#define IPADDRESSPREFIX     3
    {IPADDRESSPREFIX, ASN_OBJECT_ID, RONLY, var_ipAddressTable, 2, {1, 5}},
#if 0
#define IPADDRESSORIGIN     4
    {IPADDRESSORIGIN, ASN_INTEGER, RONLY, var_ipAddressTable, 2, {1, 6}},
#endif
#define IPADDRESSSTATUS     5
    {IPADDRESSSTATUS, ASN_INTEGER, RONLY, var_ipAddressTable, 2, {1, 7}},
#define IPADDRESSCREATED        6
    {
        IPADDRESSCREATED, ASN_TIMETICKS, RONLY, var_ipAddressTable, 2,
        {1, 8}
    },
#define IPADDRESSLASTCHANGED        7
    {
        IPADDRESSLASTCHANGED, ASN_TIMETICKS, RONLY, var_ipAddressTable, 2,
        {1, 9}
    },
#define IPADDRESSROWSTATUS      8
    {
        IPADDRESSROWSTATUS, ASN_INTEGER, RONLY, var_ipAddressTable, 2,
        {1, 10}
    },
#define IPADDRESSSTORAGETYPE        9
    {
        IPADDRESSSTORAGETYPE, ASN_INTEGER, RONLY, var_ipAddressTable, 2,
        {1, 11}
    },
};

/*
 * Initializes the ipAddressTable module
 */
static void
init_ipAddressTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipAddressTable_variables_oid,
                             sizeof(ipAddressTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipAddressTable");

    DEBUGMSGTL(("ipAddressTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ipAddressTable", ipAddressTable_variables, variable2,
                 ipAddressTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL get_next_ipAddressTableEntryByKey(ipAddressTable_entry_t *table_entry)
{
    mesa_ip_addr_t         ip_addr;
    mesa_vid_t             if_id;
    mesa_ipv4_t            n_v4_dst;
    iftable_info_t         table_info;
    ipAddressTable_entry_t tmp;
    u64                    ipAddressCreated, ipAddressLastChanged;

    memcpy(&tmp, table_entry, sizeof(tmp));

    if (tmp.ipAddressAddrType > INET_ADDRESS_IPV6) {
        return FALSE;
    }

    switch (tmp.ipAddressAddrType) {
    case INET_ADDRESS_UNKNOWN:
        tmp.ipAddressAddrType = INET_ADDRESS_IPV4;
        tmp.ipAddressAddr_len = INET_ADDRESS_IPV4_LEN;
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    case INET_ADDRESS_IPV4:
        if (tmp.ipAddressAddr_len < INET_ADDRESS_IPV4_LEN) {
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV4_LEN;
        } else if (tmp.ipAddressAddr_len > INET_ADDRESS_IPV4_LEN) {
            tmp.ipAddressAddrType = INET_ADDRESS_IPV6;
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        } else {
            break;
        }
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    case INET_ADDRESS_IPV6:
        if (tmp.ipAddressAddr_len < INET_ADDRESS_IPV6_LEN) {
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        } else if (tmp.ipAddressAddr_len > INET_ADDRESS_IPV6_LEN) {
            return FALSE;
        } else {
            break;
        }
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    default:
        break;
    }

    if (tmp.ipAddressAddrType == INET_ADDRESS_IPV6) {
        ip_addr.type = MESA_IP_TYPE_IPV6;
        memcpy(&ip_addr.addr.ipv6, tmp.ipAddressAddr, INET_ADDRESS_IPV6_LEN);
    } else {
        ip_addr.type = MESA_IP_TYPE_IPV4;
        memcpy(&n_v4_dst, tmp.ipAddressAddr, INET_ADDRESS_IPV4_LEN);
        ip_addr.addr.ipv4 = ntohl(n_v4_dst);
    }

    if ( FALSE == get_next_ip(&ip_addr, &if_id)) {
        return FALSE;
    }

    table_info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    table_info.if_id = if_id;
    (void) ifIndex_get_by_interface(&table_info);

    if (ip_addr.type == MESA_IP_TYPE_IPV4) {
        n_v4_dst = htonl (ip_addr.addr.ipv4);
        memcpy(tmp.ipAddressAddr, &n_v4_dst, INET_ADDRESS_IPV4_LEN);
        (void) vtss_ip_address_created_ipv4( vtss_ifindex_cast_from_u32(if_id, VTSS_IFINDEX_TYPE_VLAN), &ipAddressCreated);
        (void) vtss_ip_address_changed_ipv4( vtss_ifindex_cast_from_u32(if_id, VTSS_IFINDEX_TYPE_VLAN), &ipAddressLastChanged);
    } else {
        tmp.ipAddressAddrType = INET_ADDRESS_IPV6;
        tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        memcpy(tmp.ipAddressAddr, &ip_addr.addr.ipv6, INET_ADDRESS_IPV6_LEN);
        (void) vtss_ip_address_created_ipv6( vtss_ifindex_cast_from_u32(if_id, VTSS_IFINDEX_TYPE_VLAN), &ipAddressCreated);
        (void) vtss_ip_address_changed_ipv6( vtss_ifindex_cast_from_u32(if_id, VTSS_IFINDEX_TYPE_VLAN), &ipAddressLastChanged);
    }

    tmp.ipAddressCreated = (u32) (ipAddressCreated * 100);
    tmp.ipAddressLastChanged = (u32) (ipAddressLastChanged * 100);
    tmp.ipAddressIfIndex = table_info.ifIndex;
    tmp.ipAddressType = 1;
    tmp.ipAddressPrefix_len = 2;
    memset(tmp.ipAddressPrefix, 0, tmp.ipAddressPrefix_len);
    tmp.ipAddressStatus = 1;

    tmp.ipAddressRowStatus = 1;
    tmp.ipAddressStorageType = 4;
    memcpy(table_entry, &tmp, sizeof(tmp));

    return TRUE;
}

static BOOL get_ipAddressTableEntryByKey(ipAddressTable_entry_t *table_entry)
{
    ipAddressTable_entry_t tmp;
    unsigned char *ptr =  (unsigned char *)tmp.ipAddressAddr;
    int i = 0;
    BOOL overflow = TRUE;

    memcpy(&tmp, table_entry, sizeof(tmp));

    if (tmp.ipAddressAddrType != INET_ADDRESS_IPV6 &&
        tmp.ipAddressAddrType != INET_ADDRESS_IPV4) {
        return FALSE;
    }

    switch (tmp.ipAddressAddrType) {
    case INET_ADDRESS_IPV4:
        if (tmp.ipAddressAddr_len != INET_ADDRESS_IPV4_LEN) {
            return FALSE;
        }
        break;
    case INET_ADDRESS_IPV6:
        if (tmp.ipAddressAddr_len != INET_ADDRESS_IPV6_LEN) {
            return FALSE;
        }
        break;
    default:
        break;
    }

    for (i = tmp.ipAddressAddr_len - 1, ptr = (unsigned char *)(tmp.ipAddressAddr + tmp.ipAddressAddr_len - 1) ; i >= 0; i--, ptr-- ) {
        if (*ptr != 0x0 ) {
            --*ptr;
            overflow = FALSE;
            break;
        } else {
            *ptr = 0xff;
        }
    }

    if (overflow == TRUE) {
        --tmp.ipAddressAddr_len;
    }

    for (i = 0, ptr = (unsigned char *)tmp.ipAddressAddr; i < (int)tmp.ipAddressAddr_len; i++, ptr++) {
        T_D("%d", *ptr);
    }
    if ( FALSE == get_next_ipAddressTableEntryByKey(&tmp) || (tmp.ipAddressAddrType != table_entry->ipAddressAddrType) ||
         tmp.ipAddressAddr_len != table_entry->ipAddressAddr_len ||
         memcmp(tmp.ipAddressAddr, table_entry->ipAddressAddr, table_entry->ipAddressAddr_len)) {
        return FALSE;
    }

    memcpy(table_entry, &tmp, sizeof(tmp));

    return TRUE;

}

static int
getfirst_ipAddressTableEntry(ipAddressTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipAddressTable_entry_t));
    if ( FALSE == get_next_ipAddressTableEntryByKey (table_entry)) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
get_ipAddressTableEntry(ipAddressTable_entry_t *table_entry, BOOL getnext)
{

    if ( (getnext == TRUE && FALSE == get_next_ipAddressTableEntryByKey(table_entry)) ||
         (getnext == FALSE && FALSE == get_ipAddressTableEntryByKey(table_entry))) {
        return -1;
    }

    return VTSS_RC_OK;
}

static int
set_ipAddressTableEntry(ipAddressTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

typedef enum {
    IPADDRESSTABLETYPE,
    IPADDRESSADDR_LEN,
    IPADDRESSADDR
} ipAddressTable_key_t;

static BOOL subtract_ipAddressTable(ipAddressTable_entry_t *table_entry, ipAddressTable_key_t start_key, size_t offsetof_key)
{
    switch (start_key) {
    case IPADDRESSADDR: {
        char *offset = table_entry->ipAddressAddr + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1;
                return TRUE;
            }
            *(offset--) = 0xff;
        } while (offset >= table_entry->ipAddressAddr);
    }
    case IPADDRESSADDR_LEN: {
        if (table_entry->ipAddressAddr_len) {
            table_entry->ipAddressAddr_len--;
            return TRUE;
        }
    }
    case IPADDRESSTABLETYPE: {
        if (table_entry->ipAddressAddrType) {
            table_entry->ipAddressAddrType--;
            return TRUE;
        }
    }
    default:
        return FALSE;

    }
}

static int
parse_ipAddressTable(oid *name,
                     size_t *length,
                     int exact, ipAddressTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t         len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipAddressTableEntry(table_entry)) {
            return -1;
        }
        T_D("getfirst");
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipAddressAddrType = (long) * op++;
        if (!table_entry->ipAddressAddrType) {
            return 1;
        }
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        T_D("stop parsing because of no keys");
        goto parse_end;
    }

    if (*length > op_pos) {
        len = (unsigned int) * op++;
        len = (unsigned int) len > sizeof(table_entry->ipAddressAddr) ? sizeof(table_entry->ipAddressAddr) : len;
        if (!len) {
            if (FALSE == subtract_ipAddressTable(table_entry, IPADDRESSADDR_LEN, 0)) {
                return 1;
            }
            goto parse_end;
        }
        op_pos++;
        table_entry->ipAddressAddr_len = len;
        cp = (u_char *) table_entry->ipAddressAddr;
        while (len-- > 0) {
            if (*length > op_pos) {
                *cp++ = (u_char) * op++;
                op_pos++;
            } else if (exact) {
                return -1;
            } else {
                if (FALSE == subtract_ipAddressTable(table_entry, IPADDRESSADDR, cp - (u_char *)table_entry->ipAddressAddr)) {
                    return 1;
                }
                goto parse_end;
            }
        }
    } else if (exact) {
        return -1;
    } else {
        if (FALSE == subtract_ipAddressTable(table_entry, IPADDRESSADDR, 0)) {
            return 1;
        }
        goto parse_end;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

parse_end:
    T_D("key: (%ld.%zu%s)", table_entry->ipAddressAddrType, table_entry->ipAddressAddr_len, misc_raw2txt((u8 *)table_entry->ipAddressAddr, table_entry->ipAddressAddr_len, FALSE));
    return 0;
}

static int
fillobj_ipAddressTable(oid *name,
                       size_t *length,
                       ipAddressTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipAddressAddrType;
    len = (int) table_entry->ipAddressAddr_len;
    name[name_pos++] = (oid) table_entry->ipAddressAddr_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->ipAddressAddr[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_ipAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipAddressTable above.
 */
u_char         *
var_ipAddressTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipAddressTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipAddressTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipAddressTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipAddressTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IPADDRESSROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry.
                     */
                    *write_method = write_ipAddressRowStatus;
                }
                return NULL;
            }
            if (fillobj_ipAddressTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPADDRESSIFINDEX: {
        *write_method = write_ipAddressIfIndex;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressIfIndex;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSTYPE: {
        *write_method = write_ipAddressType;
        ipAddressTable_global_ret.long_ret = table_entry.ipAddressType;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSPREFIX: {
        memcpy(ipAddressTable_global_ret.objid_ret,
               table_entry.ipAddressPrefix,
               table_entry.ipAddressPrefix_len * sizeof(oid));
        *var_len = table_entry.ipAddressPrefix_len * sizeof(oid);
        return (u_char *) ipAddressTable_global_ret.objid_ret;
    }
#if 0
    case IPADDRESSORIGIN: {
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressOrigin;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
#endif
    case IPADDRESSSTATUS: {
        *write_method = write_ipAddressStatus;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressStatus;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSCREATED: {
        ipAddressTable_global_ret.ulong_ret =
            table_entry.ipAddressCreated;
        *var_len = sizeof(ipAddressTable_global_ret.ulong_ret);
        return (u_char *) & ipAddressTable_global_ret.ulong_ret;
    }
    case IPADDRESSLASTCHANGED: {
        ipAddressTable_global_ret.ulong_ret =
            table_entry.ipAddressLastChanged;
        *var_len = sizeof(ipAddressTable_global_ret.ulong_ret);
        return (u_char *) & ipAddressTable_global_ret.ulong_ret;
    }
    case IPADDRESSROWSTATUS: {
        *write_method = write_ipAddressRowStatus;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressRowStatus;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSSTORAGETYPE: {
        *write_method = write_ipAddressStorageType;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressStorageType;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipAddressTable\n",
                    vp->magic));
    }
    return NULL;
}

int
write_ipAddressIfIndex(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressIfIndex: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressIfIndex: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressIfIndex = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressType(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2 && set_value != 3) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressType = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressStatus(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6 && set_value != 7 && set_value != 8) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressStatus = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressRowStatus(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4 && set_value != 5 && set_value != 6) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /*
         * Return error code when the entry isn't existing
         * except for "createAndGo(4)" or "createAndWait(5)" status
         */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressRowStatus = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressStorageType(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3 && set_value != 4 && set_value != 5) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressStorageType = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipIfStatsTableLastChange
 */
typedef struct {
    u_long          ipIfStatsTableLastChange;
} ipTrafficStats_scalar_t;

/*
 * The entry data structure for ipSystemStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipSystemStatsIPVersion;

    /*
     * Entry columns
     */
    u_long          ipSystemStatsInReceives;
    struct counter64 ipSystemStatsHCInReceives;
    u_long          ipSystemStatsInOctets;
    struct counter64 ipSystemStatsHCInOctets;
    u_long          ipSystemStatsInHdrErrors;
    u_long          ipSystemStatsInNoRoutes;
    u_long          ipSystemStatsInAddrErrors;
    u_long          ipSystemStatsInUnknownProtos;
    u_long          ipSystemStatsInTruncatedPkts;
    u_long          ipSystemStatsInForwDatagrams;
    struct counter64 ipSystemStatsHCInForwDatagrams;
    u_long          ipSystemStatsReasmReqds;
    u_long          ipSystemStatsReasmOKs;
    u_long          ipSystemStatsReasmFails;
    u_long          ipSystemStatsInDiscards;
    u_long          ipSystemStatsInDelivers;
    struct counter64 ipSystemStatsHCInDelivers;
    u_long          ipSystemStatsOutRequests;
    struct counter64 ipSystemStatsHCOutRequests;
    u_long          ipSystemStatsOutNoRoutes;
    u_long          ipSystemStatsOutForwDatagrams;
    struct counter64 ipSystemStatsHCOutForwDatagrams;
    u_long          ipSystemStatsOutDiscards;
    u_long          ipSystemStatsOutFragReqds;
    u_long          ipSystemStatsOutFragOKs;
    u_long          ipSystemStatsOutFragFails;
    u_long          ipSystemStatsOutFragCreates;
    u_long          ipSystemStatsOutTransmits;
    struct counter64 ipSystemStatsHCOutTransmits;
    u_long          ipSystemStatsOutOctets;
    struct counter64 ipSystemStatsHCOutOctets;
    u_long          ipSystemStatsInMcastPkts;
    struct counter64 ipSystemStatsHCInMcastPkts;
    u_long          ipSystemStatsInMcastOctets;
    struct counter64 ipSystemStatsHCInMcastOctets;
    u_long          ipSystemStatsOutMcastPkts;
    struct counter64 ipSystemStatsHCOutMcastPkts;
    u_long          ipSystemStatsOutMcastOctets;
    struct counter64 ipSystemStatsHCOutMcastOctets;
    u_long          ipSystemStatsInBcastPkts;
    struct counter64 ipSystemStatsHCInBcastPkts;
    u_long          ipSystemStatsOutBcastPkts;
    struct counter64 ipSystemStatsHCOutBcastPkts;
    u_long          ipSystemStatsDiscontinuityTime;
    u_long          ipSystemStatsRefreshRate;
} ipSystemStatsTable_entry_t;
/*
 * The entry data structure for ipIfStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipIfStatsIPVersion;
    long            ipIfStatsIfIndex;

    /*
     * Entry columns
     */
    u_long          ipIfStatsInReceives;
    struct counter64 ipIfStatsHCInReceives;
    u_long          ipIfStatsInOctets;
    struct counter64 ipIfStatsHCInOctets;
    u_long          ipIfStatsInHdrErrors;
    u_long          ipIfStatsInNoRoutes;
    u_long          ipIfStatsInAddrErrors;
    u_long          ipIfStatsInUnknownProtos;
    u_long          ipIfStatsInTruncatedPkts;
    u_long          ipIfStatsInForwDatagrams;
    struct counter64 ipIfStatsHCInForwDatagrams;
    u_long          ipIfStatsReasmReqds;
    u_long          ipIfStatsReasmOKs;
    u_long          ipIfStatsReasmFails;
    u_long          ipIfStatsInDiscards;
    u_long          ipIfStatsInDelivers;
    struct counter64 ipIfStatsHCInDelivers;
    u_long          ipIfStatsOutRequests;
    struct counter64 ipIfStatsHCOutRequests;
    u_long          ipIfStatsOutForwDatagrams;
    struct counter64 ipIfStatsHCOutForwDatagrams;
    u_long          ipIfStatsOutDiscards;
    u_long          ipIfStatsOutFragReqds;
    u_long          ipIfStatsOutFragOKs;
    u_long          ipIfStatsOutFragFails;
    u_long          ipIfStatsOutFragCreates;
    u_long          ipIfStatsOutTransmits;
    struct counter64 ipIfStatsHCOutTransmits;
    u_long          ipIfStatsOutOctets;
    struct counter64 ipIfStatsHCOutOctets;
    u_long          ipIfStatsInMcastPkts;
    struct counter64 ipIfStatsHCInMcastPkts;
    u_long          ipIfStatsInMcastOctets;
    struct counter64 ipIfStatsHCInMcastOctets;
    u_long          ipIfStatsOutMcastPkts;
    struct counter64 ipIfStatsHCOutMcastPkts;
    u_long          ipIfStatsOutMcastOctets;
    struct counter64 ipIfStatsHCOutMcastOctets;
    u_long          ipIfStatsInBcastPkts;
    struct counter64 ipIfStatsHCInBcastPkts;
    u_long          ipIfStatsOutBcastPkts;
    struct counter64 ipIfStatsHCOutBcastPkts;
    u_long          ipIfStatsDiscontinuityTime;
    u_long          ipIfStatsRefreshRate;
} ipIfStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    struct counter64 c64_ret;
    u_long          ulong_ret;
} ipTrafficStats_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipTrafficStats_global_ret) */
/*
 * Process one packet at the same time, therefore unprotected access is acceptable
 */
static ipTrafficStats_return_t ipTrafficStats_global_ret;       /* static variables for retuning */

/*
 * ipTrafficStats_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ipTrafficStats_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 4, 31 };



/*
 * variable ipTrafficStats_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipTrafficStats mib section
 */

struct variable4 ipTrafficStats_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define IPSYSTEMSTATSINRECEIVES     2
    {
        IPSYSTEMSTATSINRECEIVES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 3}
    },
#define IPSYSTEMSTATSHCINRECEIVES       3
    {
        IPSYSTEMSTATSHCINRECEIVES, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 4}
    },
#define IPSYSTEMSTATSINOCTETS       4
    {
        IPSYSTEMSTATSINOCTETS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 5}
    },
#define IPSYSTEMSTATSHCINOCTETS     5
    {
        IPSYSTEMSTATSHCINOCTETS, ASN_COUNTER64, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 6}
    },
#define IPSYSTEMSTATSINHDRERRORS        6
    {
        IPSYSTEMSTATSINHDRERRORS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 7}
    },
#define IPSYSTEMSTATSINNOROUTES     7
    {
        IPSYSTEMSTATSINNOROUTES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 8}
    },
#define IPSYSTEMSTATSINADDRERRORS       8
    {
        IPSYSTEMSTATSINADDRERRORS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 9}
    },
#define IPSYSTEMSTATSINUNKNOWNPROTOS        9
    {
        IPSYSTEMSTATSINUNKNOWNPROTOS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 10}
    },
#define IPSYSTEMSTATSINTRUNCATEDPKTS        10
    {
        IPSYSTEMSTATSINTRUNCATEDPKTS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 11}
    },
#define IPSYSTEMSTATSINFORWDATAGRAMS        11
    {
        IPSYSTEMSTATSINFORWDATAGRAMS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 12}
    },
#define IPSYSTEMSTATSHCINFORWDATAGRAMS      12
    {
        IPSYSTEMSTATSHCINFORWDATAGRAMS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 13}
    },
#define IPSYSTEMSTATSREASMREQDS     13
    {
        IPSYSTEMSTATSREASMREQDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 14}
    },
#define IPSYSTEMSTATSREASMOKS       14
    {
        IPSYSTEMSTATSREASMOKS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 15}
    },
#define IPSYSTEMSTATSREASMFAILS     15
    {
        IPSYSTEMSTATSREASMFAILS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 16}
    },
#define IPSYSTEMSTATSINDISCARDS     16
    {
        IPSYSTEMSTATSINDISCARDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 17}
    },
#define IPSYSTEMSTATSINDELIVERS     17
    {
        IPSYSTEMSTATSINDELIVERS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 18}
    },
#define IPSYSTEMSTATSHCINDELIVERS       18
    {
        IPSYSTEMSTATSHCINDELIVERS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 19}
    },
#define IPSYSTEMSTATSOUTREQUESTS        19
    {
        IPSYSTEMSTATSOUTREQUESTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 20}
    },
#define IPSYSTEMSTATSHCOUTREQUESTS      20
    {
        IPSYSTEMSTATSHCOUTREQUESTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 21}
    },
#define IPSYSTEMSTATSOUTNOROUTES        21
    {
        IPSYSTEMSTATSOUTNOROUTES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 22}
    },
#define IPSYSTEMSTATSOUTFORWDATAGRAMS       22
    {
        IPSYSTEMSTATSOUTFORWDATAGRAMS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 23}
    },
#define IPSYSTEMSTATSHCOUTFORWDATAGRAMS     23
    {
        IPSYSTEMSTATSHCOUTFORWDATAGRAMS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 24}
    },
#define IPSYSTEMSTATSOUTDISCARDS        24
    {
        IPSYSTEMSTATSOUTDISCARDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 25}
    },
#define IPSYSTEMSTATSOUTFRAGREQDS       25
    {
        IPSYSTEMSTATSOUTFRAGREQDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 26}
    },
#define IPSYSTEMSTATSOUTFRAGOKS     26
    {
        IPSYSTEMSTATSOUTFRAGOKS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 27}
    },
#define IPSYSTEMSTATSOUTFRAGFAILS       27
    {
        IPSYSTEMSTATSOUTFRAGFAILS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 28}
    },
#define IPSYSTEMSTATSOUTFRAGCREATES     28
    {
        IPSYSTEMSTATSOUTFRAGCREATES, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 29}
    },
#define IPSYSTEMSTATSOUTTRANSMITS       29
    {
        IPSYSTEMSTATSOUTTRANSMITS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 30}
    },
#define IPSYSTEMSTATSHCOUTTRANSMITS     30
    {
        IPSYSTEMSTATSHCOUTTRANSMITS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 31}
    },
#define IPSYSTEMSTATSOUTOCTETS      31
    {
        IPSYSTEMSTATSOUTOCTETS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 32}
    },
#define IPSYSTEMSTATSHCOUTOCTETS        32
    {
        IPSYSTEMSTATSHCOUTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 33}
    },
#define IPSYSTEMSTATSINMCASTPKTS        33
    {
        IPSYSTEMSTATSINMCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 34}
    },
#define IPSYSTEMSTATSHCINMCASTPKTS      34
    {
        IPSYSTEMSTATSHCINMCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 35}
    },
#define IPSYSTEMSTATSINMCASTOCTETS      35
    {
        IPSYSTEMSTATSINMCASTOCTETS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 36}
    },
#define IPSYSTEMSTATSHCINMCASTOCTETS        36
    {
        IPSYSTEMSTATSHCINMCASTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 37}
    },
#define IPSYSTEMSTATSOUTMCASTPKTS       37
    {
        IPSYSTEMSTATSOUTMCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 38}
    },
#define IPSYSTEMSTATSHCOUTMCASTPKTS     38
    {
        IPSYSTEMSTATSHCOUTMCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 39}
    },
#define IPSYSTEMSTATSOUTMCASTOCTETS     39
    {
        IPSYSTEMSTATSOUTMCASTOCTETS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 40}
    },
#define IPSYSTEMSTATSHCOUTMCASTOCTETS       40
    {
        IPSYSTEMSTATSHCOUTMCASTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 41}
    },
#define IPSYSTEMSTATSINBCASTPKTS        41
    {
        IPSYSTEMSTATSINBCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 42}
    },
#define IPSYSTEMSTATSHCINBCASTPKTS      42
    {
        IPSYSTEMSTATSHCINBCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 43}
    },
#define IPSYSTEMSTATSOUTBCASTPKTS       43
    {
        IPSYSTEMSTATSOUTBCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 44}
    },
#define IPSYSTEMSTATSHCOUTBCASTPKTS     44
    {
        IPSYSTEMSTATSHCOUTBCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 45}
    },
#define IPSYSTEMSTATSDISCONTINUITYTIME      45
    {
        IPSYSTEMSTATSDISCONTINUITYTIME, ASN_TIMETICKS, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 46}
    },
#define IPSYSTEMSTATSREFRESHRATE        46
    {
        IPSYSTEMSTATSREFRESHRATE, ASN_UNSIGNED, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 47}
    },
#define IPIFSTATSTABLELASTCHANGE        1
    {
        IPIFSTATSTABLELASTCHANGE, ASN_TIMETICKS, RONLY, var_ipTrafficStats, 1,
        {2}
    },
#if defined(VTSS_HAS_PER_INTERFACE_IP_STATISTICS)
#define IPIFSTATSINRECEIVES     47
    {
        IPIFSTATSINRECEIVES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 3}
    },
#define IPIFSTATSHCINRECEIVES       48
    {
        IPIFSTATSHCINRECEIVES, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 4}
    },
#define IPIFSTATSINOCTETS       49
    {
        IPIFSTATSINOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 5}
    },
#define IPIFSTATSHCINOCTETS     50
    {
        IPIFSTATSHCINOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 6}
    },
#define IPIFSTATSINHDRERRORS        51
    {
        IPIFSTATSINHDRERRORS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 7}
    },
#define IPIFSTATSINNOROUTES     52
    {
        IPIFSTATSINNOROUTES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 8}
    },
#define IPIFSTATSINADDRERRORS       53
    {
        IPIFSTATSINADDRERRORS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 9}
    },
#define IPIFSTATSINUNKNOWNPROTOS        54
    {
        IPIFSTATSINUNKNOWNPROTOS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 10}
    },
#define IPIFSTATSINTRUNCATEDPKTS        55
    {
        IPIFSTATSINTRUNCATEDPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 11}
    },
#define IPIFSTATSINFORWDATAGRAMS        56
    {
        IPIFSTATSINFORWDATAGRAMS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 12}
    },
#define IPIFSTATSHCINFORWDATAGRAMS      57
    {
        IPIFSTATSHCINFORWDATAGRAMS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 13}
    },
#define IPIFSTATSREASMREQDS     58
    {
        IPIFSTATSREASMREQDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 14}
    },
#define IPIFSTATSREASMOKS       59
    {
        IPIFSTATSREASMOKS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 15}
    },
#define IPIFSTATSREASMFAILS     60
    {
        IPIFSTATSREASMFAILS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 16}
    },
#define IPIFSTATSINDISCARDS     61
    {
        IPIFSTATSINDISCARDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 17}
    },
#define IPIFSTATSINDELIVERS     62
    {
        IPIFSTATSINDELIVERS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 18}
    },
#define IPIFSTATSHCINDELIVERS       63
    {
        IPIFSTATSHCINDELIVERS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 19}
    },
#define IPIFSTATSOUTREQUESTS        64
    {
        IPIFSTATSOUTREQUESTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 20}
    },
#define IPIFSTATSHCOUTREQUESTS      65
    {
        IPIFSTATSHCOUTREQUESTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 21}
    },
#define IPIFSTATSOUTFORWDATAGRAMS       66
    {
        IPIFSTATSOUTFORWDATAGRAMS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 23}
    },
#define IPIFSTATSHCOUTFORWDATAGRAMS     67
    {
        IPIFSTATSHCOUTFORWDATAGRAMS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 24}
    },
#define IPIFSTATSOUTDISCARDS        68
    {
        IPIFSTATSOUTDISCARDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 25}
    },
#define IPIFSTATSOUTFRAGREQDS       69
    {
        IPIFSTATSOUTFRAGREQDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 26}
    },
#define IPIFSTATSOUTFRAGOKS     70
    {
        IPIFSTATSOUTFRAGOKS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 27}
    },
#define IPIFSTATSOUTFRAGFAILS       71
    {
        IPIFSTATSOUTFRAGFAILS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 28}
    },
#define IPIFSTATSOUTFRAGCREATES     72
    {
        IPIFSTATSOUTFRAGCREATES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 29}
    },
#define IPIFSTATSOUTTRANSMITS       73
    {
        IPIFSTATSOUTTRANSMITS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 30}
    },
#define IPIFSTATSHCOUTTRANSMITS     74
    {
        IPIFSTATSHCOUTTRANSMITS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 31}
    },
#define IPIFSTATSOUTOCTETS      75
    {
        IPIFSTATSOUTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 32}
    },
#define IPIFSTATSHCOUTOCTETS        76
    {
        IPIFSTATSHCOUTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 33}
    },
#define IPIFSTATSINMCASTPKTS        77
    {
        IPIFSTATSINMCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 34}
    },
#define IPIFSTATSHCINMCASTPKTS      78
    {
        IPIFSTATSHCINMCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 35}
    },
#define IPIFSTATSINMCASTOCTETS      79
    {
        IPIFSTATSINMCASTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 36}
    },
#define IPIFSTATSHCINMCASTOCTETS        80
    {
        IPIFSTATSHCINMCASTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 37}
    },
#define IPIFSTATSOUTMCASTPKTS       81
    {
        IPIFSTATSOUTMCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 38}
    },
#define IPIFSTATSHCOUTMCASTPKTS     82
    {
        IPIFSTATSHCOUTMCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 39}
    },
#define IPIFSTATSOUTMCASTOCTETS     83
    {
        IPIFSTATSOUTMCASTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 40}
    },
#define IPIFSTATSHCOUTMCASTOCTETS       84
    {
        IPIFSTATSHCOUTMCASTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 41}
    },
#define IPIFSTATSINBCASTPKTS        85
    {
        IPIFSTATSINBCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 42}
    },
#define IPIFSTATSHCINBCASTPKTS      86
    {
        IPIFSTATSHCINBCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 43}
    },
#define IPIFSTATSOUTBCASTPKTS       87
    {
        IPIFSTATSOUTBCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 44}
    },
#define IPIFSTATSHCOUTBCASTPKTS     88
    {
        IPIFSTATSHCOUTBCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 45}
    },
#define IPIFSTATSDISCONTINUITYTIME      89
    {
        IPIFSTATSDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_ipIfStatsTable,
        3, {3, 1, 46}
    },
#define IPIFSTATSREFRESHRATE        90
    {
        IPIFSTATSREFRESHRATE, ASN_UNSIGNED, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 47}
    },
#endif  // VTSS_HAS_PER_INTERFACE_IP_STATISTICS
};

/*
 * Initializes the ipTrafficStats module
 */
static void
init_ipTrafficStats(void)
{
    // Register mibContextTable
    mibContextTable_register(ipTrafficStats_variables_oid,
                             sizeof(ipTrafficStats_variables_oid) / sizeof(oid),
                             "IP-MIB : ipTrafficStats");

    DEBUGMSGTL(("ipTrafficStats", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ipTrafficStats", ipTrafficStats_variables, variable4,
                 ipTrafficStats_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


static int
get_ipTrafficStatsScalar(ipTrafficStats_scalar_t *scalar_entry)
{
    u64 ipIfStatsTableLastChange;
    (void) vtss_ip_interfaces_last_change (&ipIfStatsTableLastChange);
    scalar_entry->ipIfStatsTableLastChange = (u32) (ipIfStatsTableLastChange * 100);
    return VTSS_RC_OK;
}

/*
 * var_ipTrafficStats():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_ipTrafficStats(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    ipTrafficStats_scalar_t ipTrafficStats_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }

    if (get_ipTrafficStatsScalar(&ipTrafficStats_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPIFSTATSTABLELASTCHANGE: {
        ipTrafficStats_global_ret.ulong_ret =
            ipTrafficStats_scalar_entry.ipIfStatsTableLastChange;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipTrafficStats\n",
                    vp->magic));
    }
    return NULL;
}

#define VTSS_HC_2_SNMP_HC(VTSS_HC, SNMP_HC, HC, _PREFIX_) \
    vtss_snmp_u64_to_counter64(&SNMP_HC->_PREFIX_##HC, VTSS_HC->HC)

#define VTSS_C_2_SNMP_C(VTSS_C, SNMP_C, C, _PREFIX_) \
{\
    (SNMP_C)->_PREFIX_##C = (VTSS_C)->C;\
}

#define VTSS_TS_2_SNMP_TS(VTSS_TS, SNMP_TS, TS, _PREFIX_) \
{\
    (SNMP_TS)->_PREFIX_##TS = (VTSS_TS)->TS.seconds* 100 + (VTSS_TS)->TS.nanoseconds* 10000;\
}

static void vtss_ip_stat_system2ipSystemStats(vtss_appl_ip_statistics_t *entry, ipSystemStatsTable_entry_t *table_entry)
{
    VTSS_C_2_SNMP_C(entry, table_entry, InReceives, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InHdrErrors, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InNoRoutes, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InAddrErrors, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InUnknownProtos, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InTruncatedPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InForwDatagrams, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmReqds, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmOKs, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmFails, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InDiscards, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InDelivers, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutRequests, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutNoRoutes, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutForwDatagrams, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutDiscards, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragReqds, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragOKs, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragFails, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragCreates, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutTransmits, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InMcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InMcastOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutMcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutMcastOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InBcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutBcastPkts, ipSystemStats);
    VTSS_TS_2_SNMP_TS(entry, table_entry, DiscontinuityTime, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, RefreshRate, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInReceives, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInForwDatagrams, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInDelivers, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutRequests, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutForwDatagrams, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutTransmits, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInMcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInMcastOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutMcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutMcastOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInBcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutBcastPkts, ipSystemStats);
}

static int getfirst_ipSystemStatsTableEntry(ipSystemStatsTable_entry_t *table_entry)
{
    vtss_appl_ip_statistics_t statistics;

    // First try IPv4 statistics, and if that fails, try IPv6 statistics
    if (vtss_appl_ip_system_statistics_ipv4_get(&statistics) != VTSS_RC_OK) {
        if (vtss_appl_ip_system_statistics_ipv6_get(&statistics) != VTSS_RC_OK) {
            return VTSS_RC_ERROR;
        } else {
            table_entry->ipSystemStatsIPVersion = INET_VERSION_IPV6;
        }
    } else {
        table_entry->ipSystemStatsIPVersion = INET_VERSION_IPV4;
    }

    vtss_ip_stat_system2ipSystemStats(&statistics, table_entry);

    return VTSS_RC_OK;
}

static int get_ipSystemStatsTableEntry(ipSystemStatsTable_entry_t *table_entry, BOOL getnext)
{
    vtss_appl_ip_statistics_t statistics;

    if (getnext) {
        switch (table_entry->ipSystemStatsIPVersion) {
        case INET_VERSION_UNKNOWN:
            // Get IPv4 statistics
            if (vtss_appl_ip_system_statistics_ipv4_get(&statistics) == VTSS_RC_OK) {
                table_entry->ipSystemStatsIPVersion = INET_VERSION_IPV4;
                break;
            }

        // Fall through

        case INET_VERSION_IPV4:
            // Get IPv6 statistics
            if (vtss_appl_ip_system_statistics_ipv6_get(&statistics) == VTSS_RC_OK) {
                table_entry->ipSystemStatsIPVersion = INET_VERSION_IPV6;
                break;
            }

        // Fall through

        default:
            return VTSS_RC_ERROR;
        }
    } else {
        // Get particular version
        switch (table_entry->ipSystemStatsIPVersion) {
        case INET_VERSION_IPV4:
            if (vtss_appl_ip_system_statistics_ipv4_get(&statistics) != VTSS_RC_OK) {
                return VTSS_RC_ERROR;
            }

            break;

        case INET_VERSION_IPV6:
            if (vtss_appl_ip_system_statistics_ipv6_get(&statistics) != VTSS_RC_OK) {
                return VTSS_RC_ERROR;
            }

            break;

        default:
            return VTSS_RC_ERROR;
        }
    }

    vtss_ip_stat_system2ipSystemStats(&statistics, table_entry);

    return VTSS_RC_OK;
}

static int
parse_ipSystemStatsTable(oid *name,
                         size_t *length,
                         int exact,
                         ipSystemStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipSystemStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipSystemStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipSystemStatsTable(oid *name,
                           size_t *length,
                           ipSystemStatsTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ipSystemStatsIPVersion;

    *length = name_pos;
    return 0;
}

/*
 * var_ipSystemStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipTrafficStats above.
 */
u_char         *
var_ipSystemStatsTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipSystemStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_ipSystemStatsTable(name, length, exact,
                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipSystemStatsTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipSystemStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipSystemStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPSYSTEMSTATSINRECEIVES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINRECEIVES: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINHDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInHdrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINADDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInAddrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINUNKNOWNPROTOS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInUnknownProtos;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINTRUNCATEDPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInTruncatedPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSREASMREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREASMOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREASMFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINDELIVERS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINDELIVERS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTREQUESTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTREQUESTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGCREATES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragCreates;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTTRANSMITS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTTRANSMITS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSDISCONTINUITYTIME: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsDiscontinuityTime;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREFRESHRATE: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsRefreshRate;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ipSystemStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

#if defined(VTSS_HAS_PER_INTERFACE_IP_STATISTICS)
static void vtss_ip_stat_interface2ipIfStats(vtss_appl_ip_statistics_t *data, ipIfStatsTable_entry_t *table_entry)
{
    VTSS_C_2_SNMP_C(data, table_entry, InReceives, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InHdrErrors, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InNoRoutes, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InAddrErrors, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InUnknownProtos, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InTruncatedPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InForwDatagrams, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmReqds, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmOKs, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmFails, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InDiscards, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InDelivers, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutRequests, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutForwDatagrams, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutDiscards, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragReqds, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragOKs, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragFails, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragCreates, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutTransmits, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InMcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InMcastOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutMcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutMcastOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InBcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutBcastPkts, ipIfStats);
    VTSS_TS_2_SNMP_TS(data, table_entry, DiscontinuityTime, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, RefreshRate, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInReceives, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInForwDatagrams, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInDelivers, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutRequests, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutForwDatagrams, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutTransmits, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInMcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInMcastOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutMcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutMcastOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInBcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutBcastPkts, ipIfStats);
}

static BOOL get_next_ipIfStatsTableEntryByKey(ipIfStatsTable_entry_t *table_entry)
{
    vtss_ifindex_t            ifindex;
    vtss_appl_ip_statistics_t statistics;
    bool                      found = false;

    vtss_ifindex_cast_to_u32(ifindex) = table_entry->ipIfStatsIfIndex;

    switch (table_entry->ipIfStatsIPVersion) {
    case INET_VERSION_UNKNOWN:
    case INET_VERSION_IPV4:
        // Get IPv4 statistics for next VLAN I/F
        while (vtss_appl_ip_if_itr(&ifindex, &ifindex, true /* VLAN interfaces, only */) == VTSS_RC_OK) {
            if (vtss_appl_ip_if_statistics_ipv4_get(ifindex, &statistics) == VTSS_RC_OK) {
                table_entry->ipIfStatsIPVersion = INET_VERSION_IPV4;
                found = true;
                break;
            }
        }

        if (found) {
            break;
        }

        // Otherwise, start over on IPv6.
        ifindex = VTSS_IFINDEX_NONE;

    // Fall through

    case INET_VERSION_IPV6:
        // Get IPv6 statistics for next VLAN I/F
        while (vtss_appl_ip_if_itr(&ifindex, &ifindex, true /* VLAN interfaces, only */) == VTSS_RC_OK) {
            if (vtss_appl_ip_if_statistics_ipv6_get(ifindex, &statistics) == VTSS_RC_OK) {
                table_entry->ipIfStatsIPVersion = INET_VERSION_IPV6;
                found = true;
                break;
            }
        }

        if (found) {
            break;
        }

    // Fall through

    default:
        return FALSE;
    }

    table_entry->ipIfStatsIfIndex = vtss_ifindex_cast_to_u32(ifindex);
    vtss_ip_stat_interface2ipIfStats(&statistics, table_entry);
    return TRUE;
}

static BOOL getfirst_ipIfStatsTableEntry(ipIfStatsTable_entry_t *table_entry)
{
    table_entry->ipIfStatsIPVersion = MESA_IP_TYPE_NONE;
    table_entry->ipIfStatsIfIndex   = 0;
    return get_next_ipIfStatsTableEntryByKey(table_entry);
}

static BOOL get_ipIfStatsTableEntryByKey(ipIfStatsTable_entry_t *table_entry)
{
    ipIfStatsTable_entry_t  tmp = *table_entry;

    if (tmp.ipIfStatsIfIndex > 0) {
        --tmp.ipIfStatsIfIndex;
    } else if (tmp.ipIfStatsIPVersion > 0) {
        --tmp.ipIfStatsIPVersion;
        tmp.ipIfStatsIfIndex = 0x7fffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == get_next_ipIfStatsTableEntryByKey (&tmp) ||
         table_entry->ipIfStatsIPVersion != tmp.ipIfStatsIPVersion ||
         table_entry->ipIfStatsIfIndex != tmp.ipIfStatsIfIndex) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}


static int
get_ipIfStatsTableEntry(ipIfStatsTable_entry_t *table_entry, BOOL getnext)
{
    if ( (TRUE == getnext && FALSE == get_next_ipIfStatsTableEntryByKey(table_entry))  ||
         (FALSE == getnext && FALSE == get_ipIfStatsTableEntryByKey(table_entry)) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
parse_ipIfStatsTable(oid *name,
                     size_t *length,
                     int exact, ipIfStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (!getfirst_ipIfStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipIfStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ipIfStatsIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipIfStatsTable(oid *name,
                       size_t *length,
                       ipIfStatsTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ipIfStatsIPVersion;
    name[name_pos++] = (oid) table_entry->ipIfStatsIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipIfStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipTrafficStats above.
 */
u_char         *
var_ipIfStatsTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipIfStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipIfStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipIfStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipIfStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipIfStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPIFSTATSINRECEIVES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINRECEIVES: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINHDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInHdrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINADDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInAddrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINUNKNOWNPROTOS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInUnknownProtos;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINTRUNCATEDPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInTruncatedPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSREASMREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREASMOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREASMFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINDELIVERS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINDELIVERS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTREQUESTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTREQUESTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGCREATES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragCreates;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTTRANSMITS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTTRANSMITS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSDISCONTINUITYTIME: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsDiscontinuityTime;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREFRESHRATE: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsRefreshRate;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipIfStatsTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif  // VTSS_HAS_PER_INTERFACE_IP_STATISTICS

/*
 * The entry data structure for icmpStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            icmpStatsIPVersion;

    /*
     * Entry columns
     */
    u_long          icmpStatsInMsgs;
    u_long          icmpStatsInErrors;
    u_long          icmpStatsOutMsgs;
    u_long          icmpStatsOutErrors;
} icmpStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    u_long          ulong_ret;
} icmpStatsTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */

/*lint -esym(459, icmpStatsTable_global_ret) */

/*
 * Process one packet at the same time, therefore unprotected access is acceptable
 */
static icmpStatsTable_return_t icmpStatsTable_global_ret;       /* static variables for retuning */

/*
 * icmpStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             icmpStatsTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 5, 29 };



/*
 * variable icmpStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the icmpStatsTable mib section
 */

struct variable2 icmpStatsTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define ICMPSTATSINMSGS     1
    {ICMPSTATSINMSGS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 2}},
#define ICMPSTATSINERRORS       2
    {ICMPSTATSINERRORS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 3}},
#define ICMPSTATSOUTMSGS        3
    {ICMPSTATSOUTMSGS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 4}},
#define ICMPSTATSOUTERRORS      4
    {
        ICMPSTATSOUTERRORS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2,
        {1, 5}
    },
};

/*
 * Initializes the icmpStatsTable module
 */
static void
init_icmpStatsTable(void)
{
    // Register mibContextTable
    mibContextTable_register(icmpStatsTable_variables_oid,
                             sizeof(icmpStatsTable_variables_oid) / sizeof(oid),
                             "IP-MIB : icmpStatsTable");

    DEBUGMSGTL(("icmpStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("icmpStatsTable", icmpStatsTable_variables, variable2,
                 icmpStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
getfirst_icmpStatsTableEntry(icmpStatsTable_entry_t *table_entry)
{
    // TODO
    return VTSS_RC_ERROR;
}

static int
get_icmpStatsTableEntry(icmpStatsTable_entry_t *table_entry, BOOL getnext)
{
    // TODO
    return VTSS_RC_ERROR;
}

static int
parse_icmpStatsTable(oid *name,
                     size_t *length,
                     int exact, icmpStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_icmpStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->icmpStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_icmpStatsTable(oid *name,
                       size_t *length,
                       icmpStatsTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->icmpStatsIPVersion;

    *length = name_pos;
    return 0;
}

/*
 * var_icmpStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_icmpStatsTable above.
 */
u_char         *
var_icmpStatsTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    icmpStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_icmpStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_icmpStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_icmpStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_icmpStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ICMPSTATSINMSGS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsInMsgs;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSINERRORS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsInErrors;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSOUTMSGS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsOutMsgs;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSOUTERRORS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsOutErrors;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_icmpStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for icmpMsgStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            icmpMsgStatsIPVersion;
    long            icmpMsgStatsType;

    /*
     * Entry columns
     */
    u_long          icmpMsgStatsInPkts;
    u_long          icmpMsgStatsOutPkts;
} icmpMsgStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    u_long          ulong_ret;
} icmpMsgStatsTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */

/*lint -esym(459, icmpMsgStatsTable_global_ret) */

/*
 * Process one packet at the same time, therefore unprotected access is acceptable
 */
static icmpMsgStatsTable_return_t icmpMsgStatsTable_global_ret; /* static variables for retuning */

/*
 * icmpMsgStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             icmpMsgStatsTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 5, 30 };



/*
 * variable icmpMsgStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the icmpMsgStatsTable mib section
 */

struct variable2 icmpMsgStatsTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define ICMPMSGSTATSINPKTS      1
    {
        ICMPMSGSTATSINPKTS, ASN_COUNTER, RONLY, var_icmpMsgStatsTable, 2,
        {1, 3}
    },
#define ICMPMSGSTATSOUTPKTS     2
    {
        ICMPMSGSTATSOUTPKTS, ASN_COUNTER, RONLY, var_icmpMsgStatsTable, 2,
        {1, 4}
    },
};

/*
 * Initializes the icmpMsgStatsTable module
 */
static void
init_icmpMsgStatsTable(void)
{
    // Register mibContextTable
    mibContextTable_register(icmpMsgStatsTable_variables_oid,
                             sizeof(icmpMsgStatsTable_variables_oid) / sizeof(oid),
                             "IP-MIB : icmpMsgStatsTable");

    DEBUGMSGTL(("icmpMsgStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("icmpMsgStatsTable", icmpMsgStatsTable_variables,
                 variable2, icmpMsgStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
getfirst_icmpMsgStatsTableEntry(icmpMsgStatsTable_entry_t *table_entry)
{
    // TODO
    return VTSS_RC_ERROR;
}

static int
get_icmpMsgStatsTableEntry(icmpMsgStatsTable_entry_t *table_entry,
                           BOOL getnext)
{
    // TODO
    return VTSS_RC_ERROR;
}

static int
parse_icmpMsgStatsTable(oid *name,
                        size_t *length,
                        int exact, icmpMsgStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_icmpMsgStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->icmpMsgStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->icmpMsgStatsType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_icmpMsgStatsTable(oid *name,
                          size_t *length,
                          icmpMsgStatsTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->icmpMsgStatsIPVersion;
    name[name_pos++] = (oid) table_entry->icmpMsgStatsType;

    *length = name_pos;
    return 0;
}

/*
 * var_icmpMsgStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_icmpMsgStatsTable above.
 */
u_char         *
var_icmpMsgStatsTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    icmpMsgStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_icmpMsgStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_icmpMsgStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_icmpMsgStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_icmpMsgStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ICMPMSGSTATSINPKTS: {
        icmpMsgStatsTable_global_ret.ulong_ret =
            table_entry.icmpMsgStatsInPkts;
        *var_len = sizeof(icmpMsgStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpMsgStatsTable_global_ret.ulong_ret;
    }
    case ICMPMSGSTATSOUTPKTS: {
        icmpMsgStatsTable_global_ret.ulong_ret =
            table_entry.icmpMsgStatsOutPkts;
        *var_len = sizeof(icmpMsgStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpMsgStatsTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_icmpMsgStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for ipNetToPhysicalTable
 */
typedef struct {
    /* Entry keys */
    long           ipNetToPhysicalIfIndex;
    long           ipNetToPhysicalNetAddressType;
    char             ipNetToPhysicalNetAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipNetToPhysicalNetAddress_len;

    /* Entry columns */
    char             ipNetToPhysicalPhysAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipNetToPhysicalPhysAddress_len;
    u_long             ipNetToPhysicalLastUpdated;
    long             ipNetToPhysicalType;
    long             ipNetToPhysicalState;
    long             ipNetToPhysicalRowStatus;
} ipNetToPhysicalTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipNetToPhysicalTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipNetToPhysicalTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipNetToPhysicalTable_return_t ipNetToPhysicalTable_global_ret; /* static variables for retuning */

/*
 * ipNetToPhysicalTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipNetToPhysicalTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 35};



/*
 * variable ipNetToPhysicalTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipNetToPhysicalTable mib section
 */

struct variable2 ipNetToPhysicalTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPNETTOPHYSICALPHYSADDRESS      1
    {IPNETTOPHYSICALPHYSADDRESS, ASN_OCTET_STR, RONLY, var_ipNetToPhysicalTable, 2, {1, 4}},
#if 0
#define IPNETTOPHYSICALLASTUPDATED      2
    {IPNETTOPHYSICALLASTUPDATED, ASN_TIMETICKS, RONLY, var_ipNetToPhysicalTable, 2, {1, 5}},
#define IPNETTOPHYSICALTYPE     3
    {IPNETTOPHYSICALTYPE, ASN_INTEGER, RWRITE, var_ipNetToPhysicalTable, 2, {1, 6}},
#define IPNETTOPHYSICALSTATE        4
    {IPNETTOPHYSICALSTATE, ASN_INTEGER, RONLY, var_ipNetToPhysicalTable, 2, {1, 7}},
#endif
#define IPNETTOPHYSICALROWSTATUS        5
    {IPNETTOPHYSICALROWSTATUS, ASN_INTEGER, RONLY, var_ipNetToPhysicalTable, 2, {1, 8}},
};

/*
 * Initializes the ipNetToPhysicalTable module
 */
static void
init_ipNetToPhysicalTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipNetToPhysicalTable_variables_oid,
                             sizeof(ipNetToPhysicalTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipNetToPhysicalTable");

    DEBUGMSGTL(("ipNetToPhysicalTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipNetToPhysicalTable", ipNetToPhysicalTable_variables, variable2,
                 ipNetToPhysicalTable_variables_oid);

    /* place any other initialization junk you need here */
}

static BOOL vtss_ip_nb_get_nextByKey (ipNetToPhysicalTable_entry_t *table_entry)
{
    vtss_appl_ip_neighbor_key_t    key, next;
    vtss_appl_ip_neighbor_status_t status;
    mesa_ipv4_t                    n_v4_addr;
    iftable_info_t                 info;

    info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    if (!ifIndex_get_first_by_type(&info)) {
        return FALSE;
    }

    if (table_entry->ipNetToPhysicalIfIndex < (long)info.ifIndex) {
        key.ifindex = vtss_ifindex_cast_from_u32(info.if_id, VTSS_IFINDEX_TYPE_VLAN);
        key.dip.type = MESA_IP_TYPE_IPV4;
        key.dip.addr.ipv4 = 0;
    } else {
        info.ifIndex = table_entry->ipNetToPhysicalIfIndex;
        if (!ifIndex_get_valid(&info) || info.type != IFTABLE_IFINDEX_TYPE_VLAN) {
            return FALSE;
        }

        key.ifindex = vtss_ifindex_cast_from_u32(info.if_id, VTSS_IFINDEX_TYPE_VLAN);

        if (table_entry->ipNetToPhysicalNetAddressType == MESA_IP_TYPE_IPV4) {
            key.dip.type = MESA_IP_TYPE_IPV4;
            memcpy(&n_v4_addr, table_entry->ipNetToPhysicalNetAddress, sizeof(key.dip.addr.ipv4));
            key.dip.addr.ipv4 = ntohl(n_v4_addr);
        } else {
            key.dip.type = MESA_IP_TYPE_IPV6;
            memcpy(&key.dip.addr.ipv6, table_entry->ipNetToPhysicalNetAddress, sizeof(key.dip.addr.ipv6));
        }
    }

    if (vtss_appl_ip_neighbor_itr(&key, &next) != VTSS_RC_OK) {
        return FALSE;
    }

    if ((info.if_id = vtss_ifindex_as_vlan(next.ifindex)) == 0) {
        return FALSE;
    }

    if (vtss_appl_ip_neighbor_status_get(&next, &status) != VTSS_RC_OK) {
        return FALSE;
    }

    info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    (void)ifIndex_get_by_interface(&info);
    table_entry->ipNetToPhysicalIfIndex = info.ifIndex;

    if (next.dip.type == MESA_IP_TYPE_IPV4) {
        table_entry->ipNetToPhysicalNetAddressType = INET_ADDRESS_IPV4;
        table_entry->ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV4_LEN;
        n_v4_addr = htonl(next.dip.addr.ipv4);
        memcpy(table_entry->ipNetToPhysicalNetAddress, &n_v4_addr, INET_ADDRESS_IPV4_LEN);
    } else {
        table_entry->ipNetToPhysicalNetAddressType = INET_ADDRESS_IPV6;
        table_entry->ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV6_LEN;
        memcpy(table_entry->ipNetToPhysicalNetAddress, &next.dip.addr.ipv6, INET_ADDRESS_IPV6_LEN);
    }

    memcpy(table_entry->ipNetToPhysicalPhysAddress, &status.dmac, 6);
    table_entry->ipNetToPhysicalPhysAddress_len = 6;
    table_entry->ipNetToPhysicalRowStatus = 1;

    return true;
}

static BOOL get_next_ipNetToPhysicalTableEntryByKey(ipNetToPhysicalTable_entry_t *table_entry)
{
    ipNetToPhysicalTable_entry_t tmp = *table_entry;

    if ( FALSE == prepare_get_next_inetAddress(&tmp.ipNetToPhysicalNetAddressType,
                                               tmp.ipNetToPhysicalNetAddress, SNMP_ASN_OCTET_STR_MAX_LEN, &tmp.ipNetToPhysicalNetAddress_len)) {
        tmp.ipNetToPhysicalNetAddressType = INET_VERSION_IPV4;
        tmp.ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV4_LEN;
        memset(tmp.ipNetToPhysicalNetAddress, 0, INET_ADDRESS_IPV4_LEN);
        tmp.ipNetToPhysicalIfIndex++;
    }

    if ( FALSE == vtss_ip_nb_get_nextByKey(&tmp) ) {
        return FALSE;
    }

    memcpy(table_entry, &tmp, sizeof(tmp));
    return TRUE;
}

static BOOL get_pre_ipNetToPhysicalTableEntryKey(ipNetToPhysicalTable_entry_t *table_entry)
{
    mesa_rc rc = get_pre_inetAddress(table_entry->ipNetToPhysicalNetAddress, &table_entry->ipNetToPhysicalNetAddress_len );
    if ( rc == VTSS_RC_INCOMPLETE) {
        T_E("VTSS_RC_INCOMPLETE");
        return FALSE;
    } else if ( rc != VTSS_RC_OK) {
        memset( table_entry->ipNetToPhysicalNetAddress, 0xff, table_entry->ipNetToPhysicalNetAddress_len );
        if (table_entry->ipNetToPhysicalNetAddressType) {
            table_entry->ipNetToPhysicalNetAddressType--;
        } else if (table_entry->ipNetToPhysicalIfIndex != 0) {
            table_entry->ipNetToPhysicalNetAddressType = 0x7fffffff;
            table_entry->ipNetToPhysicalIfIndex--;
        } else {
            T_E("overflow");
            return FALSE;
        }
    }

    return TRUE;
}

static int
getfirst_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry)
{
    return !get_next_ipNetToPhysicalTableEntryByKey(table_entry);
}

static int
get_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry, BOOL getnext)
{
    ipNetToPhysicalTable_entry_t tmp = *table_entry;
    if ( getnext == TRUE && FALSE == get_next_ipNetToPhysicalTableEntryByKey(&tmp)) {
        return VTSS_RC_ERROR;
    } else if (getnext == FALSE ) {
        if ( FALSE == get_pre_ipNetToPhysicalTableEntryKey( &tmp) || FALSE == get_next_ipNetToPhysicalTableEntryByKey(&tmp)
             || tmp.ipNetToPhysicalIfIndex != table_entry->ipNetToPhysicalIfIndex ||
             tmp.ipNetToPhysicalNetAddressType != table_entry->ipNetToPhysicalNetAddressType ||
             tmp.ipNetToPhysicalNetAddress_len != table_entry->ipNetToPhysicalNetAddress_len ||
             memcmp(tmp.ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress_len)) {
            return VTSS_RC_ERROR;
        }
    }

    memcpy(table_entry, &tmp, sizeof(tmp));

    return VTSS_RC_OK;
}

static int
set_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

typedef enum {
    IPNETTOPHYSICALIFINDEX,
    IPNETTOPHYSICALNETADDRESSTYPE,
    IPNETTOPHYSICALNETADDRESS_LEN,
    IPNETTOPHYSICALNETADDRESS
} ipNetToPhysicalTable_key_t;

static BOOL subtract_ipNetToPhysicalTable(ipNetToPhysicalTable_entry_t *table_entry, ipNetToPhysicalTable_key_t start_key, size_t offsetof_key)
{
    switch (start_key) {
    case IPNETTOPHYSICALNETADDRESS: {
        char *offset = table_entry->ipNetToPhysicalNetAddress + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1;
                return TRUE;
            }
            *(offset--) = 0xff;
        } while (offset >= table_entry->ipNetToPhysicalNetAddress);
    }
    case IPNETTOPHYSICALNETADDRESS_LEN: {
        if (table_entry->ipNetToPhysicalNetAddress_len) {
            table_entry->ipNetToPhysicalNetAddress_len--;
            return TRUE;
        }
    }
    case IPNETTOPHYSICALNETADDRESSTYPE: {
        if (table_entry->ipNetToPhysicalNetAddressType) {
            table_entry->ipNetToPhysicalNetAddressType--;
            return TRUE;
        }
    }
    case IPNETTOPHYSICALIFINDEX: {
        if (table_entry->ipNetToPhysicalIfIndex) {
            table_entry->ipNetToPhysicalIfIndex--;
            return TRUE;
        }
    }
    default:
        return FALSE;

    }
}

static int
parse_ipNetToPhysicalTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           ipNetToPhysicalTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipNetToPhysicalTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipNetToPhysicalIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ipNetToPhysicalNetAddressType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if (FALSE == subtract_ipNetToPhysicalTable(table_entry, IPNETTOPHYSICALNETADDRESSTYPE, 0)) {
            return 1;
        }
        goto parse_end;
    }

    if (*length > op_pos) {
        len = (unsigned int) * op++;
        len = (unsigned int )len > sizeof(table_entry->ipNetToPhysicalNetAddress) ? sizeof(table_entry->ipNetToPhysicalNetAddress) : len;
        if (!len) {
            if (FALSE == subtract_ipNetToPhysicalTable(table_entry, IPNETTOPHYSICALNETADDRESS_LEN, 0)) {
                return 1;
            }
            goto parse_end;
        }
        op_pos++;
        table_entry->ipNetToPhysicalNetAddress_len = len;
        cp = (u_char *) table_entry->ipNetToPhysicalNetAddress;
        while (len-- > 0) {
            if (*length > op_pos) {
                *cp++ = (u_char) * op++;
                op_pos++;
            } else if (exact) {
                return -1;
            } else {
                if (FALSE == subtract_ipNetToPhysicalTable(table_entry, IPNETTOPHYSICALNETADDRESS, cp - (u_char *)table_entry->ipNetToPhysicalNetAddress)) {
                    return 1;
                }
                goto parse_end;
            }
        }
    } else if (exact) {
        return -1;
    } else {
        if (FALSE == subtract_ipNetToPhysicalTable(table_entry, IPNETTOPHYSICALNETADDRESS_LEN, 0)) {
            return 1;
        }
        goto parse_end;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

parse_end:
    return 0;
}

static int
fillobj_ipNetToPhysicalTable(oid     *name,
                             size_t  *length,
                             ipNetToPhysicalTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipNetToPhysicalIfIndex;
    name[name_pos++] = (oid) table_entry->ipNetToPhysicalNetAddressType;
    len = (int) table_entry->ipNetToPhysicalNetAddress_len;
    name[name_pos++] = (oid) table_entry->ipNetToPhysicalNetAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->ipNetToPhysicalNetAddress[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_ipNetToPhysicalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipNetToPhysicalTable above.
 */
u_char *
var_ipNetToPhysicalTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipNetToPhysicalTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipNetToPhysicalTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipNetToPhysicalTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipNetToPhysicalTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IPNETTOPHYSICALROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_ipNetToPhysicalRowStatus;
                }
                return NULL;
            }
            if (fillobj_ipNetToPhysicalTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPNETTOPHYSICALPHYSADDRESS: {
        *write_method = write_ipNetToPhysicalPhysAddress;
        *var_len = table_entry.ipNetToPhysicalPhysAddress_len;
        memcpy(ipNetToPhysicalTable_global_ret.string_ret, table_entry.ipNetToPhysicalPhysAddress, *var_len);
        ipNetToPhysicalTable_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ipNetToPhysicalTable_global_ret.string_ret;
    }
#if 0
    case IPNETTOPHYSICALLASTUPDATED: {
        ipNetToPhysicalTable_global_ret.ulong_ret = table_entry.ipNetToPhysicalLastUpdated;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.ulong_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.ulong_ret;
    }
    case IPNETTOPHYSICALTYPE: {
        *write_method = write_ipNetToPhysicalType;
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalType;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
    case IPNETTOPHYSICALSTATE: {
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalState;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
#endif
    case IPNETTOPHYSICALROWSTATUS: {
        *write_method = write_ipNetToPhysicalRowStatus;
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalRowStatus;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipNetToPhysicalTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipNetToPhysicalPhysAddress(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalPhysAddress: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SNMP_ASN_OCTET_STR_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalPhysAddress: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.ipNetToPhysicalPhysAddress, var_val, var_val_len);
        table_entry.ipNetToPhysicalPhysAddress_len = var_val_len;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipNetToPhysicalType(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipNetToPhysicalType = set_value;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipNetToPhysicalRowStatus(int      action,
                               u_char   *var_val,
                               u_char   var_val_type,
                               size_t   var_val_len,
                               u_char   *statP,
                               oid      *name,
                               size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipNetToPhysicalRowStatus = set_value;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipDefaultRouterTable
 */
typedef struct {
    /* Entry keys */
    long           ipDefaultRouterAddressType;
    char             ipDefaultRouterAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipDefaultRouterAddress_len;
    long           ipDefaultRouterIfIndex;

    /* Entry columns */
    u_long             ipDefaultRouterLifetime;
    long             ipDefaultRouterPreference;
} ipDefaultRouterTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipDefaultRouterTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipDefaultRouterTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipDefaultRouterTable_return_t ipDefaultRouterTable_global_ret; /* static variables for retuning */

/*
 * ipDefaultRouterTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipDefaultRouterTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 37};



/*
 * variable ipDefaultRouterTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipDefaultRouterTable mib section
 */

struct variable2 ipDefaultRouterTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if 0
#define IPDEFAULTROUTERLIFETIME     1
    {IPDEFAULTROUTERLIFETIME, ASN_UNSIGNED, RONLY, var_ipDefaultRouterTable, 2, {1, 4}},
#endif
#define IPDEFAULTROUTERPREFERENCE       2
    {IPDEFAULTROUTERPREFERENCE, ASN_INTEGER, RONLY, var_ipDefaultRouterTable, 2, {1, 5}},
};

/*
 * Initializes the ipDefaultRouterTable module
 */
static void init_ipDefaultRouterTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipDefaultRouterTable_variables_oid,
                             sizeof(ipDefaultRouterTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipDefaultRouterTable");

    DEBUGMSGTL(("ipDefaultRouterTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipDefaultRouterTable", ipDefaultRouterTable_variables, variable2,
                 ipDefaultRouterTable_variables_oid);

    /* place any other initialization junk you need here */
}

static bool get_next_default_route(vtss_appl_ip_route_status_key_t *entry)
{
    static mesa_ipv4_network_t v4_zero_network;
    static mesa_ipv6_network_t v6_zero_network;

    while (vtss_appl_ip_route_status_itr(entry, entry) == VTSS_RC_OK) {
        if (!vtss_ifindex_is_vlan(entry->route.vlan_ifindex)) {
            continue;
        }

        if ((entry->route.type == VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC && entry->route.route.ipv4_uc.network == v4_zero_network) ||
            (entry->route.type == VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC && entry->route.route.ipv6_uc.network == v6_zero_network)) {
            return true;
        }
    }

    return false;
}

static BOOL get_next_ipDefaultRouterTableEntryByKey(ipDefaultRouterTable_entry_t *table_entry)
{
    iftable_info_t                  info;
    vtss_appl_ip_route_status_key_t entry;
    long                            type     = table_entry->ipDefaultRouterAddressType;
    size_t                          addr_len = table_entry->ipDefaultRouterAddress_len;
    mesa_ipv4_t                     n_v4_dst, h_v4_dst;

    info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    if (!ifIndex_get_first_by_type(&info)) {
        return FALSE;
    }

    if (!prepare_get_next_inetAddress(&type, table_entry->ipDefaultRouterAddress, SNMP_ASN_OCTET_STR_MAX_LEN, &addr_len)) {
        return FALSE;
    }

    if (type == table_entry->ipDefaultRouterAddressType && addr_len == table_entry->ipDefaultRouterAddress_len && table_entry->ipDefaultRouterIfIndex >= (i32)info.ifIndex) {
        info.ifIndex = table_entry->ipDefaultRouterIfIndex;

        if (!ifIndex_get_valid(&info) || info.type != IFTABLE_IFINDEX_TYPE_VLAN) {
            return FALSE;
        }

        entry.route.vlan_ifindex = vtss_ifindex_cast_from_u32(info.if_id, VTSS_IFINDEX_TYPE_VLAN);
    } else {
        table_entry->ipDefaultRouterAddressType = type;
        table_entry->ipDefaultRouterAddress_len = addr_len;
        entry.route.vlan_ifindex = VTSS_IFINDEX_NONE;
    }

    switch (table_entry->ipDefaultRouterAddressType) {
    case INET_ADDRESS_IPV4:
        entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;
        memcpy(&n_v4_dst, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len);
        entry.route.route.ipv4_uc.destination = ntohl(n_v4_dst);
        break;
    case INET_ADDRESS_IPV6:
        entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC;
        memcpy(&entry.route.route.ipv6_uc.destination, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len);
        break;
    default:
        T_E("internal error");
        return FALSE;
    }

    if (!get_next_default_route(&entry)) {
        return FALSE;
    }

    switch (entry.route.type) {
    case VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC:
        table_entry->ipDefaultRouterAddressType = INET_ADDRESS_IPV4;
        memcpy(&h_v4_dst, &entry.route.route.ipv4_uc.destination, table_entry->ipDefaultRouterAddress_len);
        n_v4_dst = htonl(h_v4_dst);
        memcpy(table_entry->ipDefaultRouterAddress, &n_v4_dst, table_entry->ipDefaultRouterAddress_len);
        break;

    case VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC:
        table_entry->ipDefaultRouterAddressType = INET_ADDRESS_IPV6;
        table_entry->ipDefaultRouterAddress_len = INET_ADDRESS_IPV6_LEN;
        memcpy(table_entry->ipDefaultRouterAddress, &entry.route.route.ipv6_uc.destination, table_entry->ipDefaultRouterAddress_len);
        break;
    default:
        T_E("internal error");
        return FALSE;
    }

    if (vtss_ifindex_is_vlan(entry.route.vlan_ifindex)) {
        info.if_id = vtss_ifindex_as_vlan(entry.route.vlan_ifindex);
        info.type = IFTABLE_IFINDEX_TYPE_VLAN;
        (void)ifIndex_get_by_interface(&info);
        table_entry->ipDefaultRouterIfIndex = info.ifIndex;
        table_entry->ipDefaultRouterPreference = 0; // Not supported yet.
        return TRUE;
    } else {
        T_I("WHAT??, not a vlan: %s", entry.route.vlan_ifindex);
        return FALSE;
    }
}

static BOOL get_pre_ipDefaultRouterTableEntryKey(ipDefaultRouterTable_entry_t *table_entry)
{
    mesa_rc rc;

    if (table_entry->ipDefaultRouterIfIndex) {
        table_entry->ipDefaultRouterIfIndex--;
    } else {
        table_entry->ipDefaultRouterIfIndex = 0x7fffffff;
        rc = get_pre_inetAddress(table_entry->ipDefaultRouterAddress, &table_entry->ipDefaultRouterAddress_len );
        if ( rc == VTSS_RC_INCOMPLETE) {
            return FALSE;
        }
        if (  VTSS_RC_OK != rc && table_entry->ipDefaultRouterAddressType == 0 ) {
            return FALSE;
        } else if (VTSS_RC_OK != rc) {
            memset(table_entry->ipDefaultRouterAddress, 0xff, table_entry->ipDefaultRouterAddress_len );
            table_entry->ipDefaultRouterAddressType--;
        }
    }

    return TRUE;
}

static int
getfirst_ipDefaultRouterTableEntry(ipDefaultRouterTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipDefaultRouterTable_entry_t));

    return !get_next_ipDefaultRouterTableEntryByKey(table_entry);
}

static int
get_ipDefaultRouterTableEntry(ipDefaultRouterTable_entry_t *table_entry, BOOL getnext)
{
    ipDefaultRouterTable_entry_t tmp = *table_entry;
    if ( TRUE == getnext && FALSE == get_next_ipDefaultRouterTableEntryByKey(&tmp)) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext) {
        if ( FALSE == get_pre_ipDefaultRouterTableEntryKey(&tmp) || FALSE == get_next_ipDefaultRouterTableEntryByKey(&tmp) ||
             tmp.ipDefaultRouterAddressType != table_entry->ipDefaultRouterAddressType ||
             tmp.ipDefaultRouterAddress_len != table_entry->ipDefaultRouterAddress_len ||
             memcmp(tmp.ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len) ||
             tmp.ipDefaultRouterIfIndex != table_entry->ipDefaultRouterIfIndex ) {
            return VTSS_RC_ERROR;
        }
    }

    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

typedef enum {
    IPDEFAULTROUTERADDRESSTYPE,
    IPDEFAULTROUTERADDRESS_LEN,
    IPDEFAULTROUTERADDRESS,
    IPDEFAULTROUTERIFINDEX,
} ipDefaultRouterTable_key_t;

static BOOL subtract_ipDefaultRouterTable(ipDefaultRouterTable_entry_t *table_entry, ipDefaultRouterTable_key_t start_key, size_t offsetof_key)
{
    switch (start_key) {
    case IPDEFAULTROUTERIFINDEX: {
        if (table_entry->ipDefaultRouterIfIndex) {
            table_entry->ipDefaultRouterIfIndex--;
            return TRUE;
        }
    }
    offsetof_key = sizeof(table_entry->ipDefaultRouterAddress) / sizeof(table_entry->ipDefaultRouterAddress[0]) - 1;
    case IPDEFAULTROUTERADDRESS: {
        char *offset = table_entry->ipDefaultRouterAddress + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1;
                return TRUE;
            }
            *(offset--) = 0xff;
        } while (offset >= table_entry->ipDefaultRouterAddress);
    }
    case IPDEFAULTROUTERADDRESS_LEN: {
        if (table_entry->ipDefaultRouterAddress_len) {
            table_entry->ipDefaultRouterAddress_len--;
            return TRUE;
        }
    }
    case IPDEFAULTROUTERADDRESSTYPE: {
        if (table_entry->ipDefaultRouterAddressType) {
            table_entry->ipDefaultRouterAddressType--;
            return TRUE;
        }
    }
    default:
        return FALSE;

    }
}


static int
parse_ipDefaultRouterTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           ipDefaultRouterTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipDefaultRouterTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipDefaultRouterAddressType = (long) * op++;
        if (!table_entry->ipDefaultRouterAddressType) {
            return 1;
        }
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        goto parse_end;
    }

    if (*length > op_pos) {
        len = (unsigned int) * op++;
        len = (unsigned int )len > sizeof(table_entry->ipDefaultRouterAddress) ? sizeof(table_entry->ipDefaultRouterAddress) : len;

        if (!len) {
            if (FALSE == subtract_ipDefaultRouterTable(table_entry, IPDEFAULTROUTERADDRESS_LEN, 0)) {
                return 1;
            }
            goto parse_end;
        }
        op_pos++;
        table_entry->ipDefaultRouterAddress_len = len;
        cp = (u_char *) table_entry->ipDefaultRouterAddress;
        while (len-- > 0) {
            if (*length > op_pos) {
                *cp++ = (u_char) * op++;
                op_pos++;
            } else if (exact) {
                return -1;
            } else {
                if (FALSE == subtract_ipDefaultRouterTable(table_entry, IPDEFAULTROUTERADDRESS, cp - (u_char *)table_entry->ipDefaultRouterAddress)) {
                    return 1;
                }
                goto parse_end;
            }
        }
    }

    if (*length > op_pos) {
        table_entry->ipDefaultRouterIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        goto parse_end;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

parse_end:
    return 0;
}

static int
fillobj_ipDefaultRouterTable(oid     *name,
                             size_t  *length,
                             ipDefaultRouterTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipDefaultRouterAddressType;
    len = (int) table_entry->ipDefaultRouterAddress_len;
    name[name_pos++] = (oid) table_entry->ipDefaultRouterAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->ipDefaultRouterAddress[idx++];
    }
    name[name_pos++] = (oid) table_entry->ipDefaultRouterIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipDefaultRouterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipDefaultRouterTable above.
 */
u_char *
var_ipDefaultRouterTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipDefaultRouterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipDefaultRouterTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipDefaultRouterTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipDefaultRouterTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipDefaultRouterTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if 0
    case IPDEFAULTROUTERLIFETIME: {
        ipDefaultRouterTable_global_ret.ulong_ret = table_entry.ipDefaultRouterLifetime;
        *var_len = sizeof(ipDefaultRouterTable_global_ret.ulong_ret);
        return (u_char *) &ipDefaultRouterTable_global_ret.ulong_ret;
    }
#endif
    case IPDEFAULTROUTERPREFERENCE: {
        ipDefaultRouterTable_global_ret.long_ret = table_entry.ipDefaultRouterPreference;
        *var_len = sizeof(ipDefaultRouterTable_global_ret.long_ret);
        return (u_char *) &ipDefaultRouterTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipDefaultRouterTable\n", vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for ipv4InterfaceTable
 */
typedef struct {
    /* Entry keys */
    long           ipv4InterfaceIfIndex;

    /* Entry columns */
    long             ipv4InterfaceReasmMaxSize;
    long             ipv4InterfaceEnableStatus;
    u_long             ipv4InterfaceRetransmitTime;
} ipv4InterfaceTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    u_long              ulong_ret;
} ipv4InterfaceTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv4InterfaceTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv4InterfaceTable_return_t ipv4InterfaceTable_global_ret; /* static variables for retuning */

/*
 * ipv4InterfaceTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv4InterfaceTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 28};



/*
 * variable ipv4InterfaceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv4InterfaceTable mib section
 */

struct variable2 ipv4InterfaceTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV4INTERFACEREASMMAXSIZE       1
    {IPV4INTERFACEREASMMAXSIZE, ASN_INTEGER, RONLY, var_ipv4InterfaceTable, 2, {1, 2}},
#if 0
#define IPV4INTERFACEENABLESTATUS       2
    {IPV4INTERFACEENABLESTATUS, ASN_INTEGER, RWRITE, var_ipv4InterfaceTable, 2, {1, 3}},
#endif
#define IPV4INTERFACERETRANSMITTIME     3
    {IPV4INTERFACERETRANSMITTIME, ASN_UNSIGNED, RONLY, var_ipv4InterfaceTable, 2, {1, 4}},
};

/*
 * Initializes the ipv4InterfaceTable module
 */
static void
init_ipv4InterfaceTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv4InterfaceTable_variables_oid,
                             sizeof(ipv4InterfaceTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv4InterfaceTable");

    DEBUGMSGTL(("ipv4InterfaceTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv4InterfaceTable", ipv4InterfaceTable_variables, variable2,
                 ipv4InterfaceTable_variables_oid);

    /* place any other initialization junk you need here */
}

static BOOL get_next_ipv4InterfaceTableEntryByKey(ipv4InterfaceTable_entry_t *table_entry)
{
    iftable_info_t           info;
    vtss_appl_ip_if_status_t if_status;

    info.type = IFTABLE_IFINDEX_TYPE_VLAN;

    if ( FALSE == ifIndex_get_first_by_type(&info) ) {
        return FALSE;
    }

    if ( (table_entry->ipv4InterfaceIfIndex >= ( i32 ) info.ifIndex) && (info.ifIndex = table_entry->ipv4InterfaceIfIndex) &&
         ( FALSE == ifIndex_get_next(&info) || info.type != IFTABLE_IFINDEX_TYPE_VLAN) ) {
        return FALSE;
    }

    vtss_ifindex_t ifidx = vtss_ifindex_cast_from_u32(info.if_id, VTSS_IFINDEX_TYPE_VLAN);
    if (vtss_appl_ip_if_status_get(ifidx, VTSS_APPL_IP_IF_STATUS_TYPE_IPV4, 1, nullptr, &if_status) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->ipv4InterfaceIfIndex = info.ifIndex;
    table_entry->ipv4InterfaceReasmMaxSize = if_status.u.ipv4.info.reasm_max_size;
    table_entry->ipv4InterfaceRetransmitTime = if_status.u.ipv4.info.arp_retransmit_time;

    return TRUE;
}

static int
getfirst_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipv4InterfaceTable_entry_t));
    return !get_next_ipv4InterfaceTableEntryByKey(table_entry);
}

static int
get_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry, BOOL getnext)
{
    ipv4InterfaceTable_entry_t tmp = *table_entry;
    if ( (TRUE == getnext && FALSE == get_next_ipv4InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv4InterfaceIfIndex == 0 || ((tmp.ipv4InterfaceIfIndex--) && FALSE == get_next_ipv4InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv4InterfaceIfIndex != table_entry->ipv4InterfaceIfIndex) ) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
set_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipv4InterfaceTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         ipv4InterfaceTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv4InterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv4InterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv4InterfaceTable(oid     *name,
                           size_t  *length,
                           ipv4InterfaceTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv4InterfaceIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv4InterfaceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv4InterfaceTable above.
 */
u_char *
var_ipv4InterfaceTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv4InterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv4InterfaceTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv4InterfaceTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv4InterfaceTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv4InterfaceTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV4INTERFACEREASMMAXSIZE: {
        ipv4InterfaceTable_global_ret.long_ret = table_entry.ipv4InterfaceReasmMaxSize;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.long_ret;
    }
#if 0
    case IPV4INTERFACEENABLESTATUS: {
        *write_method = write_ipv4InterfaceEnableStatus;
        ipv4InterfaceTable_global_ret.long_ret = table_entry.ipv4InterfaceEnableStatus;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.long_ret;
    }
#endif
    case IPV4INTERFACERETRANSMITTIME: {
        ipv4InterfaceTable_global_ret.ulong_ret = table_entry.ipv4InterfaceRetransmitTime;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv4InterfaceTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipv4InterfaceEnableStatus(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv4InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv4InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv4InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv4InterfaceEnableStatus = set_value;
        if (set_ipv4InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipv6InterfaceTable
 */
typedef struct {
    /* Entry keys */
    long           ipv6InterfaceIfIndex;

    /* Entry columns */
    u_long             ipv6InterfaceReasmMaxSize;
    char             ipv6InterfaceIdentifier[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipv6InterfaceIdentifier_len;
    long             ipv6InterfaceEnableStatus;
    u_long             ipv6InterfaceReachableTime;
    u_long             ipv6InterfaceRetransmitTime;
    long             ipv6InterfaceForwarding;
} ipv6InterfaceTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipv6InterfaceTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv6InterfaceTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv6InterfaceTable_return_t ipv6InterfaceTable_global_ret; /* static variables for retuning */

/*
 * ipv6InterfaceTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv6InterfaceTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 30};



/*
 * variable ipv6InterfaceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv6InterfaceTable mib section
 */

struct variable2 ipv6InterfaceTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV6INTERFACEREASMMAXSIZE       1
    {IPV6INTERFACEREASMMAXSIZE, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 2}},
#define IPV6INTERFACEIDENTIFIER     2
    {IPV6INTERFACEIDENTIFIER, ASN_OCTET_STR, RONLY, var_ipv6InterfaceTable, 2, {1, 3}},
#define IPV6INTERFACEENABLESTATUS       3
    {IPV6INTERFACEENABLESTATUS, ASN_INTEGER, RWRITE, var_ipv6InterfaceTable, 2, {1, 5}},
#define IPV6INTERFACEREACHABLETIME      4
    {IPV6INTERFACEREACHABLETIME, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 6}},
#define IPV6INTERFACERETRANSMITTIME     5
    {IPV6INTERFACERETRANSMITTIME, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 7}},
#define IPV6INTERFACEFORWARDING     6
    {IPV6INTERFACEFORWARDING, ASN_INTEGER, RWRITE, var_ipv6InterfaceTable, 2, {1, 8}},
};

/*
 * Initializes the ipv6InterfaceTable module
 */
void
init_ipv6InterfaceTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv6InterfaceTable_variables_oid,
                             sizeof(ipv6InterfaceTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv6InterfaceTable");

    DEBUGMSGTL(("ipv6InterfaceTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv6InterfaceTable", ipv6InterfaceTable_variables, variable2,
                 ipv6InterfaceTable_variables_oid);

    /* place any other initialization junk you need here */
}

static BOOL get_next_ipv6InterfaceTableEntryByKey(ipv6InterfaceTable_entry_t *table_entry)
{
    iftable_info_t           info;
    vtss_appl_ip_if_status_t if_status;
    unsigned char            *ipv6_addr = if_status.u.ipv6.net.address.addr;

    info.type = IFTABLE_IFINDEX_TYPE_VLAN;

    if ( FALSE == ifIndex_get_first_by_type(&info) ) {
        return FALSE;
    }

    if ( (table_entry->ipv6InterfaceIfIndex >= ( i32 ) info.ifIndex) && (info.ifIndex = table_entry->ipv6InterfaceIfIndex) &&
         ( FALSE == ifIndex_get_next(&info) || info.type != IFTABLE_IFINDEX_TYPE_VLAN) ) {
        return FALSE;
    }

    vtss_ifindex_t ifidx = vtss_ifindex_cast_from_u32(info.if_id, VTSS_IFINDEX_TYPE_VLAN);
    if (vtss_appl_ip_if_status_get(ifidx, VTSS_APPL_IP_IF_STATUS_TYPE_IPV6, 1, nullptr, &if_status) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->ipv6InterfaceIfIndex = info.ifIndex;
    table_entry->ipv6InterfaceIdentifier_len = 8;
    memcpy (table_entry->ipv6InterfaceIdentifier, ipv6_addr + 8, table_entry->ipv6InterfaceIdentifier_len );
    table_entry->ipv6InterfaceReasmMaxSize = 65535;
    table_entry->ipv6InterfaceRetransmitTime = 300;
    return TRUE;
}


static int
getfirst_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry)
{
    memset( table_entry, 0, sizeof(ipv6InterfaceTable_entry_t));
    return !get_next_ipv6InterfaceTableEntryByKey(table_entry);
}

static int
get_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry, BOOL getnext)
{
    ipv6InterfaceTable_entry_t tmp = *table_entry;
    if ( (TRUE == getnext && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv6InterfaceIfIndex == 0 || ((tmp.ipv6InterfaceIfIndex--) && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv6InterfaceIfIndex != table_entry->ipv6InterfaceIfIndex) ) {
        return VTSS_RC_ERROR;
    }

    *table_entry = tmp;
    return VTSS_RC_OK;
}

static int
set_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipv6InterfaceTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         ipv6InterfaceTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv6InterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv6InterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv6InterfaceTable(oid     *name,
                           size_t  *length,
                           ipv6InterfaceTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv6InterfaceIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv6InterfaceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv6InterfaceTable above.
 */
u_char *
var_ipv6InterfaceTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv6InterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv6InterfaceTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv6InterfaceTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv6InterfaceTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv6InterfaceTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV6INTERFACEREASMMAXSIZE: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceReasmMaxSize;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
    case IPV6INTERFACEIDENTIFIER: {
        *var_len = table_entry.ipv6InterfaceIdentifier_len;
        memcpy(ipv6InterfaceTable_global_ret.string_ret, table_entry.ipv6InterfaceIdentifier, *var_len);
        ipv6InterfaceTable_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ipv6InterfaceTable_global_ret.string_ret;
    }
#if 0
    case IPV6INTERFACEENABLESTATUS: {
        *write_method = write_ipv6InterfaceEnableStatus;
        ipv6InterfaceTable_global_ret.long_ret = table_entry.ipv6InterfaceEnableStatus;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.long_ret;
    }
    case IPV6INTERFACEREACHABLETIME: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceReachableTime;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
#endif
    case IPV6INTERFACERETRANSMITTIME: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceRetransmitTime;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
#if 0
    case IPV6INTERFACEFORWARDING: {
        *write_method = write_ipv6InterfaceForwarding;
        ipv6InterfaceTable_global_ret.long_ret = table_entry.ipv6InterfaceForwarding;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv6InterfaceTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipv6InterfaceEnableStatus(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv6InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv6InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv6InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv6InterfaceEnableStatus = set_value;
        if (set_ipv6InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipv6InterfaceForwarding(int      action,
                              u_char   *var_val,
                              u_char   var_val_type,
                              size_t   var_val_len,
                              u_char   *statP,
                              oid      *name,
                              size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv6InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv6InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv6InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv6InterfaceForwarding = set_value;
        if (set_ipv6InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipv6ScopeZoneIndexTable
 */
typedef struct {
    /* Entry keys */
    long           ipv6ScopeZoneIndexIfIndex;

    /* Entry columns */
    u_long             ipv6ScopeZoneIndexLinkLocal;
    u_long             ipv6ScopeZoneIndex3;
    u_long             ipv6ScopeZoneIndexAdminLocal;
    u_long             ipv6ScopeZoneIndexSiteLocal;
    u_long             ipv6ScopeZoneIndex6;
    u_long             ipv6ScopeZoneIndex7;
    u_long             ipv6ScopeZoneIndexOrganizationLocal;
    u_long             ipv6ScopeZoneIndex9;
    u_long             ipv6ScopeZoneIndexA;
    u_long             ipv6ScopeZoneIndexB;
    u_long             ipv6ScopeZoneIndexC;
    u_long             ipv6ScopeZoneIndexD;
} ipv6ScopeZoneIndexTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    u_long              ulong_ret;
} ipv6ScopeZoneIndexTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv6ScopeZoneIndexTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv6ScopeZoneIndexTable_return_t ipv6ScopeZoneIndexTable_global_ret; /* static variables for retuning */

/*
 * ipv6ScopeZoneIndexTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv6ScopeZoneIndexTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 36};



/*
 * variable ipv6ScopeZoneIndexTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv6ScopeZoneIndexTable mib section
 */

struct variable2 ipv6ScopeZoneIndexTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV6SCOPEZONEINDEXLINKLOCAL     1
    {IPV6SCOPEZONEINDEXLINKLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 2}},
#if 0
#define IPV6SCOPEZONEINDEX3     2
    {IPV6SCOPEZONEINDEX3, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 3}},
#define IPV6SCOPEZONEINDEXADMINLOCAL        3
    {IPV6SCOPEZONEINDEXADMINLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 4}},
#define IPV6SCOPEZONEINDEXSITELOCAL     4
    {IPV6SCOPEZONEINDEXSITELOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 5}},
#define IPV6SCOPEZONEINDEX6     5
    {IPV6SCOPEZONEINDEX6, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 6}},
#define IPV6SCOPEZONEINDEX7     6
    {IPV6SCOPEZONEINDEX7, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 7}},
#define IPV6SCOPEZONEINDEXORGANIZATIONLOCAL     7
    {IPV6SCOPEZONEINDEXORGANIZATIONLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 8}},
#define IPV6SCOPEZONEINDEX9     8
    {IPV6SCOPEZONEINDEX9, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 9}},
#define IPV6SCOPEZONEINDEXA     9
    {IPV6SCOPEZONEINDEXA, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 10}},
#define IPV6SCOPEZONEINDEXB     10
    {IPV6SCOPEZONEINDEXB, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 11}},
#define IPV6SCOPEZONEINDEXC     11
    {IPV6SCOPEZONEINDEXC, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 12}},
#define IPV6SCOPEZONEINDEXD     12
    {IPV6SCOPEZONEINDEXD, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 13}},
#endif
};

/*
 * Initializes the ipv6ScopeZoneIndexTable module
 */
void
init_ipv6ScopeZoneIndexTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv6ScopeZoneIndexTable_variables_oid,
                             sizeof(ipv6ScopeZoneIndexTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv6ScopeZoneIndexTable");

    DEBUGMSGTL(("ipv6ScopeZoneIndexTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv6ScopeZoneIndexTable", ipv6ScopeZoneIndexTable_variables, variable2,
                 ipv6ScopeZoneIndexTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int
getfirst_ipv6ScopeZoneIndexTableEntry(ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    ipv6InterfaceTable_entry_t tmp;
    memset(&tmp, 0, sizeof(tmp));

    if ( FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp) ) {
        return VTSS_RC_ERROR;
    }
    table_entry->ipv6ScopeZoneIndexIfIndex = tmp.ipv6InterfaceIfIndex;
    table_entry->ipv6ScopeZoneIndexLinkLocal = tmp.ipv6InterfaceIdentifier[3];
    return VTSS_RC_OK;
}

static int
get_ipv6ScopeZoneIndexTableEntry(ipv6ScopeZoneIndexTable_entry_t *table_entry, BOOL getnext)
{
    ipv6InterfaceTable_entry_t tmp;
    tmp.ipv6InterfaceIfIndex = table_entry->ipv6ScopeZoneIndexIfIndex;

    if ( TRUE != getnext && FALSE != getnext) {
        return VTSS_RC_ERROR;
    }
    if ( (TRUE == getnext && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv6InterfaceIfIndex == 0 || ((tmp.ipv6InterfaceIfIndex--) && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv6InterfaceIfIndex != table_entry->ipv6ScopeZoneIndexIfIndex) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->ipv6ScopeZoneIndexIfIndex = tmp.ipv6InterfaceIfIndex;
    table_entry->ipv6ScopeZoneIndexLinkLocal = tmp.ipv6InterfaceIdentifier[3];

    return VTSS_RC_OK;
}

static int
parse_ipv6ScopeZoneIndexTable(oid     *name,
                              size_t  *length,
                              int     exact,
                              ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv6ScopeZoneIndexTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv6ScopeZoneIndexIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv6ScopeZoneIndexTable(oid     *name,
                                size_t  *length,
                                ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv6ScopeZoneIndexIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv6ScopeZoneIndexTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv6ScopeZoneIndexTable above.
 */
u_char *
var_ipv6ScopeZoneIndexTable(struct variable *vp,
                            oid     *name,
                            size_t  *length,
                            int     exact,
                            size_t  *var_len,
                            WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv6ScopeZoneIndexTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv6ScopeZoneIndexTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv6ScopeZoneIndexTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv6ScopeZoneIndexTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv6ScopeZoneIndexTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV6SCOPEZONEINDEXLINKLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexLinkLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
#if 0
    case IPV6SCOPEZONEINDEX3: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex3;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXADMINLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexAdminLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXSITELOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexSiteLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX6: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex6;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX7: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex7;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXORGANIZATIONLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexOrganizationLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX9: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex9;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXA: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexA;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXB: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexB;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXC: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexC;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXD: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexD;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv6ScopeZoneIndexTable\n", vp->magic));
    }
    return NULL;
}

void init_ip(void)
{
    init_ipAddressTable();
    init_ipTrafficStats();
    init_icmpStatsTable();
    init_icmpMsgStatsTable();
    init_ipNetToPhysicalTable();
    init_ipDefaultRouterTable();
    init_ipv4InterfaceTable();
    init_ipv6InterfaceTable();
    init_ipv6ScopeZoneIndexTable();
}

