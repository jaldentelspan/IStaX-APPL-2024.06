/*
 Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include "ifIndex_api.h"
#include "inet_address.h"
#include "rfc4292_ip_forward.h"
#include "ip_api.h"
#include "mibContextTable.h"  //mibContextTable_register
#include "misc_api.h"

#define SNMP_ASN_OCTET_STR_MAX_LEN  256  /* FIXME : Re-define it if needed */

#undef VTSS_TRACE_MODULE_ID
#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP

#undef VTSS_ALLOC_MODULE_ID
#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP

/*
 * The entry data structure for ipForwardNumber
 */
typedef struct {
    u_long  inetCidrRouteNumber;
    u_long  inetCidrRouteDiscards;
} ipForward_scalar_t;

/*
 * The entry data structure for inetCidrRouteTable
 */
typedef struct {
    /* Entry keys */
    long    inetCidrRouteDestType;
    char    inetCidrRouteDest[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t  inetCidrRouteDest_len;
    u_long  inetCidrRoutePfxLen;
    oid     inetCidrRoutePolicy[MAX_OID_LEN];
    size_t  inetCidrRoutePolicy_len;
    long    inetCidrRouteNextHopType;
    char    inetCidrRouteNextHop[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t  inetCidrRouteNextHop_len;

    /* Entry columns */
    long             inetCidrRouteIfIndex;
    long             inetCidrRouteType;
    long             inetCidrRouteProto;
    u_long             inetCidrRouteAge;
    u_long             inetCidrRouteNextHopAS;
    long             inetCidrRouteMetric1;
    long             inetCidrRouteMetric2;
    long             inetCidrRouteMetric3;
    long             inetCidrRouteMetric4;
    long             inetCidrRouteMetric5;
    long             inetCidrRouteStatus;
} inetCidrRouteTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid                 objid_ret[MAX_OID_LEN];
    size_t              objid_len_ret;
    u_char              ip_string_ret[4];
    u_long              ulong_ret;
} ipForward_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipForward_global_ret) */
static ipForward_return_t ipForward_global_ret; /* static variables for retuning */

static char print_buf[40];
/*
 * ipForward_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipForward_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 24};



/*
 * variable ipForward_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipForward mib section
 */

struct variable4 ipForward_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define INETCIDRROUTENUMBER         1
    {INETCIDRROUTENUMBER, ASN_GAUGE, RONLY, var_ipForward, 1, {6}},
#define INETCIDRROUTEIFINDEX        2
    {INETCIDRROUTEIFINDEX, ASN_INTEGER, RONLY, var_inetCidrRouteTable, 3, {7, 1, 7}},
#define INETCIDRROUTETYPE           3
    {INETCIDRROUTETYPE, ASN_INTEGER, RONLY, var_inetCidrRouteTable, 3, {7, 1, 8}},
    /* Not support
    #define INETCIDRROUTEPROTO          4
    {INETCIDRROUTEPROTO, ASN_INTEGER, RONLY, var_inetCidrRouteTable, 3, {7, 1, 9}},
    #define INETCIDRROUTEAGE            5
    {INETCIDRROUTEAGE, ASN_GAUGE, RONLY, var_inetCidrRouteTable, 3, {7, 1, 10}},
    #define INETCIDRROUTENEXTHOPAS      6
    {INETCIDRROUTENEXTHOPAS, ASN_UNSIGNED, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 11}},
    #define INETCIDRROUTEMETRIC1        7
    {INETCIDRROUTEMETRIC1, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 12}},
    #define INETCIDRROUTEMETRIC2        8
    {INETCIDRROUTEMETRIC2, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 13}},
    #define INETCIDRROUTEMETRIC3        9
    {INETCIDRROUTEMETRIC3, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 14}},
    #define INETCIDRROUTEMETRIC4        10
    {INETCIDRROUTEMETRIC4, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 15}},
    #define INETCIDRROUTEMETRIC5        11
    {INETCIDRROUTEMETRIC5, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 16}},
    */
#define INETCIDRROUTESTATUS         12
    {INETCIDRROUTESTATUS, ASN_INTEGER, RONLY, var_inetCidrRouteTable, 3, {7, 1, 17}},
#define INETCIDRROUTEDISCARDS       13
    /* Not support
    {INETCIDRROUTEDISCARDS, ASN_COUNTER, RONLY, var_ipForward, 1, {8}},
    */
};

/*
 * Initializes the ipForward module
 */
void
init_ipForward(void)
{
    // Register mibContextTable
    mibContextTable_register(ipForward_variables_oid,
                             sizeof(ipForward_variables_oid) / sizeof(oid),
                             "IP-FORWARD-MIB : ipForward");

    DEBUGMSGTL(("ipForward", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipForward", ipForward_variables, variable4,
                 ipForward_variables_oid);

    /* place any other initialization junk you need here */
}

static u32 route_cnt_get(void)
{
    vtss_appl_ip_route_key_t tmp, *key = &tmp;
    uint32_t                 cnt = 0;

    // Start over by resetting key
    memset(key, 0, sizeof(*key));
    while (vtss_appl_ip_route_conf_itr(key, &tmp) == VTSS_RC_OK) {
        cnt++;
    }

    return cnt;
}

static int get_ipForwardScalar(ipForward_scalar_t *scalar_entry)
{
    scalar_entry->inetCidrRouteNumber = route_cnt_get();
    return 0;
}

/*
 * var_ipForward():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_ipForward(struct variable *vp,
              oid     *name,
              size_t  *length,
              int     exact,
              size_t  *var_len,
              WriteMethod **write_method)
{
    ipForward_scalar_t ipForward_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (get_ipForwardScalar(&ipForward_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case INETCIDRROUTENUMBER: {
        ipForward_global_ret.ulong_ret = ipForward_scalar_entry.inetCidrRouteNumber;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    /* Not support
    case INETCIDRROUTEDISCARDS: {
        ipForward_global_ret.ulong_ret = ipForward_scalar_entry.inetCidrRouteDiscards;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipForward\n", vp->magic));
    }
    return NULL;
}

static bool get_next_route_status_entry(vtss_appl_ip_route_status_key_t *entry, vtss_appl_ip_route_status_flags_t *flags, vtss_ifindex_t *p_ifidx, BOOL next)
{
    vtss_appl_ip_route_status_t status;
    bool                        found = false;

    if (next) {
        // Looking for the next entry.
        // In order to force the next, we set the protocol to the highest
        // possible value
        entry->protocol = VTSS_APPL_IP_ROUTE_PROTOCOL_ANY;
        while (vtss_appl_ip_route_status_itr(entry, entry) == VTSS_RC_OK) {
            // Apparently only VLAN interfaces may be returned, hence the while
            // loop.
            if (vtss_ifindex_is_vlan(entry->route.vlan_ifindex)) {
                found = true;
                break;
            }
        }

        if (!found) {
            return false;
        }
    } else {
        // If the incoming entry is not a VLAN interface, we are done.
        // Apparently, this is how this function used to work. Don't know why.
        if (!vtss_ifindex_is_vlan(entry->route.vlan_ifindex)) {
            return false;
        }
    }

    // Get the status for this entry.
    if (vtss_appl_ip_route_status_get(entry, &status) != VTSS_RC_OK) {
        // Unable to get status for this entry
        return false;
    }

    if (flags) {
        *flags = status.flags;
    }

    if (p_ifidx) {
        *p_ifidx = entry->route.vlan_ifindex;
    }

    return true;
}

static void route_2_inet_entry(vtss_appl_ip_route_status_key_t *entry, vtss_appl_ip_route_status_flags_t *flags, vtss_ifindex_t *p_ifidx, inetCidrRouteTable_entry_t *table_entry)
{
    mesa_ipv4_t n_v4_dst;

    switch (entry->route.type) {
    case VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC:
        table_entry->inetCidrRouteDestType = table_entry->inetCidrRouteNextHopType = INET_ADDRESS_IPV4;
        table_entry->inetCidrRouteDest_len = table_entry->inetCidrRouteNextHop_len = 4;
        n_v4_dst = htonl(entry->route.route.ipv4_uc.network.address);
        memcpy(table_entry->inetCidrRouteDest, &n_v4_dst, sizeof(n_v4_dst));
        table_entry->inetCidrRoutePfxLen = entry->route.route.ipv4_uc.network.prefix_size;
        n_v4_dst = htonl(entry->route.route.ipv4_uc.destination);
        memcpy(table_entry->inetCidrRouteNextHop, &n_v4_dst, sizeof(n_v4_dst));
        break;
    case VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC:
        table_entry->inetCidrRouteDestType = table_entry->inetCidrRouteNextHopType = INET_ADDRESS_IPV6;
        table_entry->inetCidrRouteDest_len = table_entry->inetCidrRouteNextHop_len = 16;
        memcpy(table_entry->inetCidrRouteDest, &entry->route.route.ipv6_uc.network.address, sizeof(entry->route.route.ipv6_uc.network.address));
        table_entry->inetCidrRoutePfxLen = entry->route.route.ipv6_uc.network.prefix_size;
        memcpy(table_entry->inetCidrRouteNextHop, &entry->route.route.ipv6_uc.destination, sizeof(entry->route.route.ipv6_uc.destination));
        break;
    default:
        break;
    }

    if (flags) {
        table_entry->inetCidrRouteType = *flags;
    }

    if (p_ifidx && vtss_ifindex_is_vlan(*p_ifidx)) {
        iftable_info_t info;
        info.type = IFTABLE_IFINDEX_TYPE_VLAN;
        info.if_id = vtss_ifindex_as_vlan(*p_ifidx);
        (void) ifIndex_get_by_interface( &info );
        table_entry->inetCidrRouteIfIndex = info.ifIndex;
    }

    table_entry->inetCidrRoutePolicy_len = 2;
    memset(table_entry->inetCidrRoutePolicy, 0, sizeof(table_entry->inetCidrRoutePolicy));
    table_entry->inetCidrRouteType = 4;
    table_entry->inetCidrRouteStatus = 1;

}

/* Map the inet entry to route entry, if the paramter is not valid, find the next valid parmater
   */
static BOOL inet_2_route_entry(inetCidrRouteTable_entry_t *table_entry, vtss_appl_ip_route_status_key_t *entry, BOOL valid)
{
    mesa_ipv4_t n_v4_dst;

    if (valid) {
        if (table_entry->inetCidrRouteNextHopType != table_entry->inetCidrRouteDestType) {
            return FALSE;
        }

        if (table_entry->inetCidrRouteNextHopType != INET_ADDRESS_IPV4 && table_entry->inetCidrRouteNextHopType != INET_ADDRESS_IPV6) {
            return FALSE;
        }

        if (table_entry->inetCidrRouteNextHop_len != table_entry->inetCidrRouteDest_len) {
            return FALSE;
        }

        if ((table_entry->inetCidrRouteNextHopType == INET_ADDRESS_IPV4 && table_entry->inetCidrRouteNextHop_len != 4) ||
            (table_entry->inetCidrRouteNextHopType == INET_ADDRESS_IPV6 && table_entry->inetCidrRouteNextHop_len != 16)  ) {
            return FALSE;
        }
    }

    switch (table_entry->inetCidrRouteNextHopType) {
    case INET_ADDRESS_IPV4:
        entry->route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;
        memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, sizeof(n_v4_dst));
        entry->route.route.ipv4_uc.network.address = ntohl(n_v4_dst);
        entry->route.route.ipv4_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
        memcpy(&n_v4_dst, table_entry->inetCidrRouteNextHop, sizeof(n_v4_dst));
        entry->route.route.ipv4_uc.destination = ntohl(n_v4_dst);
        break;
    case INET_ADDRESS_IPV6:
        entry->route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC;
        memcpy(&entry->route.route.ipv6_uc.network.address, table_entry->inetCidrRouteDest, sizeof(entry->route.route.ipv6_uc.network.address));
        entry->route.route.ipv6_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
        memcpy(&entry->route.route.ipv6_uc.destination, table_entry->inetCidrRouteNextHop, sizeof(entry->route.route.ipv6_uc.network.address));
        break;
    default:
        break;
    }

    return TRUE;

}

static BOOL get_next_oct_str (char *addr, int addr_len)
{
    char *ptr =  addr;
    int i = 0;
    BOOL overflow = TRUE;

    for (i = addr_len; i >= 0; i-- ) {
        if (*(ptr + i) != (char)0xff ) {
            (*(ptr + i))++;
            overflow = FALSE;
            break;
        } else {
            *(ptr + i) = 0x0;
        }
    }

    return !overflow;
}

/* 1. get next dest
   2. update the provious key
   3. the following keys are all zero */
static BOOL get_next_inet_entry_dest(inetCidrRouteTable_entry_t *table_entry, vtss_appl_ip_route_status_key_t *entry)
{
    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }
    switch (table_entry->inetCidrRouteDestType) {
    case INET_ADDRESS_IPV4:
        if (table_entry->inetCidrRouteDest_len < 4) {
            table_entry->inetCidrRouteDest_len = 4;
            table_entry->inetCidrRouteNextHop_len = 4;
        } else if (table_entry->inetCidrRouteDest_len > 4) {
            table_entry->inetCidrRouteDestType = INET_ADDRESS_IPV6;
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else {
            if ( FALSE == get_next_oct_str(table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len)) {
                memset(table_entry, 0, sizeof(*table_entry));
                table_entry->inetCidrRouteDestType++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, sizeof(table_entry->inetCidrRouteDest));
        break;
    case INET_ADDRESS_IPV6:
        if (table_entry->inetCidrRouteDest_len < 16) {
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else if (table_entry->inetCidrRouteDest_len > 16) {
            return FALSE;
        } else {
            if ( FALSE == get_next_oct_str(table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len)) {
                return FALSE;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, sizeof(table_entry->inetCidrRouteDest));
        break;
    default:
        break;
    }
    table_entry->inetCidrRoutePfxLen = 0;
    table_entry->inetCidrRouteNextHopType = 0;
    memset(table_entry->inetCidrRouteNextHop, 0, sizeof(table_entry->inetCidrRouteNextHop));
    (void) inet_2_route_entry(table_entry, entry, FALSE);
    return TRUE;
}

/* 1. get next PfxLen
   2. update the provious key
   3. the following keys are all zero */
static BOOL get_next_inet_entry_PfxLen(inetCidrRouteTable_entry_t *table_entry, vtss_appl_ip_route_status_key_t *entry)
{
    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }

    switch (table_entry->inetCidrRouteDestType) {
    case INET_ADDRESS_IPV4:
        if (table_entry->inetCidrRouteDest_len < 4) {
            table_entry->inetCidrRouteDest_len = 4;
            table_entry->inetCidrRouteNextHop_len = 4;
        } else if (table_entry->inetCidrRouteDest_len > 4) {
            table_entry->inetCidrRouteDestType = INET_ADDRESS_IPV6;
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else {
            if (table_entry->inetCidrRoutePfxLen >= 32 ) {
                (void)get_next_inet_entry_dest(table_entry, NULL);
            } else {
                table_entry->inetCidrRoutePfxLen++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, sizeof(table_entry->inetCidrRouteDest));
        break;
    case INET_ADDRESS_IPV6:
        if (table_entry->inetCidrRouteDest_len < 16) {
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else if (table_entry->inetCidrRouteDest_len > 16) {
            return FALSE;
        } else {
            if (table_entry->inetCidrRoutePfxLen >= 128 ) {
                if ( FALSE == get_next_inet_entry_dest(table_entry, NULL) ) {
                    return FALSE;
                }
            } else {
                table_entry->inetCidrRoutePfxLen++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, sizeof(table_entry->inetCidrRouteDest));
        break;
    default:
        break;
    }

    table_entry->inetCidrRouteNextHopType = 0;
    memset(table_entry->inetCidrRouteNextHop, 0, sizeof(table_entry->inetCidrRouteNextHop));
    (void)inet_2_route_entry(table_entry, entry, FALSE);
    return TRUE;
}

static BOOL get_next_inet_entry(inetCidrRouteTable_entry_t *table_entry)
{
    vtss_appl_ip_route_status_key_t   entry;
    mesa_ipv4_t                       n_v4_dst;
    long                              type;
    size_t                            len;
    u_long                            pfxLen;
    vtss_appl_ip_route_status_flags_t flags;
    vtss_ifindex_t                    ifidx;

    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }

    if (table_entry->inetCidrRouteDestType < INET_ADDRESS_IPV4) {
        memset(&entry, 0, sizeof(entry));
    } else {
        if (table_entry->inetCidrRouteDestType == INET_ADDRESS_IPV4) {
            type    = INET_ADDRESS_IPV4;
            len     = 4;
            pfxLen   = 32;
        } else {
            type    = INET_ADDRESS_IPV6;
            len     = 16;
            pfxLen   = 128;
        }

        memset(&entry, 0, sizeof(entry));
        if (table_entry->inetCidrRouteDest_len > len) {
            table_entry->inetCidrRouteDestType++;
            if (table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6) {
                return FALSE;
            }

            entry.route.type = type == INET_ADDRESS_IPV6 ? VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC : VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;

        } else if (table_entry->inetCidrRouteDest_len < len)  {
            entry.route.type = type == INET_ADDRESS_IPV6 ? VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC : VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;
        } else {
            if (table_entry->inetCidrRoutePfxLen > pfxLen) {
                if ( FALSE == get_next_inet_entry_dest(table_entry, &entry)) {
                    return FALSE;
                }
            } else {
                if (table_entry->inetCidrRouteNextHopType > type) {
                    if ( FALSE == get_next_inet_entry_PfxLen(table_entry, &entry)) {
                        return FALSE;
                    }
                } else if (table_entry->inetCidrRouteNextHopType < type) {
                    if (type == INET_ADDRESS_IPV4) {
                        entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;
                        memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, sizeof(n_v4_dst));
                        entry.route.route.ipv4_uc.network.address     = ntohl(n_v4_dst);
                        entry.route.route.ipv4_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
                    } else {
                        entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC;
                        memcpy(&entry.route.route.ipv6_uc.network.address, table_entry->inetCidrRouteDest, sizeof(entry.route.route.ipv6_uc.network.address));
                        entry.route.route.ipv6_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
                    }

                    /*
                        When snmp client request the OID that didn't include next hop info, the length will be (for IPv4 example)
                        1. 1.3.6.1.2.1.4.24.7.1.7.1.4.192.168.215.0.24.2.0.0.1 --> len = 0xffffffff
                        2. 1.3.6.1.2.1.4.24.7.1.7.1.4.192.168.215.0.24.2.0.0   --> len = 0
                    */
                    if (table_entry->inetCidrRouteNextHop_len == 0xffffffff || table_entry->inetCidrRouteNextHop_len == 0) {
                        memset(table_entry->inetCidrRouteNextHop, 0, sizeof(table_entry->inetCidrRouteNextHop));
                        if (get_next_route_status_entry(&entry, &flags, &ifidx, FALSE)) {
                            route_2_inet_entry(&entry, &flags, &ifidx, table_entry);
                            return TRUE;
                        }
                    }
                } else {
                    if (table_entry->inetCidrRouteNextHop_len > len) {
                        if ( FALSE == get_next_inet_entry_PfxLen(table_entry, &entry)) {
                            return FALSE;
                        }
                    } else if (table_entry->inetCidrRouteNextHop_len < len) {
                        if (type == INET_ADDRESS_IPV4) {
                            entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV4_UC;
                            memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, sizeof(n_v4_dst));
                            entry.route.route.ipv4_uc.network.address = ntohl(n_v4_dst);
                            entry.route.route.ipv4_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
                            T_D("dest is %s", misc_ipv4_txt(n_v4_dst, print_buf));
                        } else {
                            entry.route.type = VTSS_APPL_IP_ROUTE_TYPE_IPV6_UC;
                            memcpy(&entry.route.route.ipv6_uc.network.address, table_entry->inetCidrRouteDest, sizeof(entry.route.route.ipv6_uc.network.address));
                            entry.route.route.ipv6_uc.network.prefix_size = table_entry->inetCidrRoutePfxLen;
                        }
                        /*
                            When snmp client request the OID that didn't include next hop info, the length will be (for IPv4 example)
                            1. 1.3.6.1.2.1.4.24.7.1.7.1.4.192.168.215.0.24.2.0.0.1.4.0.0.0 --> len = 3, NextHop = 255.255.255.null
                        */
                        if ((table_entry->inetCidrRouteNextHop_len == 3 || table_entry->inetCidrRouteNextHop_len == 15) && (table_entry->inetCidrRouteNextHop[0] == 0xFF)) {
                            memset(table_entry->inetCidrRouteNextHop, 0, sizeof(table_entry->inetCidrRouteNextHop));
                            if (get_next_route_status_entry(&entry, &flags, &ifidx, FALSE)) {
                                route_2_inet_entry(&entry, &flags, &ifidx, table_entry);
                                return TRUE;
                            }
                        }
                    } else {
                        (void)inet_2_route_entry(table_entry, &entry, FALSE);
                    }
                }
            }
        }
    }

    if (!get_next_route_status_entry(&entry, &flags, &ifidx, TRUE)) {
        return FALSE;
    }

    route_2_inet_entry(&entry, &flags, &ifidx, table_entry);
    return TRUE;
}

static int getfirst_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(*table_entry));
    return !get_next_inet_entry(table_entry);
}

static int get_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry, BOOL getnext)
{
    vtss_appl_ip_route_status_key_t   entry;
    vtss_appl_ip_route_status_flags_t flags;
    vtss_ifindex_t                    ifidx;

    T_D("%s from:", getnext ? "GET-NEXT" : "GET");
    T_D("key-1: %ld", (long int)table_entry->inetCidrRouteDestType);
    T_D("key-2: (%d%s)", (int)table_entry->inetCidrRouteDest_len, misc_raw2txt((u8 *)table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len, FALSE));
    T_D("key-3: %lu", table_entry->inetCidrRoutePfxLen);
    T_D("key-4 is (%d%s)", (int)table_entry->inetCidrRoutePolicy_len, misc_raw2txt((u8 *)table_entry->inetCidrRoutePolicy, table_entry->inetCidrRoutePolicy_len, FALSE));
    T_D("key-5: %ld", (long int)table_entry->inetCidrRouteNextHopType);
    T_D("key-6: (%d%s)", (int)table_entry->inetCidrRouteNextHop_len, misc_raw2txt((u8 *)table_entry->inetCidrRouteNextHop, table_entry->inetCidrRouteNextHop_len, FALSE));

    if (!getnext) {
        if (!inet_2_route_entry(table_entry, &entry, TRUE)) {
            return 1;
        }

        if (!get_next_route_status_entry(&entry, &flags, &ifidx, FALSE)) {
            return 1;
        }

        route_2_inet_entry(&entry, &flags, &ifidx, table_entry);
    } else if ( FALSE == get_next_inet_entry(table_entry)) {
        return 1;
    }

    return 0;
}

static int
set_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

typedef enum {
    INETCIDRROUTEDESTTYPE,
    INETCIDRROUTEDEST_LEN,
    INETCIDRROUTEDEST,
    INETCIDRROUTEPFXLEN,
    INETCIDRROUTEPOLICY_LEN,
    INETCIDRROUTEPOLICY,
    INETCIDRROUTENEXTHOPTYPE,
    INETCIDRROUTENEXTHOP_LEN,
    INETCIDRROUTENEXTHOP
} inetCidrRouteTable_key_t;

static BOOL subtract_inetCidrRouteTable_key(inetCidrRouteTable_entry_t *table_entry, inetCidrRouteTable_key_t start_key, size_t offsetof_key)
{
    switch (start_key) {
    case INETCIDRROUTENEXTHOP: {
        T_D("start_key is INETCIDRROUTENEXTHOP, offsetof_key is %d", (int)offsetof_key);
        char *offset = table_entry->inetCidrRouteNextHop + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1;
                return TRUE;
            }
            *(offset--) = 0xff;
        } while (offset >= table_entry->inetCidrRouteNextHop);
    }
    case INETCIDRROUTENEXTHOP_LEN: {
        T_D("start_key is INETCIDRROUTENEXTHOP_LEN %d", (int)table_entry->inetCidrRouteNextHop_len);
        if (table_entry->inetCidrRouteNextHop_len) {
            table_entry->inetCidrRouteNextHop_len--;
            return TRUE;
        }
        table_entry->inetCidrRouteNextHop_len = 0xffffffff;
    }
    case INETCIDRROUTENEXTHOPTYPE: {
        T_D("start_key is INETCIDRROUTENEXTHOPTYPE");
        if (table_entry->inetCidrRouteNextHopType) {
            table_entry->inetCidrRouteNextHopType--;
            return TRUE;
        }
    }
    offsetof_key = sizeof(table_entry->inetCidrRoutePolicy) / sizeof(table_entry->inetCidrRoutePolicy[0]) - 1;
    case INETCIDRROUTEPOLICY: {
        T_D("start_key is INETCIDRROUTEPOLICY, offsetof_key is %d", (int)offsetof_key);
        oid *offset = table_entry->inetCidrRoutePolicy + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1 ;
                return TRUE;
            }
            *(offset--) = 0xffffffff;
        } while (offset >= table_entry->inetCidrRoutePolicy);
    }
    case INETCIDRROUTEPOLICY_LEN:
        T_D("start_key is INETCIDRROUTEPOLICY_LEN");
        if (table_entry->inetCidrRoutePolicy_len) {
            table_entry->inetCidrRoutePolicy_len--;
            return TRUE;
        }
        table_entry->inetCidrRoutePolicy_len = 0xffffffff;
    case INETCIDRROUTEPFXLEN: {
        T_D("start_key is INETCIDRROUTEPFXLEN");
        if (table_entry->inetCidrRoutePfxLen) {
            table_entry->inetCidrRoutePfxLen--;
            return TRUE;
        }
        table_entry->inetCidrRoutePfxLen = 0xffffffff;
        offsetof_key = sizeof(table_entry->inetCidrRouteDest) / sizeof(table_entry->inetCidrRouteDest[0]) - 1;
    }
    case INETCIDRROUTEDEST: {
        T_D("start_key is INETCIDRROUTEDEST, offsetof_key is %d", (int)offsetof_key);
        char *offset = table_entry->inetCidrRouteDest + offsetof_key;
        do {
            if (*(offset)) {
                *(offset) -= 1;
                return TRUE;
            }
            *(offset--) = 0xff;
        } while (offset >= table_entry->inetCidrRouteDest);
    }
    case INETCIDRROUTEDEST_LEN: {
        T_D("start_key is INETCIDRROUTEDEST_LEN");
        if (table_entry->inetCidrRouteDest_len) {
            table_entry->inetCidrRouteDest_len--;
            return TRUE;
        }
        table_entry->inetCidrRouteDest_len = 0xffffffff;
    }
    case INETCIDRROUTEDESTTYPE:
        T_D("start_key is INETCIDRROUTEDESTTYPE");
        if (table_entry->inetCidrRouteDestType--) {
            return TRUE;
        }
    default:
        return FALSE;

    }
}

static int
parse_inetCidrRouteTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         inetCidrRouteTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    T_D("parsing %s", misc_oid2txt(name, *length));

    if (exact && *length < (9 + 1 + 9)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_inetCidrRouteTableEntry(table_entry)) {
            T_D("no entries");
            return -1;
        }
        T_D("got first entries");
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->inetCidrRouteDestType = (long) * op++;
        op_pos++;
        T_D("key-1 is %ld", (long int)table_entry->inetCidrRouteDestType);
    } else if (exact) {
        return -1;
    } else {
        T_D("stop parsing because of no keys");
        goto parse_end;
    }
    len = (unsigned int) * op++;
    if ((unsigned int )len > sizeof(table_entry->inetCidrRouteDest)) {
        T_D("go next from key-1");
        subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTEDEST_LEN, 0);
        goto parse_end;
    }
    op_pos++;
    table_entry->inetCidrRouteDest_len = len;
    cp = (u_char *) table_entry->inetCidrRouteDest;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            T_D("stop parsing because of incompleted key-2");
            subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTEDEST, cp - (u_char *)table_entry->inetCidrRouteDest);
            goto parse_end;
        }
    }

    if (*length > op_pos) {
        table_entry->inetCidrRoutePfxLen = (u_long) * op++;
        op_pos++;
        T_D("key-3 is %lu", table_entry->inetCidrRoutePfxLen);
    } else if (exact) {
        return -1;
    } else {
        T_D("stop parsing  because of no key-3");
        goto parse_end;
    }
    len = (unsigned int) * op++;
    if ((unsigned int )len > sizeof(table_entry->inetCidrRoutePolicy)) {
        T_D("go next from key-3");
        T_D("stop parsing because of invalid key-4");
        subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTEPOLICY_LEN, 0);
        goto parse_end;
    }

    op_pos++;
    table_entry->inetCidrRoutePolicy_len = len;
    cp = (u_char *) table_entry->inetCidrRoutePolicy;
    while (len-- > 0) {
        if (*length > op_pos) {
            *(oid *)cp = *op++;
            cp += sizeof(table_entry->inetCidrRoutePolicy[0]);
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            T_D("stop parsing because of incompleted key-4");
            subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTEPOLICY, (cp - (u_char *) table_entry->inetCidrRoutePolicy) / sizeof(oid));
            goto parse_end;
        }
    }

    if (*length > op_pos) {
        table_entry->inetCidrRouteNextHopType = (long) * op++;
        op_pos++;
        T_D("key-5 is %ld", (long int)table_entry->inetCidrRouteNextHopType);
    } else if (exact) {
        return -1;
    } else {
        T_D("stop parsing because of no key-5");
        subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTENEXTHOPTYPE, 0);
        goto parse_end;
    }

    if (*length > op_pos) {
        len = (unsigned int) * op++;
        len = (unsigned int )len > sizeof(table_entry->inetCidrRouteNextHop) ? sizeof(table_entry->inetCidrRouteNextHop) : len;
        if (((unsigned int )len > sizeof(table_entry->inetCidrRouteNextHop))
            /* case 1.1.3.6.1.2.1.4.24.7.1.7.1.4.192.168.215.0.24.2.0.0.1.0 */
            || ((unsigned int )len == 0)) {
            T_D("pick next value from key-5");
            subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTENEXTHOP_LEN, 0);
            goto parse_end;
        }

        op_pos++;
        table_entry->inetCidrRouteNextHop_len = len;
        cp = (u_char *) table_entry->inetCidrRouteNextHop;
        while (len-- > 0) {
            if (*length > op_pos) {
                *cp++ = (u_char) * op++;
                op_pos++;
            } else if (exact) {
                return -1;
            } else {
                T_D("stop parsing because of incompleted key-6");
                subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTENEXTHOP, cp - (u_char *)table_entry->inetCidrRouteNextHop);
                goto parse_end;
            }
        }
    } else if (exact) {
        return -1;
    } else {
        T_D("stop parsing because of no key-6");
        subtract_inetCidrRouteTable_key(table_entry, INETCIDRROUTENEXTHOP_LEN, 0);
        goto parse_end;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

parse_end:
    T_D("parsing output:");
    T_D("key-1: %ld", (long int)table_entry->inetCidrRouteDestType);
    T_D("key-2: (%d/%s)", (int)table_entry->inetCidrRouteDest_len, misc_raw2txt((u8 *)table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len, FALSE));
    T_D("key-3: %lu", table_entry->inetCidrRoutePfxLen);
    T_D("key-4 is (%d%s)", (int)table_entry->inetCidrRoutePolicy_len, misc_raw2txt((u8 *)table_entry->inetCidrRoutePolicy, table_entry->inetCidrRoutePolicy_len, FALSE));
    T_D("key-5: %ld", (long int)table_entry->inetCidrRouteNextHopType);
    T_D("key-6: (%d/%s)", (int)table_entry->inetCidrRouteNextHop_len, misc_raw2txt((u8 *)table_entry->inetCidrRouteNextHop, table_entry->inetCidrRouteNextHop_len, FALSE));
    return 0;
}

static int
fillobj_inetCidrRouteTable(oid     *name,
                           size_t  *length,
                           inetCidrRouteTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->inetCidrRouteDestType;
    len = (int) table_entry->inetCidrRouteDest_len;
    name[name_pos++] = (oid) table_entry->inetCidrRouteDest_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->inetCidrRouteDest[idx++];
    }
    name[name_pos++] = (oid) table_entry->inetCidrRoutePfxLen;

    /* We didn't implement route policy, so fill fix value */
    len = 2;
    name[name_pos++] = len;
    while (len-- > 0) {
        name[name_pos++] = 0;
    }
    name[name_pos++] = (oid) table_entry->inetCidrRouteNextHopType;
    len = (int) table_entry->inetCidrRouteNextHop_len;
    name[name_pos++] = (oid) table_entry->inetCidrRouteNextHop_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->inetCidrRouteNextHop[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_inetCidrRouteTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipForward above.
 */
u_char *
var_inetCidrRouteTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    inetCidrRouteTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_inetCidrRouteTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_inetCidrRouteTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_inetCidrRouteTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == INETCIDRROUTESTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_inetCidrRouteStatus;
                }
                return NULL;
            }
            if (fillobj_inetCidrRouteTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case INETCIDRROUTEIFINDEX: {
        *write_method = write_inetCidrRouteIfIndex;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteIfIndex;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTETYPE: {
        *write_method = write_inetCidrRouteType;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteType;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }

    /* Not support
    case INETCIDRROUTEPROTO: {
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteProto;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEAGE: {
        ipForward_global_ret.ulong_ret = table_entry.inetCidrRouteAge;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    case INETCIDRROUTENEXTHOPAS: {
        *write_method = write_inetCidrRouteNextHopAS;
        ipForward_global_ret.ulong_ret = table_entry.inetCidrRouteNextHopAS;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    case INETCIDRROUTEMETRIC1: {
        *write_method = write_inetCidrRouteMetric1;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric1;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC2: {
        *write_method = write_inetCidrRouteMetric2;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric2;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC3: {
        *write_method = write_inetCidrRouteMetric3;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric3;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC4: {
        *write_method = write_inetCidrRouteMetric4;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric4;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC5: {
        *write_method = write_inetCidrRouteMetric5;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric5;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    */
    case INETCIDRROUTESTATUS: {
        *write_method = write_inetCidrRouteStatus;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteStatus;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_inetCidrRouteTable\n", vp->magic));
    }
    return NULL;
}

int
write_inetCidrRouteIfIndex(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteIfIndex: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteIfIndex: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteIfIndex = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteType(int      action,
                        u_char   *var_val,
                        u_char   var_val_type,
                        size_t   var_val_len,
                        u_char   *statP,
                        oid      *name,
                        size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteType = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0  /* Not support */
int
write_inetCidrRouteNextHopAS(int      action,
                             u_char   *var_val,
                             u_char   var_val_type,
                             size_t   var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t   name_len)
{
    u_long         set_value = var_val ? *((u_long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteNextHopAS: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) { /* FIXME */
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteNextHopAS: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        /*
         * FIXME : check the valid range
         * if (set_value < min_value || set_value > max_value) {
         *  (void) snmp_log(LOG_ERR, "write to inetCidrRouteTable: bad value\n");
         *   return SNMP_ERR_WRONGVALUE;
         * }
         */
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteNextHopAS = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric1(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric1: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric1: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric1 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric2(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric2: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric2: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric2 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric3(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric3: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric3: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric3 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric4(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric4: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric4: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric4 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric5(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric5: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric5: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric5 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not support */

int
write_inetCidrRouteStatus(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteStatus = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

