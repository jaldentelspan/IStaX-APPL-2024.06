/*

 Copyright (c) 2006-2022 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */


/* We *have* serialized access */
/*lint -esym(459, var_lldpXMedLocLocationTable,var_lldpXMedLocMediaPolicyTable,write_lldpXMedFastStartRepeatCount) */
/*lint -esym(459, var_lldpXMedLocXPoEPSEPortTable,var_lldpXMedPortConfigTable,write_lldpXMedPortConfigNotifEnable) */
/*lint -esym(459, var_lldpXMedMIB) */
/*lint -esym(459, var_lldpXMedRemInventoryTable) */
/*lint -esym(459, var_lldpXMedRemMediaPolicyTable) */
/*lint -esym(459, var_lldpXMedRemCapabilitiesTable) */
/*lint -esym(459, var_lldpXMedRemLocationTable) */
/*lint -esym(459, var_lldpXMedRemXPoEPDTable) */
/*lint -esym(459, write_lldpXMedPortConfigTLVsTxEnable) */
/*lint -esym(459, var_lldpXMedRemXPoEPSETable)*/
/*lint -esym(459, var_lldpXMedRemXPoETable)*/
/*lint -esym(457, snmp_send_vars_trap) */
/*lint -esym(459, write_lldpXMedLocLocationInfo) */
#include <main.h>

#include "vtss_os_wrapper_snmp.h"
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include "lldpXMedMIB.h"
#include "msg_api.h"
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register
#include "lldp_api.h"
#include "lldp_remote.h"
#include "lldp_os.h"
#include "lldp_trace.h"
#include "dot1ab_lldp.h"
#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "rfc1213_mib2.h"
#include "misc_api.h" // misc_oid2txt()
#ifdef VTSS_SW_OPTION_POE
#include "poe_api.h"
#endif
#ifdef VTSS_SW_OPTION_EEE
#include "eee_api.h"
#endif /* VTSS_SW_OPTION_EEE */
#ifdef VTSS_SW_OPTION_LLDP_MED
#include "dot1ab_lldp_api.h"
#include "lldpmed_shared.h"
#include "lldpmed_tx.h"
#include "lldpmed_rx.h"
#endif

/*
* +++ Start (Internal implementation declarations)
*/
/*
* --- End (Internal implementation declarations)
*/

/*
* lldpXMedMIB_variables_oid:
*   this is the top level oid that we want to register under.  This
*   is essentially a prefix, with the suffix appearing in the
*   variable below.
*/

oid             lldpXMedMIB_variables_oid[] =    { 1, 0, 8802, 1, 1, 2, 1, 5, 4795, 1 };

/*
* variable4 lldpXMedMIB_variables:
*   this variable defines function callbacks and type return information
*   for the lldpXMedMIB mib section
*/

struct variable4 lldpXMedMIB_variables[] = {
    /*
    * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
    */
#define LLDPXMEDLOCDEVICECLASS              1
    {LLDPXMEDLOCDEVICECLASS, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {1, 1}},
#define LLDPXMEDPORTCAPSUPPORTED            2
    {LLDPXMEDPORTCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 1}},
#define LLDPXMEDPORTCONFIGTLVSTXENABLE      3
    {LLDPXMEDPORTCONFIGTLVSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 2}},
#define LLDPXMEDPORTCONFIGNOTIFENABLE       4
    {LLDPXMEDPORTCONFIGNOTIFENABLE, ASN_INTEGER, RWRITE, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 3}},
#define LLDPXMEDFASTSTARTREPEATCOUNT        5
    {LLDPXMEDFASTSTARTREPEATCOUNT, ASN_UNSIGNED, RWRITE, var_lldpXMedMIB, 2, {1, 3}},
#define LLDPXMEDLOCMEDIAPOLICYAPPTYPE       6
    {LLDPXMEDLOCMEDIAPOLICYAPPTYPE, ASN_OCTET_STR, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 1}},
#define LLDPXMEDLOCMEDIAPOLICYVLANID        7
    {LLDPXMEDLOCMEDIAPOLICYVLANID, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 2}},
#define LLDPXMEDLOCMEDIAPOLICYPRIORITY      8
    {LLDPXMEDLOCMEDIAPOLICYPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 3}},
#define LLDPXMEDLOCMEDIAPOLICYDSCP          9
    {LLDPXMEDLOCMEDIAPOLICYDSCP, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 4}},
#if 0
#define LLDPXMEDLOCMEDIAPOLICYUNKNOWN       10
    {LLDPXMEDLOCMEDIAPOLICYUNKNOWN, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, { 2, 1, 1, 5}},
#endif
#define LLDPXMEDLOCMEDIAPOLICYTAGGED        11
    {LLDPXMEDLOCMEDIAPOLICYTAGGED, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 6}},
#define LLDPXMEDLOCHARDWAREREV              12
    {LLDPXMEDLOCHARDWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 2}},
#define LLDPXMEDLOCFIRMWAREREV              13
    {LLDPXMEDLOCFIRMWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 3}},
#define LLDPXMEDLOCSOFTWAREREV              14
    {LLDPXMEDLOCSOFTWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 4}},
#define LLDPXMEDLOCSERIALNUM                15
    {LLDPXMEDLOCSERIALNUM, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 5}},
#define LLDPXMEDLOCMFGNAME                  16
    {LLDPXMEDLOCMFGNAME, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 6}},
#define LLDPXMEDLOCMODELNAME                17
    {LLDPXMEDLOCMODELNAME, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 7}},
#define LLDPXMEDLOCASSETID                  18
    {LLDPXMEDLOCASSETID, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 8}},
#define LLDPXMEDLOCLOCATIONSUBTYPE          19
    {LLDPXMEDLOCLOCATIONSUBTYPE, ASN_INTEGER, RONLY, var_lldpXMedLocLocationTable, 4, {2, 9, 1, 1}},
#define LLDPXMEDLOCLOCATIONINFO             20
    {LLDPXMEDLOCLOCATIONINFO, ASN_OCTET_STR, RWRITE, var_lldpXMedLocLocationTable, 4, {2, 9, 1, 2}},
#define LLDPXMEDLOCXPOEDEVICETYPE           21
    {LLDPXMEDLOCXPOEDEVICETYPE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 10}},
#define LLDPXMEDLOCXPOEPSEPORTPOWERAV       22
    {LLDPXMEDLOCXPOEPSEPORTPOWERAV, ASN_GAUGE, RONLY, var_lldpXMedLocXPoEPSEPortTable, 4, {2, 11, 1, 1}},
#define LLDPXMEDLOCXPOEPSEPORTPDPRIORITY    23
    {LLDPXMEDLOCXPOEPSEPORTPDPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedLocXPoEPSEPortTable, 4, {2, 11, 1, 2}},
#define LLDPXMEDLOCXPOEPSEPOWERSOURCE       24
    {LLDPXMEDLOCXPOEPSEPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 12}},
#define LLDPXMEDLOCXPOEPDPOWERREQ           25
    {LLDPXMEDLOCXPOEPDPOWERREQ, ASN_GAUGE, RONLY, var_lldpXMedMIB, 2, {2, 13}},
#define LLDPXMEDLOCXPOEPDPOWERSOURCE        26
    {LLDPXMEDLOCXPOEPDPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 14}},
#define LLDPXMEDLOCXPOEPDPOWERPRIORITY      27
    {LLDPXMEDLOCXPOEPDPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 15}},
#define LLDPXMEDREMCAPSUPPORTED             28
    {LLDPXMEDREMCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 1}},
#define LLDPXMEDREMCAPCURRENT               29
    {LLDPXMEDREMCAPCURRENT, ASN_OCTET_STR, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 2}},
#define LLDPXMEDREMDEVICECLASS              30
    {LLDPXMEDREMDEVICECLASS, ASN_INTEGER, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 3}},
#define LLDPXMEDREMMEDIAPOLICYAPPTYPE       31
    {LLDPXMEDREMMEDIAPOLICYAPPTYPE, ASN_OCTET_STR, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 1}},
#define LLDPXMEDREMMEDIAPOLICYVLANID        32
    {LLDPXMEDREMMEDIAPOLICYVLANID, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 2}},
#define LLDPXMEDREMMEDIAPOLICYPRIORITY      33
    {LLDPXMEDREMMEDIAPOLICYPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 3}},
#define LLDPXMEDREMMEDIAPOLICYDSCP          34
    {LLDPXMEDREMMEDIAPOLICYDSCP, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 4}},
#define LLDPXMEDREMMEDIAPOLICYUNKNOWN       35
    {LLDPXMEDREMMEDIAPOLICYUNKNOWN, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 5}},
#define LLDPXMEDREMMEDIAPOLICYTAGGED        36
    {LLDPXMEDREMMEDIAPOLICYTAGGED, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 6}},
#define LLDPXMEDREMHARDWAREREV              37
    {LLDPXMEDREMHARDWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 1}},
#define LLDPXMEDREMFIRMWAREREV              38
    {LLDPXMEDREMFIRMWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 2}},
#define LLDPXMEDREMSOFTWAREREV              39
    {LLDPXMEDREMSOFTWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 3}},
#define LLDPXMEDREMSERIALNUM                40
    {LLDPXMEDREMSERIALNUM, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 4}},
#define LLDPXMEDREMMFGNAME                  41
    {LLDPXMEDREMMFGNAME, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 5}},
#define LLDPXMEDREMMODELNAME                42
    {LLDPXMEDREMMODELNAME, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 6}},
#define LLDPXMEDREMASSETID                  43
    {LLDPXMEDREMASSETID, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 7}},
#define LLDPXMEDREMLOCATIONSUBTYPE          44
    {LLDPXMEDREMLOCATIONSUBTYPE, ASN_INTEGER, RONLY, var_lldpXMedRemLocationTable, 4, {3, 4, 1, 1}},
#define LLDPXMEDREMLOCATIONINFO             45
    {LLDPXMEDREMLOCATIONINFO, ASN_OCTET_STR, RONLY, var_lldpXMedRemLocationTable, 4, {3, 4, 1, 2}},
#define LLDPXMEDREMXPOEDEVICETYPE           46
    {LLDPXMEDREMXPOEDEVICETYPE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoETable, 4, {3, 5, 1, 1}},
#define LLDPXMEDREMXPOEPSEPOWERAV           47
    {LLDPXMEDREMXPOEPSEPOWERAV, ASN_GAUGE, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 1}},
#define LLDPXMEDREMXPOEPSEPOWERSOURCE       48
    {LLDPXMEDREMXPOEPSEPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 2}},
#define LLDPXMEDREMXPOEPSEPOWERPRIORITY     49
    {LLDPXMEDREMXPOEPSEPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 3}},
#define LLDPXMEDREMXPOEPDPOWERREQ           50
    {LLDPXMEDREMXPOEPDPOWERREQ, ASN_GAUGE, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 1}},
#define LLDPXMEDREMXPOEPDPOWERSOURCE        51
    {LLDPXMEDREMXPOEPDPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 2}},
#define LLDPXMEDREMXPOEPDPOWERPRIORITY      52
    {LLDPXMEDREMXPOEPDPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 3}},
};

#ifdef VTSS_SW_OPTION_LLDP_MED
static u_long bool2truthvalue(BOOL value)
{
    long truthvalue;
    if (value) {
        truthvalue = 1;    /* Enabled */
    } else {
        truthvalue = 2;    /* Disabled */
    }

    return truthvalue;
}
#endif

/*
* (L = length of the oidsuffix)
*/

static iftable_info_t  table_info;

#define PORT_INDEX  table_info.if_id

/*
* Initializes the lldpXMedMIB module
*/
void
init_lldpXMedMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(lldpXMedMIB_variables_oid,
                             sizeof(lldpXMedMIB_variables_oid) / sizeof(oid),
                             "LLDP-EXT-MED-MIB : lldpXMedMIB");

    DEBUGMSGTL(("lldpXMedMIB", "Initializing\n"));

    /*
    * register ourselves with the agent to handle our mib tree
    */
    REGISTER_MIB("lldpXMedMIB", lldpXMedMIB_variables, variable4,
                 lldpXMedMIB_variables_oid);

    /*
    * place any other initialization junk you need here
    */
}

/*
* var_lldpXMedMIB():
*   This function is called every time the agent gets a request for
*   a scalar variable that might be found within your mib section
*   registered above.  It is up to you to do the right thing and
*   return the correct value.
*     You should also correct the value of "var_len" if necessary.
*
*   Please see the documentation for more information about writing
*   module extensions, and check out the examples in the examples
*   and mibII directories.
*/
u_char         *
var_lldpXMedMIB(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    // No indexes, so we can use header_generic
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;

    }


    CapArray<vtss_appl_lldp_port_conf_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> lldp_port_conf;
    if (table_info.isid != VTSS_ISID_START) {
        return NULL;
    }
    (void) lldp_mgmt_conf_get(&lldp_port_conf[0]);

    vtss_appl_lldp_common_conf_t  lldp_conf;
    (void) vtss_appl_lldp_common_conf_get(&lldp_conf);

    static long VALUE = 0;
    static long VAR = 0;

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCMODELNAME: {
        // PD only
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_LLDP_MED
    case LLDPXMEDLOCDEVICECLASS: {
        VAR = LLDPMED_DEVICE_TYPE_NETWORK_CONNECTIVITY;
#ifdef VTSS_SW_OPTION_LLDP_MED_TYPE
        if (lldp_port_conf[PORT_INDEX].lldpmed_device_type == VTSS_APPL_LLDP_MED_END_POINT) {
            VAR = LLDPMED_DEVICE_TYPE_ENDPOINT_CLASS_I;
        }
#endif
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCSOFTWAREREV: {
        // PD only
        VAR = VALUE;
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPSEPOWERSOURCE: {
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - Enter");
        meba_poe_power_source_t power_source = poe_mgmt_get_power_source();
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - Enter 2");

        // See IEEE MIB definition of power source
        switch (power_source) {
        case MEBA_POE_POWER_SOURCE_PRIMARY: {
            VAR = 2;
            break;
        }
        case MEBA_POE_POWER_SOURCE_BACKUP: {
            VAR = 3;
            break;
        }
        default:
            T_EG(TRACE_GRP_SNMP, "Unknwon power source : %d", power_source);
            VAR = 2;  // Set source to primary as default.
            break;
        }
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - power source =%lu", VAR);
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCFIRMWAREREV: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPDPOWERSOURCE: {
        VAR = 1; // We are a PSE, so we returns "unknown"
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEDEVICETYPE: {
        VAR = 2;        // The switch will always be PSE type - See IEEE Mib definitions
        return (u_char *) & VAR;
    }
#endif
#ifdef VTSS_SW_OPTION_LLDP_MED
    case LLDPXMEDFASTSTARTREPEATCOUNT: {
        *write_method = write_lldpXMedFastStartRepeatCount;
        VAR = lldp_conf.medFastStartRepeatCount;
        return (u_char *) & VAR;
    }
#endif
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPDPOWERPRIORITY: {
        VAR = 1; // We are a PSE, so we returns "unknown"
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCASSETID: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCHARDWAREREV: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMFGNAME: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEPDPOWERREQ: {
        VAR = 0; // Not a PSE
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCSERIALNUM: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpXMedMIB\n",
                    vp->magic));
    }
    return NULL;
}

#ifdef VTSS_SW_OPTION_LLDP_MED
static ulong port2table_index(mesa_port_no_t iport)
{
    dot1Port_info_t  dot1Port_info;

    dot1Port_info.type = DOT1PORT_TYPE_PORT;
    dot1Port_info.isid = table_info.isid;
    dot1Port_info.if_id = iport;

    if (dot1Port_get_by_interface(&dot1Port_info)) {
        return dot1Port_info.dot1port;
    } else {
        return IFTABLE_IFINDEX_END;
    }
}


static mesa_rc get_table_info(ulong *table_index,
                              ulong lldp_loc_port_num,
                              int exact)
{
    dot1Port_info_t  tbl_info;

    //  Select first port if "get next"
    if (lldp_loc_port_num == 0 && !exact) {
        lldp_loc_port_num = 1;
    }

    tbl_info.dot1port = lldp_loc_port_num - 1;

    T_NG(TRACE_GRP_SNMP, "dot1port is %u", tbl_info.dot1port);
    if (FALSE == dot1Port_get_next(&tbl_info)) {
        return VTSS_UNSPECIFIED_ERROR;// Stop when last index is exceeded
    }

    *table_index = tbl_info.dot1port;
    table_info.if_id = tbl_info.if_id;
    table_info.isid = tbl_info.isid;
    T_NG(TRACE_GRP_SNMP, "dot1port is %u, %d/%d", tbl_info.dot1port, table_info.isid, table_info.if_id);

    return VTSS_RC_OK;
}



//
// The application type is of type 0-8 (table 12, TIA1057), while the MIB uses BITS type.
// Therefore we need to be able to convert between the 2 types.

// Converting from application type to BITS type
static ulong appl_type2bits(ulong appl_type)
{
    return 1 << appl_type;
}


// Converting from BITS to application type
static ulong bits2appl_type(ulong bits)
{
    int i;
    for (i = 0; i < 32; i++) {
        if (bits & (1 << i)) {
            return i;
        }
    }
    return 0;
}

static BOOL bits_next(oid *bits, ulong bits_len, ulong *value)
{
    int i, j, tmp;

    if (bits[0] > bits_len - 1) {
        return FALSE;
    } else if (bits[0] < bits_len - 1) {
        bits[0] = bits_len - 1;
        memset (bits + 1, 0, bits[0] * sizeof(bits[0]));
    }

    for (i = 0; i < bits[0]; i++) {
        for (j = 0; j < 8; j++) {
            if ((tmp = bits[i + 1] & (1 << (7 - j)))) {
                if (j == 0 && i == 0) {
                    return FALSE;
                }

                if (value) {
                    *value = (j + i * 8) - 1;
                }
                memset (bits + 1, 0, bits[0] * sizeof(bits[0]));
                if (j == 0) {
                    bits[i] = 1;
                    bits[i + 1] = 0;
                } else {
                    bits[i + 1] = (1 << (7 - j)) << 1;
                }
                return TRUE;
            }
        }
    }

    /* get first */
    bits[bits_len - 1] = 1;
    if (value) {
        *value = (7 + (bits[0] - 1) * 8);
    }
    return TRUE;
}

// Converting from BITS to unsinged int
static BOOL bits_get(oid *bits, ulong bits_len, ulong *value)
{
    int i = 0;
    oid *tmp = NULL;
    BOOL ready_to_get = FALSE;
    if (!bits || bits[0] != bits_len - 1) {
        return FALSE;
    }

    if (VTSS_MALLOC_CAST(tmp, bits_len * sizeof(oid)) == NULL) {
        T_E("malloc failed, size: %lu", bits_len * sizeof(oid));
        return FALSE;
    }

    memcpy(tmp, bits, bits_len * sizeof(oid));

    for (i = bits_len - 1; i > 0; --i) {
        if (tmp[i] == 0) {
            tmp[i] = 255;
            continue;
        } else {
            --tmp[i];
            ready_to_get = TRUE;
            break;
        }
    }

    if (!ready_to_get) {
        VTSS_FREE(tmp);
        return FALSE;
    }


    if (FALSE == bits_next(tmp, bits_len, value) || memcmp(tmp, bits, bits_len * sizeof(oid))) {
        VTSS_FREE(tmp);
        return FALSE;
    }
    VTSS_FREE(tmp);
    return TRUE;
}

static BOOL uint2bits(ulong value, oid *bits, ulong bits_len)
{
    if (!bits || bits_len < 2 || value >= 16 * (bits_len - 1)) {
        return FALSE;
    }
    memset (bits, 0, sizeof(bits[0]) * bits_len);
    bits[0] = bits_len - 1;
    bits[value / 8 + 1] = 1 << (7 - value % 8);
    return TRUE;
}

#endif

/*
* var_lldpXMedLocMediaPolicyTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocMediaPolicyTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    ulong           table_index = 0;
    static long     VAR;
    int             p_index;

    int     lowest_table_index = 0;
    int     lowest_port_num = 0;
    oid     *op = NULL;
    oid     bits[3] = {0, 0, 0}, *bits_ptr = bits;
    size_t  bits_len = sizeof(bits) / sizeof(bits[0]);

    ulong lldp_loc_port_num = 0;
    ulong lldpx_med_loc_media_policy_app_type = 0;
    vtss_appl_lldp_med_policy_t policy;
    vtss_appl_lldp_common_conf_t  lldp_conf;
    CapArray<vtss_appl_lldp_port_conf_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> lldp_port_conf;
    vtss_ifindex_t ifindex;
    BOOL enabled;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long); /* assume an integer and change later if not */


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    BOOL found = FALSE;
    int oid_length = 14; // (oid = 1.0.8802.1.1.2.5.4795.1.2.1.1.2)

    if (exact && *length != oid_length + 4) {
        return NULL;
    }
    op = name + oid_length; // point to first index
    if (op < name + *length) {
        lldp_loc_port_num = *op++;
    }

    if (op < name + *length) {
        int init_bits_len = (name + *length - op >= bits_len) ?
                            bits_len : (name + *length - op);
        BOOL init_bits_done = FALSE;
        int i;

        T_NG(TRACE_GRP_SNMP, "offset = " VPRIsz, name + *length - op);

        bits_ptr[0] = *op++;

        for (i = 1; i < init_bits_len; i++) {
            bits_ptr[i] = *op++;
        }

        T_NG(TRACE_GRP_SNMP, "init_bits_len = %d, bits_len = " VPRIz, init_bits_len, bits_len);
        if (init_bits_len != bits_len) {
            for (i = bits_len - 1; i > 0; --i) {
                if (bits_ptr[i] == 0) {
                    bits_ptr[i] = 255;
                    continue;
                } else {
                    --bits_ptr[i];
                    init_bits_done = TRUE;
                    break;
                }
            }
            if (init_bits_done == FALSE) {
                memset (bits, 0, sizeof(bits));
            }
        }
    }

    T_DG(TRACE_GRP_SNMP, "Initial value: key = %lu%s, execute %s operation", lldp_loc_port_num, misc_oid2txt(bits_ptr, bits_len), exact ? "GET" : "GET-NEXT");

    if (exact) {
        if (get_table_info(&table_index,
                           lldp_loc_port_num,
                           exact) != VTSS_RC_OK) {
            return NULL;
        }

        (void) vtss_appl_lldp_common_conf_get(&lldp_conf);
        if (table_info.isid != VTSS_ISID_START) {
            return NULL;
        }
        (void) lldp_mgmt_conf_get(&lldp_port_conf[0]);

        (void) vtss_ifindex_from_port(table_info.isid, table_info.if_id, &ifindex);
        T_NG(TRACE_GRP_SNMP, "lldp_loc_port_num =" VPRIlu", lldpx_med_loc_media_policy_app_type =" VPRIlu", *length =" VPRIz", port_no = %u",
             lldp_loc_port_num, lldpx_med_loc_media_policy_app_type, *length, table_info.if_id);

        if (table_index != lldp_loc_port_num) {
            return NULL;
        }

        if (FALSE == bits_get(bits_ptr, bits_len, &lldpx_med_loc_media_policy_app_type)) {
            T_DG(TRACE_GRP_SNMP, "bits = %s", misc_oid2txt(bits_ptr, bits_len));
            return NULL;
        }

        T_DG(TRACE_GRP_SNMP, "type = %lu", lldpx_med_loc_media_policy_app_type);
        for (p_index = LLDPMED_POLICY_MIN ; p_index <= LLDPMED_POLICY_MAX; p_index++ ) {
            (void) vtss_appl_lldp_conf_port_policy_get(ifindex, p_index, &enabled);
            if (enabled) {
                (void) vtss_appl_lldp_conf_policy_get(p_index, &policy);

                if (policy.network_policy.application_type == lldpx_med_loc_media_policy_app_type) {
                    found = TRUE;
                    lowest_port_num = table_info.if_id;
                    lowest_table_index = p_index;
                    break;
                }
            }
        }
    } else {


        // Not exact. Find policy with lowest indexes above the request oid indexes.

        int iport;
        /* Becasue the lldpXMedLocMediaPolicyAppType syntex is BITS which means the lower value of type
           will be encoded as higher bit, the initial value for comparing is VOICE(1) */
        ulong highest_app_type = 0, tmp;
        BOOL next_from_bits = TRUE;
        lowest_port_num = fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT) + 1;

        /* if the primary key exists, get the next secondary key, Otherwise, get the next primary key and get first secondary key */
        next_from_bits = get_table_info(&table_index, lldp_loc_port_num, TRUE) ? FALSE : TRUE;

        if (next_from_bits) {
            while (bits_next(bits_ptr, bits_len, &tmp)) {
                if (tmp <= VIDEO_SIGNALING && tmp > 0) {
                    found = TRUE;
                    break;
                }
            }
            if (FALSE == found) {
                if (get_table_info(&table_index, lldp_loc_port_num + 1, FALSE)) {
                    T_NG(TRACE_GRP_SNMP, "there's no port_num after %lu", lldp_loc_port_num);
                    return NULL;
                }

                tmp = VIDEO_SIGNALING;
            }
        } else {
            if (lldp_loc_port_num == 0xffffffff) {
                /* the primary key overflow */
                return NULL;
            }
            if (get_table_info(&table_index, lldp_loc_port_num + 1, FALSE)) {
                T_NG(TRACE_GRP_SNMP, "there's no port_num after %lu", lldp_loc_port_num);
                return NULL;
            }

            tmp = VIDEO_SIGNALING;
        }

        found = FALSE;
        T_DG(TRACE_GRP_SNMP, "Start to traverse the existent entry from port %d, type %lu", table_info.if_id, tmp);
        for (iport = (int)table_info.if_id ; iport < fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT); iport++ ) {
            if (iport < 0) {
                break;
            }

            (void) vtss_ifindex_from_port(table_info.isid, iport, &ifindex);

            T_NG(TRACE_GRP_SNMP, "port %d/%d: tmp = %lu, fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT) = %d", table_info.isid, iport, tmp, fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT));
            for (p_index = LLDPMED_POLICY_MAX ; p_index >= LLDPMED_POLICY_MIN; p_index-- ) {
                (void) vtss_appl_lldp_conf_port_policy_get(ifindex, p_index, &enabled);

                if (enabled) {
                    (void) vtss_appl_lldp_conf_policy_get(p_index, &policy);

                    T_NG(TRACE_GRP_SNMP, "p_index %d: type = %d, tmp = %lu, highest_app_type = %lu)", p_index,
                         policy.network_policy.application_type, tmp, highest_app_type);
                    /* find the max type which lower than highest_app_type */
                    if (policy.network_policy.application_type == tmp) {
                        T_DG(TRACE_GRP_SNMP, "get port %d, type %lu", iport, highest_app_type);
                        highest_app_type = policy.network_policy.application_type;
                        found = TRUE;
                        lowest_port_num = iport;
                        lowest_table_index = p_index;

                        break;
                    }

                    if (policy.network_policy.application_type < tmp && policy.network_policy.application_type >= highest_app_type) {
                        highest_app_type = policy.network_policy.application_type;
                        found = TRUE;
                        lowest_port_num = iport;
                        lowest_table_index = p_index;
                    }
                }
            }
            if (FALSE == found) {
                tmp = VIDEO_SIGNALING;
                highest_app_type = 0;
            } else {
                break;
            }
        }
    }

    if (!found) {
        T_NG(TRACE_GRP_SNMP, "NOT found");
        return NULL;
    }

    // Return the index found
    *length = oid_length;

    (void) vtss_appl_lldp_conf_policy_get(lowest_table_index, &policy);
    name[(*length)++] = port2table_index(lowest_port_num);

    uint2bits(policy.network_policy.application_type, bits_ptr, 3);
    memcpy(name + (*length), bits_ptr, 3 * sizeof(oid));
    (*length) += 3;

    T_DG(TRACE_GRP_SNMP, "lowest_port_num = %d, lowest_table_index, key = %s", lowest_port_num, misc_oid2txt(name + 14, *length - 14));


    T_NG(TRACE_GRP_SNMP, " lldp_conf.policies_table[%d].application_type = %d, lowest_port_num = %d",
         lowest_table_index, policy.network_policy.application_type, lowest_port_num);

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCMEDIAPOLICYAPPTYPE: {
        return NULL;
    }
    case LLDPXMEDLOCMEDIAPOLICYVLANID: {
        T_NG(TRACE_GRP_SNMP, "LLDPXMEDLOCMEDIAPOLICYVLANID");
        VAR = policy.network_policy.vlan_id;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYPRIORITY: {
        VAR = (i32) policy.network_policy.l2_priority;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYDSCP: {
        VAR = policy.network_policy.dscp_value;
        return (u_char *) & VAR;
    }
#if 0
    case LLDPXMEDLOCMEDIAPOLICYUNKNOWN: {
        VAR = 0;
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCMEDIAPOLICYTAGGED: {
        VAR = bool2truthvalue(policy.network_policy.tagged_flag);
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocMediaPolicyTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}



/*
* var_lldpXMedLocXPoEPSEPortTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocXPoEPSEPortTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_POE
    static long VAR;
#endif

    // Determine if the table indexes are in use
    if ((header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_RC_OK) || (table_info.isid != VTSS_ISID_START)) {
        return NULL;
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPSEPORTPOWERAV: {

        // Get PoE status
        poe_status_t          poe_status;
        poe_mgmt_get_status(&poe_status);
        VAR = poe_status.port_status[PORT_INDEX].power_reserved_dw;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEPSEPORTPDPRIORITY: {
        poe_conf_t poe_conf;
        poe_config_get(&poe_conf);

        switch (poe_conf.priority[PORT_INDEX]) {
        case VTSS_APPL_POE_PORT_POWER_PRIORITY_LOW: {
            VAR = 4;
            break;
        }
        case VTSS_APPL_POE_PORT_POWER_PRIORITY_HIGH: {
            VAR = 3;
            break;
        }
        case VTSS_APPL_POE_PORT_POWER_PRIORITY_CRITICAL: {
            VAR = 2;
            break;
        }
        default: {
            T_EG_PORT(TRACE_GRP_SNMP, (u32)PORT_INDEX, "Unknown priority:%d", poe_conf.priority[PORT_INDEX]);
            VAR = 1; // Default to unknown
        }
        }
        T_DG_PORT(TRACE_GRP_SNMP, (u32)PORT_INDEX, "LLDPXMEDLOCXPOEPSEPORTPDPRIORITY found, %d", VAR);

        return (u_char *) & VAR;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocXPoEPSEPortTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
* var_lldpXMedPortConfigTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedPortConfigTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    ulong table_index = 0;
    ulong lldp_loc_port_num = 0;
    int   oid_length = 14; // (oid = 1.0.8802.1.1.2.5.4795.1.1.2.1.2)
    oid   *op = NULL;

    // Determine if the table indexes are in use
    if ((table_info.isid != VTSS_ISID_START) || (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_RC_OK)) {
        return NULL;
    }

    op = name + oid_length; // point to first index
    if (op < name + *length) {
        lldp_loc_port_num = *op++;
    }

    if (get_table_info(&table_index, lldp_loc_port_num, FALSE)) {
        T_NG(TRACE_GRP_SNMP, "there's no port_num after %lu", lldp_loc_port_num);
        return NULL;
    }

    static long VAR = 0 ;// Default

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDPORTCAPSUPPORTED: {
        VAR = BITS_type_swapbyte(lldpmed_get_capabilities_word(PORT_INDEX));
        T_NG(TRACE_GRP_SNMP, "Capabilities = %lu", VAR);
        return (u_char *) & VAR;
    }
    case LLDPXMEDPORTCONFIGTLVSTXENABLE: {
        *write_method = write_lldpXMedPortConfigTLVsTxEnable;
        CapArray<vtss_appl_lldp_port_conf_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> lldp_conf;
        (void) lldp_mgmt_conf_get(&lldp_conf[0]);
        VAR = BITS_type_swapbyte(lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask);
        *var_len = 1;
        return (u_char *) & VAR;
    }
    case LLDPXMEDPORTCONFIGNOTIFENABLE: {
        VAR = lldpmed_mgmt_get_notification_ena(PORT_INDEX);
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedPortConfigTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemCapabilitiesTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemCapabilitiesTable(struct variable *vp,
                                 oid *name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len,
                                 WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static long VAR;

    vtss_appl_lldp_remote_entry_t    entry;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_RC_OK) {
        return NULL;
    }

    VAR = 0 ;// Default
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMCAPSUPPORTED: {
        if (entry.lldpmed_capabilities_vld) {
            VAR = BITS_type_swapbyte(entry.lldpmed_capabilities);
            T_NG(TRACE_GRP_SNMP, "entry.lldpmed_capabilities = 0x%X", entry.lldpmed_capabilities);
            return (u_char *) & VAR;
        } else {
            return NULL;
        }

    }
    case LLDPXMEDREMCAPCURRENT: {
        if (entry.lldpmed_capabilities_vld) {
            VAR = BITS_type_swapbyte(entry.lldpmed_capabilities_current);
            return (u_char *) & VAR;
        } else {
            return NULL;
        }
    }
    case LLDPXMEDREMDEVICECLASS: {
        if (entry.lldpmed_capabilities_vld) { // Note : Device type is in the TLV as capabilities (Figure 6, TIA1057), so we use the same valid bit.
            T_NG(TRACE_GRP_SNMP, "Device Type = %d", entry.lldpmed_device_type);
            VAR = entry.lldpmed_device_type;
            return (u_char *) & VAR;
        } else {
            return NULL;
        }
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemCapabilitiesTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}





/*
* var_lldpXMedRemXPoETable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoETable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    vtss_appl_lldp_remote_entry_t    entry;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_RC_OK) {
        return NULL;
    }

#ifdef VTSS_SW_OPTION_POE
    static long VAR    = 0;
    int power_type     = 0;
    int power_source   = 0;
    int power_priority = 0;
    int power_value    = 0;
    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        T_DG(TRACE_GRP_SNMP, "entry NOT in use");
        power_type = 4; // Set power type to none - see IEEE MIBS
        power_source = 2 ; // Set power power source to primary - see IEEE MIBS
        power_priority = 4; // Set power priority to low - - see IEEE MIBS
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMXPOEDEVICETYPE: {


        // Convertion between power type and MIB power type ( IEEE 801.2at/D3 table 33-22 vs IEEE MIB )
        T_DG(TRACE_GRP_SNMP, "power_type = %d", power_type);
        switch (power_type) {
        case 0:
        case 2: {
            VAR = 2; // 2 = PSE - See IEEE MIB
            break;
        }
        case 1:
        case 3: {
            VAR = 3; // 3 = PD - See IEEE MIB
            break;
        }
        default:
            VAR = 4; // Set power type to none - see IEEE MIBS
        }

        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoETable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemInventoryTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemInventoryTable(struct variable *vp,
                              oid *name,
                              size_t *length,
                              int exact,
                              size_t *var_len,
                              WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static char     VAR_STR[255];
    vtss_appl_lldp_remote_entry_t entry;


    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.3.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_RC_OK) {
        return NULL;
    }



    T_NG(TRACE_GRP_SNMP, "Getting var_lldpXMedRemInventoryTable");
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMHARDWAREREV: {
        if (entry.lldpmed_hw_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_hw_rev, entry.lldpmed_hw_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMFIRMWAREREV: {
        if (entry.lldpmed_firm_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_firm_rev, entry.lldpmed_firm_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }

    }
    case LLDPXMEDREMSOFTWAREREV: {
        if (entry.lldpmed_sw_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_sw_rev, entry.lldpmed_sw_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMSERIALNUM: {
        if (entry.lldpmed_serial_no_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_serial_no, entry.lldpmed_serial_no_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMMFGNAME: {
        if (entry.lldpmed_manufacturer_name_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_manufacturer_name, entry.lldpmed_manufacturer_name_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMMODELNAME: {
        if (entry.lldpmed_model_name_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_model_name, entry.lldpmed_model_name_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMASSETID: {
        if (entry.lldpmed_asset_id_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_asset_id, entry.lldpmed_asset_id_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemInventoryTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

//static lldp_u32_t set_loc_location_type = 0;

/*
* var_lldpXMedLocLocationTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocLocationTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static uchar     VAR_STR[255];

    oid                    *op = NULL;
    lldp_u32_t index_loc_port_num = 0;
    lldp_u32_t index_xmed_loc_location_subtype = 0;

    mesa_rc rc = VTSS_UNSPECIFIED_ERROR;
    lldp_u16_t   subtype_idx;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    int oid_length = 14; // (oid =  (1.0.8802.1.1.2.1.5.4795.1.2.9.1.2)
    op = name + oid_length; // point to first index

    // The 2 indexes
    if (op < name + *length) {
        index_loc_port_num = *op++;
    }
    if (op < name + *length) {
        index_xmed_loc_location_subtype = *op++;
    }

    ulong          table_index = 0;
    if (get_table_info(&table_index,
                       index_loc_port_num,
                       exact) != VTSS_RC_OK) {
        return NULL;
    }

    if (exact) {
        // Check that the OID has the correct length
        if (*length < 16) {
            return NULL;
        }

        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }
        rc = VTSS_RC_OK;
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");

        for (subtype_idx = 2; subtype_idx <= 4; subtype_idx++) {
            T_NG(TRACE_GRP_SNMP, "index_loc_port_num = %u, index_xmed_loc_location_subtype = %u, subtype_idx = %d",
                 index_loc_port_num, index_xmed_loc_location_subtype, subtype_idx);

            if (subtype_idx > index_xmed_loc_location_subtype) {
                index_xmed_loc_location_subtype = subtype_idx;
                rc = VTSS_RC_OK;
                break;
            }
        }

        T_DG(TRACE_GRP_SNMP, "index_xmed_loc_location_subtype = %u", index_xmed_loc_location_subtype);
//        if (index_loc_port_num == 0) {
//            index_loc_port_num = 1;
//        }

    }

    if (rc != VTSS_RC_OK) {
        return NULL;
    }


    // length = 14 (1.0.8802.1.1.2.1.5.4795.1.2.9.1.2)
    *length = oid_length;
    name[(*length)++] = table_index;
    name[(*length)++] = index_xmed_loc_location_subtype;

    lldp_u16_t i;
    for (i = 0; i < *length; i++) {
        T_DG(TRACE_GRP_SNMP, "%lu", name[i]);
    }



    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCLOCATIONSUBTYPE: {
        return NULL;
    }
    case LLDPXMEDLOCLOCATIONINFO: {
#ifdef VTSS_SW_OPTION_LLDP_MED
        /* TO_DO, we don't support now */
        // *write_method = write_lldpXMedLocLocationInfo;

        *var_len = 0 ;

        //set_loc_location_type = index_xmed_loc_location_subtype;
        switch (index_xmed_loc_location_subtype) {
        case 2:
            *var_len = (size_t) lldp_mgmt_lldpmed_coordinate_location_tlv_add(&VAR_STR[0]);
            break;
        case 3:
            *var_len = (size_t) lldp_mgmt_lldpmed_civic_location_tlv_add(&VAR_STR[0]);
            break;

        case 4:
            *var_len = (size_t) lldp_mgmt_lldpmed_ecs_location_tlv_add(&VAR_STR[0]) ;
            break;
        default:
            T_W("Invalid location subtype = %u", index_xmed_loc_location_subtype);
#endif
            return NULL;
        }

        return (u_char *) &VAR_STR[0];
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocLocationTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemXPoEPDTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoEPDTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{

#ifdef VTSS_SW_OPTION_POE
    vtss_appl_lldp_remote_entry_t entry;
    static long         VAR;


    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.7.1.3)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_RC_OK) {
        return NULL;
    }


    int power_type     = 0;
    int power_source   = 0;
    int power_priority = 0;
    int power_value    = 0;


    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        T_DG(TRACE_GRP_SNMP, "entry NOT in use");
        power_source = 1 ; // Set power power source to unknown - see IEEE MIBS
        power_priority = 1; // Set power priority to unknown - - see IEEE MIBS
        power_value = 0;
    }


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMXPOEPDPOWERREQ: {
        VAR = power_value;
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPDPOWERSOURCE: {
        T_DG(TRACE_GRP_SNMP, "power_source = %d", power_source);
        VAR = power_source + 1;  // Power source has added one for the MIB - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPDPOWERPRIORITY: {
        VAR = power_priority + 1;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoEPDTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemXPoEPSETable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoEPSETable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_EEE
    vtss_appl_lldp_remote_entry_t entry;
    eee_switch_state_t  eee_state;
    eee_switch_conf_t switch_conf;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_RC_OK) {
        return NULL;
    }


    T_NG(TRACE_GRP_SNMP, "LocalPortNum is %lu", name[*length - 2]);
    if (eee_mgmt_switch_state_get(table_info.isid, &eee_state)) {
        T_DG(TRACE_GRP_SNMP, "invoke eee_mgmt_switch_state_get(%d) failed", table_info.isid);
        return NULL;
    }

    if (eee_mgmt_switch_conf_get(table_info.isid, &switch_conf)) {
        T_DG(TRACE_GRP_SNMP, "invoke eee_mgmt_switch_conf_get(%d) failed", table_info.isid);
        return NULL;
    }

    T_NG(TRACE_GRP_SNMP, "EEE for interface(%d/%d): cap = 0x%x, enable = %s, lp_cap = 0x%x  \n",
         table_info.isid, table_info.if_id, eee_state.port[table_info.if_id].eee_capable,
         switch_conf.port[table_info.if_id].eee_ena ? "ENABLED" : "DISABLED",
         eee_state.port[table_info.if_id].link_partner_eee_capable);

    if (!eee_state.port[table_info.if_id].eee_capable) {
        T_DG(TRACE_GRP_SNMP, "EEE not supported for this interface(%d/%d)\n", table_info.isid, table_info.if_id);
        return NULL;
    } else if (!switch_conf.port[table_info.if_id].eee_ena) {
        T_DG(TRACE_GRP_SNMP, "EEE not enabled for this interface(%d/%d)\n", table_info.isid, table_info.if_id);
        return NULL;
    } else if (!eee_state.port[table_info.if_id].link_partner_eee_capable) {
        T_DG(TRACE_GRP_SNMP, "Link partner is not EEE capable\n");
        return NULL;
    }

#ifdef VTSS_SW_OPTION_POE
    static long VAR;
    int power_type;
    int power_source;
    int power_priority;
    int power_value;

    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        power_source = 1 ; // Set power power source to unknown - see IEEE MIBS
        power_priority = 1; // Set power priority to unknown- - see IEEE MIBS
    }
#endif

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDREMXPOEPSEPOWERAV: {
        VAR = power_value;
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPSEPOWERSOURCE: {

        VAR = power_source + 1;  // Power source has added one for the MIB - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPSEPOWERPRIORITY: {


        VAR = power_priority + 1;    // The MIB has added one to the priority - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoEPSETable\n",
                    vp->magic));
    }
#endif  /* VTSS_SW_OPTION_EEE */
    return NULL;
}

/*
* var_lldpXMedRemMediaPolicyTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemMediaPolicyTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static long          VAR = 0;
    oid                  *op = NULL;
    u32                  idx_num;
    vtss_appl_lldp_remote_entry_t  entry, temp_entry;
    lldp_u8_t            entry_appl_type = 0, temp_entry_appl_type = 0;
    ulong                table_index = 0;
    lldp_u32_t           index_rem_time_mark = 0;
    lldp_u32_t           index_rem_local_port_num = 0;
    lldp_u16_t           index_rem_index = 0;
    lldp_u32_t           index_xmed_media_policy_app_type = 0;
    int                  policy_idx_to_be_used = 0;
    int                  policy_idx = 0;
    lldp_bool_t          found = LLDP_FALSE;
    vtss_appl_lldp_cap_t cap;

    if (table_info.isid != VTSS_ISID_START) {
        return NULL;
    }
    (void) vtss_appl_lldp_cap_get(&cap);


    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long);     /* assume an integer and change later if not */

    // Clear the entry to start from knwon point
    memset(&entry, 0x0, sizeof(entry));
    memset(&temp_entry, 0x0, sizeof(temp_entry));


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    // Get the entries
    vtss_appl_lldp_remote_entry_t *entries = NULL;
    vtss_appl_lldp_mutex_lock();
    entries = vtss_appl_lldp_entries_get();
    vtss_appl_lldp_mutex_unlock();


    op = name + 14; // point to first index

    if (op < name + *length) {
        index_rem_time_mark = *op++;
    }

    if (op < name + *length) {
        index_rem_local_port_num = *op++;
    }

    if (op < name + *length) {
        index_rem_index = *op++;
    }

    if (op < name + *length) {
        index_xmed_media_policy_app_type = bits2appl_type(*op++);
    }

    if (get_table_info(&table_index,
                       index_rem_local_port_num,
                       exact) != VTSS_RC_OK ) {
        return NULL;
    }


    if (exact) {

        // Check that the OID has the correct length
        if (*length < 18) { /* 1.0.8802.1.1.2.5.4795.1.3.2.1.2 + 4 indexes */
            return NULL;
        }


        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }

        for (idx_num = 0; idx_num < cap.remote_entries_cnt; idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }


            if (entry.time_mark          == index_rem_time_mark &&
                entry.receive_port       == table_info.if_id &&
                entry.lldp_remote_index  == index_rem_index) {


                for (policy_idx = 0; policy_idx < VTSS_APPL_LLDP_MED_POLICY_APPLICATIONS_CNT; policy_idx++ ) {
                    entry_appl_type = entry.policy[policy_idx].network_policy.application_type;
                    if (entry.policy[policy_idx].in_use == LLDP_TRUE &&
                        entry_appl_type == index_xmed_media_policy_app_type) {
                        policy_idx_to_be_used = policy_idx;
                        found = TRUE;
                        break;
                    }
                }
            }
        }
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");
        T_NG(TRACE_GRP_SNMP, "mark time %u - port %u - index %u, appl  %u",
             index_rem_time_mark,
             table_info.if_id,
             index_rem_index,
             index_xmed_media_policy_app_type);



        /* Use parameters of time_mark, local_port_num, index, policy_app_type
        to lookup your entry, find a entry that entry keys is great current keys */

        for (idx_num = 0; idx_num < cap.remote_entries_cnt; idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            for (policy_idx = 0; policy_idx < VTSS_APPL_LLDP_MED_POLICY_APPLICATIONS_CNT; policy_idx++ ) {
                T_RG(TRACE_GRP_SNMP, "entry.policy_vld[%d] = %d", policy_idx, entry.policy[policy_idx].in_use);
                if (entry.policy[policy_idx].in_use == LLDP_TRUE) {
                    entry_appl_type = entry.policy[policy_idx].network_policy.application_type;
                    T_NG(TRACE_GRP_SNMP, "Policy found, policy_idx = %d", policy_idx);



                    if (entry.time_mark > index_rem_time_mark ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port > table_info.if_id) ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port == table_info.if_id && entry.lldp_remote_index > index_rem_index) ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port == table_info.if_id && entry.lldp_remote_index == index_rem_index &&
                         entry_appl_type > index_xmed_media_policy_app_type)) {

                        if (found == 0) {
                            /* record the fist find entry that entry keys is great current keys */
                            T_NG(TRACE_GRP_SNMP, "found = 1");
                            found = 1;
                            temp_entry = entry;
                            temp_entry_appl_type = entry_appl_type;
                            policy_idx_to_be_used = policy_idx;

                            /* keep lookup to find if there is any smaller keys entry */

                        } else if (temp_entry.time_mark > entry.time_mark ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port > entry.receive_port) ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index > entry.lldp_remote_index) ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index == entry.lldp_remote_index && temp_entry_appl_type > entry_appl_type)) {
                            /* find another smaller keys entry */
                            T_NG(TRACE_GRP_SNMP, "Update temp entry");
                            temp_entry = entry;
                            temp_entry_appl_type = entry_appl_type;
                            policy_idx_to_be_used = policy_idx;
                        }
                    }
                }
            }

        }

        entry = temp_entry;
        entry_appl_type = temp_entry_appl_type;
    }

    if (found) {
        T_NG(TRACE_GRP_SNMP, "rc = VTSS_RC_OK");
        *length = 14; // 1.0.8802.1.1.2.1.5.4795.1.3.2.1.2
        name[(*length)++] = entry.time_mark;
        name[(*length)++] = port2table_index(entry.receive_port);
        name[(*length)++] = entry.lldp_remote_index;
        name[(*length)++] = appl_type2bits(entry_appl_type);
    } else {
        return NULL;
    }


    T_NG(TRACE_GRP_SNMP, "Policy found,policy_idx_to_be_used = %d, %d", policy_idx_to_be_used, VTSS_APPL_LLDP_MED_POLICY_APPLICATIONS_CNT);
    T_NG(TRACE_GRP_SNMP, "vp->magic = %u", vp->magic);
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMMEDIAPOLICYAPPTYPE: {
        return NULL;
    }
    case LLDPXMEDREMMEDIAPOLICYVLANID: {
        VAR = entry.policy[policy_idx_to_be_used].network_policy.vlan_id;
        T_NG(TRACE_GRP_SNMP, "LLDPXMEDREMMEDIAPOLICYVLANID VAR = %lu", VAR);
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYPRIORITY: {
        VAR = entry.policy[policy_idx_to_be_used].network_policy.l2_priority;
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYDSCP: {
        VAR = entry.policy[policy_idx_to_be_used].network_policy.dscp_value;
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYUNKNOWN: {
        VAR = entry.policy[policy_idx_to_be_used].network_policy.unknown_policy_flag;
        T_NG(TRACE_GRP_SNMP, "Unknown policy");
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYTAGGED: {

        VAR = bool2truthvalue(entry.policy[policy_idx_to_be_used].network_policy.tagged_flag);
        return (u_char *) &VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemMediaPolicyTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemLocationTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemLocationTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static char            VAR_STR[255];
    oid                    *op = NULL;
    u32                    idx_num;
    vtss_appl_lldp_remote_entry_t    entry, temp_entry;

    lldp_u32_t index_rem_time_mark = 0;
    lldp_u32_t index_rem_local_port_num = 0;
    lldp_u16_t index_rem_index = 0;
    lldp_u16_t index_xmed_rem_location_subtype = 0;
    lldp_bool_t found = LLDP_FALSE;
    vtss_appl_lldp_cap_t cap;
    if (table_info.isid != VTSS_ISID_START) {
        return NULL;
    }
    (void) vtss_appl_lldp_cap_get(&cap);

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long);     /* assume an integer and change later if not */

    // Clear the entry to start from knwon point
    memset(&entry, 0x0, sizeof(entry));
    memset(&temp_entry, 0x0, sizeof(temp_entry));


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    // Get the entries
    vtss_appl_lldp_remote_entry_t *entries = NULL;
    vtss_appl_lldp_mutex_lock();
    entries = vtss_appl_lldp_entries_get();
    vtss_appl_lldp_mutex_unlock();


    T_NG(TRACE_GRP_SNMP, "oid is: %s", misc_oid2txt(name, *length));
    op = name + 14; // point to first index

    if (op < name + *length) {
        index_rem_time_mark = *op++;
    }

    if (op < name + *length) {
        index_rem_local_port_num = *op++;
    }

    if (op < name + *length) {
        index_rem_index = *op++;
    }

    if (op < name + *length) {
        index_xmed_rem_location_subtype = *op++;
        // For some strange reason Table 14, TIA1057 doesn't use the same numbering as the MIB in TIA1057,
        // so we have to subtract one.
//        if (index_xmed_rem_location_subtype > 0) {
//            index_xmed_rem_location_subtype--;
//        }
    }

    T_NG(TRACE_GRP_SNMP, "Initial indexs: %d, %d, %d, %d", index_rem_time_mark, index_rem_local_port_num, index_rem_index, index_xmed_rem_location_subtype);
    ulong          table_index = 0;
    if (get_table_info(&table_index,
                       index_rem_local_port_num,
                       exact) != VTSS_RC_OK) {
        return NULL;
    }


    if (exact) {

        // Check that the OID has the correct length
        if (*length < 18) { /* 1.0.8802.1.1.2.5.4795.1.3.4.1.1 + 4 indexes */
            return NULL;
        }

        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }

        for (idx_num = 0; idx_num < cap.remote_entries_cnt; idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }


            if (entry.time_mark             == index_rem_time_mark &&
                entry.receive_port          == table_info.if_id &&
                entry.lldp_remote_index     == index_rem_index &&
                2                           == index_xmed_rem_location_subtype) {

                if (entry.lldpmed_coordinate_location_vld == 1) {
                    found = TRUE;
                    T_NG(TRACE_GRP_SNMP, "found it, indexs: %d, %d, %d, %d", entry.time_mark, entry.receive_port, entry.lldp_remote_index, index_xmed_rem_location_subtype);
                    break;
                }

            }
        }


    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");

        /* Use parameters of time_mark, local_port_num, index, policy_app_type
        to lookup your entry, find a entry that entry keys is great current keys */

        for (idx_num = 0; idx_num < cap.remote_entries_cnt; idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            if (entry.lldpmed_coordinate_location_vld == 1) {
                if (entry.time_mark > index_rem_time_mark ||
                    (entry.time_mark == index_rem_time_mark && entry.receive_port > table_info.if_id) ||
                    (entry.time_mark == index_rem_time_mark &&
                     entry.receive_port == table_info.if_id &&
                     entry.lldp_remote_index > index_rem_index) ||
                    (entry.time_mark == index_rem_time_mark &&
                     entry.receive_port == table_info.if_id &&
                     entry.lldp_remote_index == index_rem_index &&
                     LLDPMED_LOCATION_COORDINATE > index_xmed_rem_location_subtype)) {

                    if (found == FALSE) {
                        /* record the fist find entry that entry keys is great current keys */

                        T_NG(TRACE_GRP_SNMP, "found it, indexs: %d, %d, %d, %d", entry.time_mark, entry.receive_port, entry.lldp_remote_index, index_xmed_rem_location_subtype);
                        found = 1;
                        temp_entry = entry;
                        /* keep lookup to find if there is any smaller keys entry */

                    } else if (temp_entry.time_mark > entry.time_mark ||
                               (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port > entry.receive_port) ||
                               (temp_entry.time_mark == entry.time_mark &&
                                temp_entry.receive_port == entry.receive_port &&
                                temp_entry.lldp_remote_index > entry.lldp_remote_index)) {
                        /* find another smaller keys entry */
                        T_NG(TRACE_GRP_SNMP, "Update temp entry, indexs: %d, %d, %d, %d", entry.time_mark, entry.receive_port, entry.lldp_remote_index, index_xmed_rem_location_subtype);
                        temp_entry = entry;
                    }
                }
            }
        }
        entry = temp_entry;
    }


    if (found) {
        T_NG(TRACE_GRP_SNMP, "rc = VTSS_RC_OK, magic is %d", vp->magic);
        *length = 14; // 1.0.8802.1.1.2.1.5.4795.1.3.4.1.1
        name[(*length)++] = entry.time_mark;
        name[(*length)++] = port2table_index(entry.receive_port);
        name[(*length)++] = entry.lldp_remote_index;
        name[(*length)++] = 2;
    } else {
        return NULL;
    }


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMLOCATIONSUBTYPE: {
        return NULL;
    }

    case LLDPXMEDREMLOCATIONINFO: {
        lldpmed_location2str(&entry, &VAR_STR[0], (lldpmed_location_type_t) LLDPMED_LOCATION_COORDINATE);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemLocationTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

#ifdef VTSS_SW_OPTION_LLDP_MED
int
write_lldpXMedFastStartRepeatCount(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    static u_long  buf     = VTSS_APPL_LLDP_FAST_START_REPEAT_COUNT_DEFAULT;
    static u_long  old_buf = VTSS_APPL_LLDP_FAST_START_REPEAT_COUNT_DEFAULT;
    size_t           max_size = sizeof(u_long);
    u_char          intval = *((u_char *) var_val);


    // Get current configuration
    vtss_appl_lldp_common_conf_t  lldp_conf;
    (void) vtss_appl_lldp_common_conf_get(&lldp_conf);


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < VTSS_APPL_LLDP_FAST_START_REPEAT_COUNT_MIN || intval  > VTSS_APPL_LLDP_FAST_START_REPEAT_COUNT_MAX) {
            T_NG(TRACE_GRP_SNMP, "intval = %d, var_val = %d", intval, *var_val);
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((u_char *) var_val);
        lldp_conf.medFastStartRepeatCount = buf;
        if (vtss_appl_lldp_common_conf_set(&lldp_conf) != VTSS_RC_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_conf.medFastStartRepeatCount = buf;
        if (vtss_appl_lldp_common_conf_set(&lldp_conf) != VTSS_RC_OK) {
            return SNMP_ERR_UNDOFAILED;
        }
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpXMedPortConfigTLVsTxEnable(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    static long    buf, old_buf;
    long            intval;

    intval = (long)(*(var_val));

    // Get current configuration
    CapArray<vtss_appl_lldp_port_conf_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> lldp_conf;
    if (table_info.isid != VTSS_ISID_START) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }
    (void) lldp_mgmt_conf_get(&lldp_conf[0]);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > 1) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval & 0x0F) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *var_val;
        lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask = 0;
        if (buf & 0x80) {
            lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask |= VTSS_APPL_LLDP_MED_OPTIONAL_TLV_CAPABILITIES_BIT;
        }
        if (buf & 0x40) {
            lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask |= VTSS_APPL_LLDP_MED_OPTIONAL_TLV_POLICY_BIT;
        }
        if (buf & 0x20) {
            lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask |= VTSS_APPL_LLDP_MED_OPTIONAL_TLV_LOCATION_BIT;
        }
        if (buf & 0x10) {
            lldp_conf[table_info.if_id].lldpmed_optional_tlvs_mask |= VTSS_APPL_LLDP_MED_OPTIONAL_TLV_POE_BIT;
        }

        if (lldp_mgmt_conf_set(&lldp_conf[0]) != VTSS_RC_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_conf[PORT_INDEX].lldpmed_optional_tlvs_mask = buf;
        if (lldp_mgmt_conf_set(&lldp_conf[0]) != VTSS_RC_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif
#ifdef VTSS_SW_OPTION_LLDP_MED
int
write_lldpXMedPortConfigNotifEnable(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    static long           buf = 1, old_buf = 1;
    size_t          max_size;
    long            intval;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((long *) var_val);

        if ((table_info.isid != VTSS_ISID_START) || (lldpmed_mgmt_set_notification_ena(buf, PORT_INDEX) != VTSS_RC_OK)) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}


int
write_lldpXMedLocLocationInfo(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    static char     buf[VTSS_APPL_LLDP_CIVIC_CA_VAL_LEN_INCL_TYPE_MAX], old_buf[VTSS_APPL_LLDP_CIVIC_CA_VAL_LEN_INCL_TYPE_MAX];
    size_t          max_size =  VTSS_APPL_LLDP_CIVIC_CA_VAL_LEN_MAX;

    // Get current configuration
    vtss_appl_lldp_common_conf_t  lldp_conf;
    (void) vtss_appl_lldp_common_conf_get(&lldp_conf) ;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedLocLocationInfo: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedLocLocationInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }

    case ACTION: {
        memcpy(buf, var_val, var_val_len);

#if 1
        /* civic location */
        u8 LCI_len = buf[0]; // see figure 10 , TIA1057

        // Make sure that we don't go out of bounds
        if (LCI_len > VTSS_APPL_LLDP_CIVIC_CA_VAL_LEN_INCL_TYPE_MAX || LCI_len > var_val_len) {
            return SNMP_ERROR_PARM;
        }

        lldp_conf.ca_country_code[0] = buf[2]; // See figure 10 , TIA1057
        lldp_conf.ca_country_code[1] = buf[1]; // See figure 10 , TIA1057

        u8 i = 4; // Start at byte 4 (Byte 0 = LCI length, Byte 1 = What, Bytes 2,3 = Country code) - TIA1057 Figure 10
        while (i < (LCI_len - 2)) { // Prevent out of bounds in buf by taking into account that i is incremented twice before used as index in buf
            u8 ca_type = buf[i++];  // Get CAType and let i point to CAlength - TIA1057 Figure 10
            u8 ca_len  = buf[i++];  // Get CAlength and let i point to CAvalue - TIA1057 Figure 10
            (void) vtss_appl_lldp_location_civic_info_set(&lldp_conf.civic, (vtss_appl_lldp_med_catype_t)ca_type, &buf[i]);

            i += ca_len; // Point to next civic information
        }
#else /* TO_DO, we don't support now */
        if (1 == set_loc_location_type) {
            /* coordinate location */
            lldp_conf.coordinate_location.latitude      = ((*var_val & 0x03) << 32) +
                                                          ((*(var_val + 1) & 0xFF) << 24) +
                                                          ((*(var_val + 2) & 0xFF) << 16) +
                                                          ((*(var_val + 3) & 0xFF) << 8) +
                                                          (*(var_val + 4) & 0xFF);
            lldp_conf.coordinate_location.longitude     = ((*(var_val + 5) & 0x03) << 32) +
                                                          ((*(var_val + 6) & 0xFF) << 24) +
                                                          ((*(var_val + 7) & 0xFF) << 16) +
                                                          ((*(var_val + 8) & 0xFF) << 8) +
                                                          (*(var_val + 9) & 0xFF);
            lldp_conf.coordinate_location.altitude_type = (vtss_appl_lldp_med_at_type_t)((*(var_val + 10) & 0xF0) >> 4);
            lldp_conf.coordinate_location.altitude      = ((*(var_val + 11) & 0x3F) << 24) +
                                                          ((*(var_val + 12) & 0xFF) << 16) +
                                                          ((*(var_val + 13) & 0xFF) << 8) +
                                                          (*(var_val + 14) & 0xFF);
            lldp_conf.coordinate_location.datum         = (vtss_appl_lldp_med_datum_t)(*(var_val + 15));
        } else if (2 == set_loc_location_type) {
            /* civic location */
            u8 LCI_len = buf[0]; // see figure 10 , TIA1057

            // Make sure that we don't go out of bounds
            if (LCI_len > VTSS_APPL_LLDP_CIVIC_CA_VAL_LEN_INCL_TYPE_MAX || LCI_len > var_val_len) {
                return SNMP_ERROR_PARM;
            }

            lldp_conf.ca_country_code[0] = buf[2]; // See figure 10 , TIA1057
            lldp_conf.ca_country_code[1] = buf[1]; // See figure 10 , TIA1057

            u8 i = 4; // Start at byte 4 (Byte 0 = LCI length, Byte 1 = What, Bytes 2,3 = Country code) - TIA1057 Figure 10
            while (i < LCI_len) {
                u8 ca_type = buf[i++];  // Get CAType and let i point to CAlength - TIA1057 Figure 10
                u8 ca_len  = buf[i++];  // Get CAlength and let i point to CAvalue - TIA1057 Figure 10
                (void) vtss_appl_lldp_location_civic_info_set(&lldp_conf.civic, (vtss_appl_lldp_med_catype_t)ca_type, &buf[i]);

                i += ca_len; // Point to next civic information
            }

        } else if (3 == set_loc_location_type) {
            /* ecs location */
            if (var_val_len > VTSS_APPL_LLDP_ELIN_VALUE_LEN_MAX) {
                return SNMP_ERROR_PARM;
            }

            int i = 0;
            while (i < var_val_len) {
                lldp_conf.elin_location[i] = *(var_val + i);
                i++;
            }
        }
#endif
        if (vtss_appl_lldp_common_conf_set(&lldp_conf) != VTSS_RC_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }

    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        memcpy(buf, old_buf, sizeof(buf));
        break;
    }
    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        memcpy(old_buf, buf, sizeof(buf));
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif //VTSS_SW_OPTION_LLDP_MED

// LLDP notification Trap - Must be called when ever a entry is modified.
void snmpLLDPXemMIBNotificationChange(int port_index)
{

    // Set the notification OID
    oid  lldp_notifications_oid[] = {1, 0, 8802, 1, 1, 2, 1, 5, 4795, 0, 1};

    snmp_vars_trap_entry_t  trap_entry;

    // Check if notfication for the port the has has changed is enabled
    if (lldp_mgmt_get_notification_ena(port_index, FALSE) == 1) {

        T_DG(TRACE_GRP_SNMP, "Notification for port was enabled");


        // Transmit the SNMP trap
        memset(&trap_entry, 0x0, sizeof(trap_entry));
        trap_entry.oid_len = OID_LENGTH(lldp_notifications_oid);
        memcpy(trap_entry.oid, lldp_notifications_oid, sizeof(oid) * trap_entry.oid_len);
        trap_entry.vars = NULL;
        snmp_send_vars_trap(&trap_entry);
    }
}
