/*

 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include "vtss_os_wrapper_snmp.h"
#include "rfc4133_entity.h"
#include "vtss_snmp_api.h"

#include "topo_api.h"
#include "msg_api.h"
#include "misc_api.h"

/*
 * +++ Start (Internal implementation declarations)
 */
#include "conf_api.h"
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#define MANUFACTURER_NAME   ""
#define ALIAS_NAME          "None"

#if RFC4133_SUPPORTED_ENTITY
struct timeval last_changetime;

#if RFC4133_SUPPORTED_PHYSICAL
#include "snmp_custom_api.h"
uint get_available_entPhysicalTableIndex(int idx_num)
{
    vtss_isid_t usid;
    vtss_isid_t isid;
    isid = topo_usid2isid(idx_num);

    if ( VTSS_ISID_LEGAL(isid) && msg_switch_exists(isid) ) {
        return idx_num;
    } else {
        for (usid = idx_num + 1; usid < VTSS_USID_CNT; usid++) {
            isid = topo_usid2isid(usid);
            if ( VTSS_ISID_LEGAL(isid) && msg_switch_exists(isid) ) {
                return usid;
            }
        }
        return VTSS_USID_END;
    }
}
#endif /*RFC4133_SUPPORTED_PHYSICAL*/
#endif /*RFC4133_SUPPORTED_ENTITY*/
/*
 * --- End (Internal implementation declarations)
 */


#if RFC4133_SUPPORTED_ENTITY
/*
 * entityMIBObjects_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             entityMIBObjects_variables_oid[] = { 1, 3, 6, 1, 2, 1, 47, 1 };

/*
 * variable4 entityMIBObjects_variables:
 *   this variable defines function callbacks and type return information
 *   for the entityMIBObjects mib section
 */

struct variable4 entityMIBObjects_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if RFC4133_SUPPORTED_PHYSICAL
#if 0   /* ENTPHYSICALINDEX is not-accessiable*/
#define ENTPHYSICALINDEX            1
    {ENTPHYSICALINDEX, ASN_INTEGER, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 1}},
#endif
#define ENTPHYSICALDESCR            2
    {ENTPHYSICALDESCR, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 2}},
#define ENTPHYSICALVENDORTYPE       3
    {ENTPHYSICALVENDORTYPE, ASN_OBJECT_ID, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 3}},
#define ENTPHYSICALCONTAINEDIN      4
    {ENTPHYSICALCONTAINEDIN, ASN_INTEGER, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 4}},
#define ENTPHYSICALCLASS            5
    {ENTPHYSICALCLASS, ASN_INTEGER, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 5}},
#define ENTPHYSICALPARENTRELPOS     6
    {ENTPHYSICALPARENTRELPOS, ASN_INTEGER, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 6}},
#define ENTPHYSICALNAME             7
    {ENTPHYSICALNAME, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 7}},
#define ENTPHYSICALHARDWAREREV      8
    {ENTPHYSICALHARDWAREREV, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 8}},
#define ENTPHYSICALFIRMWAREREV      9
    {ENTPHYSICALFIRMWAREREV, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 9}},
#define ENTPHYSICALSOFTWAREREV      10
    {ENTPHYSICALSOFTWAREREV, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 10}},
#define ENTPHYSICALSERIALNUM        11
    {ENTPHYSICALSERIALNUM, ASN_OCTET_STR, RWRITE, var_entPhysicalTable, 4, {1, 1, 1, 11}},
#define ENTPHYSICALMFGNAME          12
    {ENTPHYSICALMFGNAME, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 12}},
#define ENTPHYSICALMODELNAME        13
    {ENTPHYSICALMODELNAME, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 13}},
#define ENTPHYSICALALIAS            14
    {ENTPHYSICALALIAS, ASN_OCTET_STR, RWRITE, var_entPhysicalTable, 4, {1, 1, 1, 14}},
#define ENTPHYSICALASSETID          15
    {ENTPHYSICALASSETID, ASN_OCTET_STR, RWRITE, var_entPhysicalTable, 4, {1, 1, 1, 15}},
#define ENTPHYSICALISFRU            16
    {ENTPHYSICALISFRU, ASN_INTEGER, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 16}},
#define ENTPHYSICALMFGDATE          17
    {ENTPHYSICALMFGDATE, ASN_OCTET_STR, RONLY, var_entPhysicalTable, 4, {1, 1, 1, 17}},
#define ENTPHYSICALURIS             18
    {ENTPHYSICALURIS, ASN_OCTET_STR, RWRITE, var_entPhysicalTable, 4, {1, 1, 1, 18}},
#endif /*RFC4133_SUPPORTED_PHYSICAL*/

#if RFC4133_SUPPORTED_LOGICAL
#define ENTLOGICALINDEX             19
    {ENTLOGICALINDEX, ASN_INTEGER, RONLY, var_entLogicalTable, 4, {2, 1, 1, 1}},
#define ENTLOGICALDESCR             20
    {ENTLOGICALDESCR, ASN_OCTET_STR, RONLY, var_entLogicalTable, 4, {2, 1, 1, 2}},
#define ENTLOGICALTYPE              21
    {ENTLOGICALTYPE, ASN_OBJECT_ID, RONLY, var_entLogicalTable, 4, {2, 1, 1, 3}},
#define ENTLOGICALCOMMUNITY         22
    {ENTLOGICALCOMMUNITY, ASN_OCTET_STR, RONLY, var_entLogicalTable, 4, {2, 1, 1, 4}},
#define ENTLOGICALTADDRESS          23
    {ENTLOGICALTADDRESS, ASN_OCTET_STR, RONLY, var_entLogicalTable, 4, {2, 1, 1, 5}},
#define ENTLOGICALTDOMAIN           24
    {ENTLOGICALTDOMAIN, ASN_OBJECT_ID, RONLY, var_entLogicalTable, 4, {2, 1, 1, 6}},
#define ENTLOGICALCONTEXTENGINEID   25
    {ENTLOGICALCONTEXTENGINEID, ASN_OCTET_STR, RONLY, var_entLogicalTable, 4, {2, 1, 1, 7}},
#define ENTLOGICALCONTEXTNAME       26
    {ENTLOGICALCONTEXTNAME, ASN_OCTET_STR, RONLY, var_entLogicalTable, 4, {2, 1, 1, 8}},
#endif /*RFC4133_SUPPORTED_LOGICAL*/

#if RFC4133_SUPPORTED_MAPPING
#define ENTLPPHYSICALINDEX          27
    {ENTLPPHYSICALINDEX, ASN_INTEGER, RONLY, var_entLPMappingTable, 4, {3, 1, 1, 1}},
#define ENTALIASLOGICALINDEXORZERO  28
    {ENTALIASLOGICALINDEXORZERO, ASN_INTEGER, RONLY, var_entAliasMappingTable, 4, {3, 2, 1, 1}},
#define ENTALIASMAPPINGIDENTIFIER   29
    {ENTALIASMAPPINGIDENTIFIER, ASN_OBJECT_ID, RONLY, var_entAliasMappingTable, 4, {3, 2, 1, 2}},
#define ENTPHYSICALCHILDINDEX       30
    {ENTPHYSICALCHILDINDEX, ASN_INTEGER, RONLY, var_entPhysicalContainsTable, 4, {3, 3, 1, 1}},
#endif /*RFC4133_SUPPORTED_MAPPING*/

#define ENTLASTCHANGETIME           31
    {ENTLASTCHANGETIME, ASN_TIMETICKS, RONLY, var_entityMIBObjects, 2, {4, 1}},

};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the entityMIB module
 */
void init_entityMIB(void)
{
    DEBUGMSGTL(("entityMIB", "Initializing\n"));

    init_entityMIBObjects();
    memset(&last_changetime, 0x0, sizeof(last_changetime) );
#if 0//RFC4133_SUPPORTED_TRAPS
    init_entityMIBTraps();
#endif /*RFC4133_SUPPORTED_TRAPS*/

}

/*
 * Initializes the entityMIBObjects module
 */
void init_entityMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(entityMIBObjects_variables_oid,
                             sizeof(entityMIBObjects_variables_oid) / sizeof(oid),
                             "ENTITY-MIB : entityMIBObjects");

    DEBUGMSGTL(("entityMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("entityMIBObjects", entityMIBObjects_variables, variable4,
                 entityMIBObjects_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_entityMIBObjects():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *var_entityMIBObjects(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */
    static u_long ulong_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTLASTCHANGETIME: {
        ulong_ret = (last_changetime.tv_sec * 100) + (last_changetime.tv_usec / 10000);
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_entityMIBObjects\n",
                    vp->magic));
    }
    return NULL;
}

#if RFC4133_SUPPORTED_PHYSICAL
/*
 * var_entPhysicalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIBObjects above.
 */
u_char *var_entPhysicalTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static u_long   ulong_ret;
    static long     long_ret;
    static char     string[MSG_MAX_VERSION_STRING_LEN];

    uint             table_index;
    int             table_size;
    int             idx_num;

    table_size = VTSS_USID_CNT;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_entPhysicalTableIndex(idx_num);
    if ( !(VTSS_USID_LEGAL(table_index)) || (exact && (table_index != idx_num))  ) {
        return NULL;
    }
    //if (!get_entPhysicalTable_entry(idx_num, &table_entry) )
    //return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if 0   /* ENTPHYSICALINDEX is not-accessiable*/
    case ENTPHYSICALINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif

    case ENTPHYSICALDESCR: {
        char *string_p;

        string_p = system_get_descr();
        *var_len = strlen((char *)string_p);
        return (u_char *)string_p;
    }
    case ENTPHYSICALVENDORTYPE: {

        *var_len = snmp_private_mib_oid_len_get() * sizeof(oid);
        return (u_char *)snmp_private_mib_oid;
    }
    case ENTPHYSICALCONTAINEDIN: {
        ulong_ret = 0;
        return (u_char *) &ulong_ret;
    }
    case ENTPHYSICALCLASS: {
        ulong_ret = 3; /* chassis */
        return (u_char *) &ulong_ret;
    }
    case ENTPHYSICALPARENTRELPOS: {
        long_ret = -1;
        return (u_char *) &long_ret;
    }
    case ENTPHYSICALNAME: {
        system_conf_t system_conf;
        system_get_config(&system_conf);
        strcpy(string, system_conf.sys_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALHARDWAREREV: {
        *var_len = 0;
        return (u_char *) string;
    }
    case ENTPHYSICALFIRMWAREREV: {
        msg_version_string_get(topo_usid2isid(table_index), string);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALSOFTWAREREV: {
        msg_version_string_get(topo_usid2isid(table_index), string);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALSERIALNUM: {
        conf_board_t conf;

        /* get form data */
        conf_mgmt_board_get(&conf);
        snprintf(string, sizeof(string), "System MAC: %02x-%02x-%02x-%02x-%02x-%02x",
                 conf.mac_address.addr[0], conf.mac_address.addr[1], conf.mac_address.addr[2],
                 conf.mac_address.addr[3], conf.mac_address.addr[4], conf.mac_address.addr[5]);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALMFGNAME: {
        strcpy(string, MANUFACTURER_NAME);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALMODELNAME: {
        strcpy(string, misc_board_name());
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case ENTPHYSICALALIAS: {
        strcpy(string, ALIAS_NAME);
        *var_len = strlen(string);
        return (u_char *) string;
    }
#if 0   /* not support now*/
    case ENTPHYSICALASSETID: {
        *write_method = write_entPhysicalAssetID;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case ENTPHYSICALISFRU: {
        long_ret = 1;
        return (u_char *) &long_ret;
    }
    case ENTPHYSICALMFGDATE: {
        /* For example, Tuesday May 26, 1992 at 1:30:15 PM EDT
           string[0]=19;
           string[1]=92;
           string[2]=3;
           string[3]=26;
           string[4]=13;
           string[5]=30;
           string[6]=15;
           string[7]=26;
           string[8]=0;
           string[9]=-4;
           string[10]=0; */
        memset(string, 0x0, sizeof(string));
        *var_len = 8;
        return (u_char *) string;
    }
#if 0   /* not support now*/
    case ENTPHYSICALURIS: {
        *write_method = write_entPhysicalUris;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_entPhysicalTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /*RFC4133_SUPPORTED_PHYSICAL*/

#endif/*RFC4133_SUPPORTED_ENTITY*/

#if RFC4133_SUPPORTED_LOGICAL
/*
 * var_entLogicalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIBObjects above.
 */
u_char *var_entLogicalTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //entLogicalTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_entLogicalTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_entLogicalTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTLOGICALINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALDESCR: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALCOMMUNITY: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALTADDRESS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALTDOMAIN: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALCONTEXTENGINEID: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTLOGICALCONTEXTNAME: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_entLogicalTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /*RFC4133_SUPPORTED_LOGICAL*/


#if RFC4133_SUPPORTED_MAPPING
/*
 * var_entLPMappingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIBObjects above.
 */
u_char         *
var_entLPMappingTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //entLPMappingTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_entLPMappingTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_entLPMappingTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTLPPHYSICALINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_entLPMappingTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_entLPMappingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIB above.
 */
u_char *var_entLPMappingTable(struct variable *vp,
                              oid *name,
                              size_t *length,
                              int exact,
                              size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //entLPMappingTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_entLPMappingTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_entLPMappingTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTLPPHYSICALINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_entLPMappingTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_entAliasMappingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIBObjects above.
 */
u_char *var_entAliasMappingTable(struct variable *vp,
                                 oid *name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //entAliasMappingTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_entAliasMappingTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_entAliasMappingTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTALIASLOGICALINDEXORZERO: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case ENTALIASMAPPINGIDENTIFIER: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_entAliasMappingTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_entPhysicalContainsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_entityMIBObjects above.
 */
u_char *var_entPhysicalContainsTable(struct variable *vp,
                                     oid *name,
                                     size_t *length,
                                     int exact,
                                     size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //entPhysicalContainsTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_entPhysicalContainsTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_entPhysicalContainsTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ENTPHYSICALCHILDINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_entPhysicalContainsTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /*RFC4133_SUPPORTED_MAPPING*/


#if RFC4133_SUPPORTED_PHYSICAL_WRITE
int write_entPhysicalSerialNum(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalSerialNum: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalSerialNum: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to entPhysicalSerialNum: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int write_entPhysicalAlias(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalAlias: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalAlias: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to entPhysicalAlias: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int write_entPhysicalAssetID(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalAssetID: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalAssetID: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to entPhysicalAssetID: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_entPhysicalUris(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalUris: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to entPhysicalUris: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to entPhysicalUris: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /*RFC4133_SUPPORTED_PHYSICAL_WRITE*/

#if RFC4133_SUPPORTED_ENTITY
#if RFC4133_SUPPORTED_TRAPS
static oid              entityMIBTraps_variables_oid[] = { 1, 3, 6, 1, 2, 1, 47, 2, 0, 1};
snmp_vars_trap_entry_t  entityMIBTraps;
#endif /*RFC4133_SUPPORTED_TRAPS*/
mesa_rc entConfigChange(vtss_isid_t isid)
{
    vtss_isid_t     sid;
    struct timespec now_n;

    for (sid = VTSS_ISID_START; sid < VTSS_ISID_END; sid++) {
        if (isid != VTSS_ISID_GLOBAL && isid != sid) {
            continue;
        }

        //James: gettimeofday(&last_changetime, NULL);
        clock_gettime(CLOCK_MONOTONIC, &now_n);
        last_changetime.tv_sec = now_n.tv_sec;
        last_changetime.tv_usec = now_n.tv_nsec / 1000;
#if RFC4133_SUPPORTED_TRAPS
        memset(&entityMIBTraps, 0x0, sizeof(entityMIBTraps));
        strncpy(entityMIBTraps.name, TRAP_NAME_ENTITY_CONF_CHNG, TRAP_MAX_TABLE_NAME_LEN);
        entityMIBTraps.oid_len = OID_LENGTH(entityMIBTraps_variables_oid);
        memcpy(entityMIBTraps.oid, entityMIBTraps_variables_oid, sizeof(oid) * entityMIBTraps.oid_len);
        entityMIBTraps.vars = NULL;

        snmp_send_vars_trap(&entityMIBTraps);
#endif /*RFC4133_SUPPORTED_TRAPS*/
    }

    return VTSS_RC_OK;
}
#endif /*RFC4133_SUPPORTED_ENTITY*/

#if 0
/*
 * entityMIBTraps_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             entityMIBTraps_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 47, 2 };

/*
 * variable4 entityMIBTraps_variables:
 *   this variable defines function callbacks and type return information
 *   for the entityMIBTraps mib section
 */

struct variable4 entityMIBTraps_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

};

/*
 * (L = length of the oidsuffix)
 */

/*
 * FIXME: template declaration for compiler completed
 */
static long     VAR = 0, VALUE = 0;

/*
 * Initializes the entityMIBTraps module
 */
void
init_entityMIBTraps(void)
{
    // Register mibContextTable
    mibContextTable_register(entityMIBTraps_variables_oid,
                             sizeof(entityMIBTraps_variables_oid) / sizeof(oid),
                             "ENTITY-MIB : entityMIBTraps");

    DEBUGMSGTL(("entityMIBTraps", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("entityMIBTraps", entityMIBTraps_variables, variable4,
                 entityMIBTraps_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_entityMIBTraps():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_entityMIBTraps(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_entityMIBTraps\n",
                    vp->magic));
    }
    return NULL;
}
#endif /*if 0*/

