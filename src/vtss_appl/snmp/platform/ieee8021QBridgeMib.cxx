/*
 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.


#include <main.h>
#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "ieee8021QBridgeMib.h"
#include "ucd_snmp_ieee8021QBridgeMib.h"
#include "mibContextTable.h"         // mibContextTable_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#include "vlan_api.h"
#include "mac_api.h"
#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "port_api.h"       // port_count_max()
#include "l2proto_api.h"
#include "misc_api.h"
#if defined(VTSS_SW_OPTION_XXRP)
#include "xxrp_api.h"
#include "vtss_mrp.hxx"
#endif /* defined(VTSS_SW_OPTION_XXRP) */
#include "misc_api.h"

// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

#define MAC_ADDR_LEN                    6
#define IEEE8021QBRIDGECOMPONENTID      1
#define IEEE8021QBRIDGECOMPONENT_CNT    1
/*
 * for object ieee8021QBridgeVlanStatus
 * only Other and permanent are defined, in HP only permanent is required.
 */
enum {
    SNMP_VLAN_STATUS_OTHER      = 1,
    SNMP_VLAN_STATUS_PERMANENT  = 2,
#ifdef VTSS_SW_OPTION_MVRP
    SNMP_VLAN_STATUS_DYNMVRP    = 3
#endif
};

#define IEEE8021QBRIDGEMIB_NOT_SUPPORTED       0


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/
static BOOL IEEE8021QBRIDGE_BridgeTable_entry_get(ieee8021QBridgeTable_entry_t *table_entry)
{
    u8         access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_vid_t vid;
    int        cnt = 0;
    mesa_rc    rc;
#ifdef VTSS_SW_OPTION_MVRP
    BOOL       mvrp_state = FALSE;
#endif /* VTSS_SW_OPTION_MVRP */

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return FALSE;
    }

    for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
        if (VTSS_BF_GET(access_vids, vid)) {
            cnt++;
        }
    }

#ifdef VTSS_SW_OPTION_MVRP
    if ((rc = xxrp_mgmt_global_enabled_get(VTSS_MRP_APPL_MVRP, &mvrp_state)) != VTSS_RC_OK) {
        T_W("Invalid MRP application provided : %s\n", error_txt(rc));
        return FALSE;
    }
#endif /* VTSS_SW_OPTION_MVRP */

    table_entry->ieee8021QBridgeVlanVersionNumber = 2 ;
    table_entry->ieee8021QBridgeMaxSupportedVlans = VLAN_ENTRY_CNT;
    table_entry->ieee8021QBridgeMaxVlanId         = VTSS_APPL_VLAN_ID_MAX;
#ifdef VTSS_SW_OPTION_MVRP
    if (mvrp_state) {
        table_entry->ieee8021QBridgeMvrpEnabledStatus = 1;
    } else {
        table_entry->ieee8021QBridgeMvrpEnabledStatus = 2;
    }
#endif /* VTSS_SW_OPTION_MVRP */
    table_entry->ieee8021QBridgeNumVlans          = cnt;

    return TRUE;
}

static int IEEE8021QBRIDGE_FdbIndex_getnext( u_long *bridge_id, mesa_vid_t *vid)
{
    vtss_appl_vlan_entry_t vlan_mgmt_entry;
    mesa_vid_t             tmp_vid = 0;
    u_long                 tmp_bridge_id = 0;

    if (bridge_id == NULL || vid == NULL) {
        return VTSS_RC_ERROR;
    }

    if ( *bridge_id > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if ( *bridge_id  < IEEE8021QBRIDGECOMPONENTID) {
        tmp_vid = VTSS_VID_NULL;
        tmp_bridge_id = 1;;
    } else {
        tmp_vid = *vid;
        tmp_bridge_id = *bridge_id;
    }
    if (vtss_appl_vlan_get(VTSS_ISID_GLOBAL, tmp_vid, &vlan_mgmt_entry, TRUE, VTSS_APPL_VLAN_USER_ALL) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }
    *vid = vlan_mgmt_entry.vid;
    *bridge_id = tmp_bridge_id;

    return VTSS_RC_OK;
}

static int IEEE8021QBRIDGE_FdbIndex_get( u_long *bridge_id, mesa_vid_t *vid)
{
    mesa_vid_t          tmp_vid = *vid;
    u_long              tmp_bridge_id = *bridge_id;

    if ( *bridge_id > IEEE8021QBRIDGECOMPONENT_CNT || *bridge_id < IEEE8021QBRIDGECOMPONENTID ) {
        return VTSS_RC_ERROR;
    }
    if (*vid == VTSS_VID_NULL) {
        return VTSS_RC_ERROR;
    }
    tmp_bridge_id = *bridge_id;
    tmp_vid = *vid - 1;
    if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext( &tmp_bridge_id, &tmp_vid)) {
        return VTSS_RC_ERROR;
    }

    if (tmp_vid != *vid || tmp_bridge_id != *bridge_id) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static BOOL IEEE8021QBRIDGE_FdbTable_entry_get(ieee8021QBridgeFdbTable_entry_t *table_entry)
{
    switch_iter_t       sit;
    mac_table_stats_t   stats;
    mac_age_conf_t      age_conf;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    table_entry->ieee8021QBridgeFdbDynamicCount = 0;
    while (switch_iter_getnext(&sit)) {
        if (mac_mgmt_table_vlan_stats_get(sit.isid, table_entry->ieee8021QBridgeFdbId, &stats) == VTSS_RC_OK) {
            table_entry->ieee8021QBridgeFdbDynamicCount += stats.learned_total;
        }
    }

    if (mac_mgmt_age_time_get( &age_conf) == VTSS_RC_OK) {
        table_entry->ieee8021QBridgeFdbAgingTime = age_conf.mac_age_time;
    }
    memset(&table_entry->ieee8021QBridgeFdbLearnedEntryDiscards, 0, sizeof(struct counter64));

    return TRUE;
}

void IEEE8021QBRIDGE_TpFdbPort_get_by_port( vtss_isid_t isid, mesa_port_no_t iport, long *qTpFdbPort)
{
    dot1Port_info_t             info;
    BOOL                        found = FALSE;
#ifdef VTSS_SW_OPTION_AGGR
    aggr_mgmt_group_member_t    aggr_members;
    aggr_mgmt_group_no_t        tmp_aggr;

    for (tmp_aggr = AGGR_MGMT_GROUP_NO_START; tmp_aggr < AGGR_MGMT_GROUP_NO_END_; tmp_aggr++) {
        if ((aggr_mgmt_port_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_RC_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_RC_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {

            continue;
        }
        if (aggr_members.entry.member[iport] == TRUE) {
            found = TRUE;
            break;
        }
    }
#endif /* VTSS_SW_OPTION_AGGR */


    info.isid = isid;
    if ( FALSE == found ) {
        info.if_id = iport;
        info.type = DOT1PORT_TYPE_PORT;
#ifdef VTSS_SW_OPTION_AGGR
    } else {
        info.if_id = tmp_aggr;
        info.type = AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr) ? DOT1PORT_TYPE_GLAG : DOT1PORT_TYPE_LLAG;
#endif /* VTSS_SW_OPTION_AGGR */
    }

    if (FALSE == dot1Port_get_by_interface(&info)) {
        ;
    }

    *qTpFdbPort = info.dot1port;
}

//  Rev 19577
static BOOL IEEE8021QBRIDGE_TpFdbTable_entry_get( mac_mgmt_addr_type_t *mac_type, mesa_vid_mac_t  *vid_mac_in, ieee8021QBridgeTpFdbTable_entry_t *table_entry, BOOL getnext)
{
    mac_mgmt_table_stack_t  mac_entry;
    mesa_mac_table_entry_t  isid_mac_entry;
    mesa_port_no_t port_no = 0;
    vtss_isid_t  isid = 0, mac_isid;
    int learned = 0;

    if (mac_mgmt_stack_get_next(vid_mac_in, &mac_entry, mac_type, getnext) == VTSS_RC_OK) {

        table_entry->ieee8021QBridgeFdbComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeFdbId = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(mesa_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }

            for (port_no = VTSS_PORT_NO_START; port_no < port_count_max(); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    learned = 1;
                    mac_isid = isid;
                    IEEE8021QBRIDGE_TpFdbPort_get_by_port(mac_isid, port_no, (long *)&table_entry->ieee8021QBridgeTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->ieee8021QBridgeTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->ieee8021QBridgeTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->ieee8021QBridgeTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->ieee8021QBridgeTpFdbStatus = 1;    /* other   */
        }
        return TRUE;
    } else {
        T_D("no entry");
        return FALSE;
    }
}

static void IEEE8021QBRIDGE_PortList_BF_size_get(u_long *port_count_p)
{
    dot1Port_info_t table_info;
    switch_iter_t   sit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        table_info.isid = sit.isid;
        table_info.if_id = VTSS_PORT_NO_START + port_count_max() - 1;
        table_info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&table_info);
    }

    *port_count_p = VTSS_PORTLIST_BF_SIZE(table_info.dot1port);
}

static int IEEE8021QBRIDGE_TpGroupTable_entry_get(mac_mgmt_addr_type_t *mac_type, mesa_vid_mac_t  *vid_mac_in,
                                                  ieee8021QBridgeTpGroupTable_entry_t *table_entry, BOOL getnext)
{
    mac_mgmt_table_stack_t  mac_entry;
    mesa_mac_table_entry_t  isid_mac_entry;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    mesa_port_no_t          port_no;

    if (mac_mgmt_stack_get_next(vid_mac_in, &mac_entry, mac_type, getnext) == VTSS_RC_OK) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =  IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeTpGroupAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeTpGroupAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(mesa_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            info.isid = isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;

            for (port_no = VTSS_PORT_NO_START; port_no < port_count_max(); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeTpGroupEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeTpGroupEgressPorts, dot1port_start + port_no, 0);
                }

            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get((u_long *)&table_entry->ieee8021QBridgeTpGroupEgressPorts_len);
        table_entry->ieee8021QBridgeTpGroupLearnt_len = table_entry->ieee8021QBridgeTpGroupEgressPorts_len;
        memset(table_entry->ieee8021QBridgeTpGroupLearnt, 0, table_entry->ieee8021QBridgeTpGroupEgressPorts_len);
    } else {
        T_D("no entry");
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_StaticUnicastTableEntry_get(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry, BOOL getnext)
{
    mesa_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mesa_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    mesa_port_no_t          port_no;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->ieee8021QBridgeStaticUnicastVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->ieee8021QBridgeStaticUnicastAddress, 6);

    /* Search only for UC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if ( mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_RC_OK ) {

        table_entry->ieee8021QBridgeStaticUnicastComponentId = 1;
        table_entry->ieee8021QBridgeStaticUnicastVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeStaticUnicastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeStaticUnicastAddress_len = 6;
        table_entry->ieee8021QBridgeStaticUnicastReceivePort = 0;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(mesa_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }
            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            info.isid = isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            for (port_no = VTSS_PORT_NO_START; port_no < port_count_max(); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts, dot1port_start + port_no, 0);
                }
            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts_len);
        table_entry->ieee8021QBridgeStaticUnicastRowStatus = 1;
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
IEEE8021QBRIDGE_StaticMulticastTableEntry_get(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry, BOOL getnext)
{
    mesa_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mesa_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    mesa_port_no_t          port_no;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->ieee8021QBridgeVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->ieee8021QBridgeStaticMulticastAddress, 6);

    /* Search only for MC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if ( mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_RC_OK ) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeStaticMulticastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeStaticMulticastAddress_len = 6;
        table_entry->ieee8021QBridgeStaticMulticastReceivePort = 0;


        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(mesa_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }
            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            info.isid = isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            for (port_no = VTSS_PORT_NO_START; port_no < port_count_max(); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts, dot1port_start + port_no, 0);
                }
            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts_len);
        table_entry->ieee8021QBridgeStaticMulticastRowStatus = 3;    /* permanent */
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
IEEE8021QBRIDGE_VlanCurrentTableEntry_get(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry, BOOL getnext)
{
    vtss_appl_vlan_entry_t     vlan_mgmt_entry;
    vtss_appl_vlan_port_conf_t port_conf;
    dot1Port_info_t            info;
    vtss_common_port_t         dot1port_start;
    port_iter_t                pit;
    switch_iter_t              sit;
    u8                         access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc                    rc;

    vlan_mgmt_entry.vid = table_entry->ieee8021QBridgeVlanIndex;

    if ((rc = vtss_appl_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, getnext, VTSS_APPL_VLAN_USER_ALL)) != VTSS_RC_OK) {
        return rc;
    }

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return rc;
    }

    table_entry->ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
    table_entry->ieee8021QBridgeVlanIndex = vlan_mgmt_entry.vid;
    table_entry->ieee8021QBridgeVlanFdbId = vlan_mgmt_entry.vid;
    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (!VTSS_BF_GET(access_vids, vlan_mgmt_entry.vid)) {
            continue;
        }

        if ((rc = vtss_appl_vlan_get(sit.isid, vlan_mgmt_entry.vid, &vlan_mgmt_entry, FALSE, VTSS_APPL_VLAN_USER_STATIC)) != VTSS_RC_OK) {
            return rc;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (vlan_mgmt_entry.ports[pit.iport]) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentEgressPorts, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentEgressPorts, dot1port_start + pit.iport, 0);
            }

            if (vlan_mgmt_port_conf_get(sit.isid, pit.iport, &port_conf, VTSS_APPL_VLAN_USER_ALL, TRUE) == VTSS_RC_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentUntaggedPorts, dot1port_start + pit.iport, vlan_mgmt_vid_gets_tagged(&port_conf.hybrid, vlan_mgmt_entry.vid) ? 0 : 1);
            }
        }
    }
    IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeVlanCurrentEgressPorts_len);
    table_entry->ieee8021QBridgeVlanCurrentUntaggedPorts_len = table_entry->ieee8021QBridgeVlanCurrentEgressPorts_len;
    table_entry->ieee8021QBridgeVlanStatus = 2; /* permenent */

    return VTSS_RC_OK;
}

static int IEEE8021QBRIDGE_VlanStaticTableEntry_get(ieee8021QBridgeVlanStaticTable_entry_t *table_entry, BOOL getnext)
{
    vtss_appl_vlan_entry_t     vlan_mgmt_entry;
    char                       vlan_name[VTSS_APPL_VLAN_NAME_MAX_LEN];
    vtss_appl_vlan_port_conf_t port_conf;
    dot1Port_info_t            info;
    vtss_common_port_t         dot1port_start;
    port_iter_t                pit;
    switch_iter_t              sit;
    u8                         access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc                    rc;

    vlan_mgmt_entry.vid = table_entry->ieee8021QBridgeVlanStaticVlanIndex;

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return rc;
    }

    if (getnext) {
        BOOL       found = FALSE;
        mesa_vid_t vid;

        for (vid = vlan_mgmt_entry.vid + 1; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
            if (VTSS_BF_GET(access_vids, vid)) {
                found = TRUE;
                vlan_mgmt_entry.vid = vid;
                break;
            }
        }

        if (!found) {
            return VTSS_RC_ERROR;
        }
    } else {
        if (!VTSS_BF_GET(access_vids, vlan_mgmt_entry.vid)) {
            return VTSS_RC_ERROR;
        }
    }

    if (vtss_appl_vlan_name_get(vlan_mgmt_entry.vid, vlan_name, NULL) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memset(table_entry, 0, sizeof(ieee8021QBridgeVlanStaticTable_entry_t));
    table_entry->ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
    table_entry->ieee8021QBridgeVlanStaticVlanIndex = vlan_mgmt_entry.vid;
    strcpy(table_entry->ieee8021QBridgeVlanStaticName, vlan_name);
    table_entry->ieee8021QBridgeVlanStaticName_len = strlen(vlan_name);

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vtss_appl_vlan_get(sit.isid, vlan_mgmt_entry.vid, &vlan_mgmt_entry, FALSE, VTSS_APPL_VLAN_USER_STATIC) != VTSS_RC_OK) {
            T_E("vid = %d not found", vlan_mgmt_entry.vid);
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (vlan_mgmt_entry.ports[pit.iport]) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport, 0);
            }

            if (vlan_mgmt_port_conf_get(sit.isid, pit.iport, &port_conf, VTSS_APPL_VLAN_USER_STATIC, TRUE) == VTSS_RC_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts, dot1port_start + pit.iport, vlan_mgmt_vid_gets_tagged(&port_conf.hybrid, vlan_mgmt_entry.vid) ? 0 : 1);
            }
        }
    }
    IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeVlanStaticEgressPorts_len);
    table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len = table_entry->ieee8021QBridgeVlanStaticEgressPorts_len;
    table_entry->ieee8021QBridgeVlanStaticRowStatus = SNMP_ROW_ACTIVE;

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_PortVlanTableEntry_get(dot1Port_info_t   *info, ieee8021QBridgePortVlanTable_entry_t *table_entry)
{
    vtss_appl_vlan_port_conf_t port_conf;
    if (vlan_mgmt_port_conf_get(info->isid, info->if_id, &port_conf, VTSS_APPL_VLAN_USER_STATIC, TRUE) == VTSS_RC_OK) {
        table_entry->ieee8021BridgeBasePortComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021BridgeBasePort = info->dot1port;
        table_entry->ieee8021QBridgePvid = port_conf.hybrid.pvid;
        if (port_conf.hybrid.frame_type == MESA_VLAN_FRAME_ALL) {
            table_entry->ieee8021QBridgePortAcceptableFrameTypes = 1;   /* admitAll */
        } else {
            table_entry->ieee8021QBridgePortAcceptableFrameTypes = 2;   /* adminOnlyVlanTagged  */
        }
        if (port_conf.hybrid.ingress_filter) {
            table_entry->ieee8021QBridgePortIngressFiltering = 1;    /* TRUE  */
        } else {
            table_entry->ieee8021QBridgePortIngressFiltering = 2;    /* FALSE */
        }
    } else {
        return 1;
    }

#ifdef VTSS_SW_OPTION_MVRP
    BOOL state = FALSE;
    if (xxrp_mgmt_enabled_get(info->isid, info->if_id, VTSS_MRP_APPL_MVRP,
                              &state) == VTSS_RC_OK) {
        if (state) {
            table_entry->ieee8021QBridgePortMvrpEnabledStatus = 1; /* MVRP enabled */
        } else {
            table_entry->ieee8021QBridgePortMvrpEnabledStatus = 2; /* MVRP disabled */
        }
    } else {
        return 1;
    }

    vtss::mrp::MrpApplPortStat stat;
    if (vtss::mrp::mgmt_stat_port_get(info->isid, info->if_id, VTSS_APPL_MRP_APPL_MVRP,
                                      stat) == VTSS_RC_OK) {
        vtss_snmp_u64_to_counter64(&table_entry->ieee8021QBridgePortMvrpFailedRegistrations, stat.failedRegistrations);
        memcpy(table_entry->ieee8021QBridgePortMvrpLastPduOrigin,
               stat.lastPduOrigin,
               sizeof(table_entry->ieee8021QBridgePortMvrpLastPduOrigin));
    } else {
        return 1;
    }

    /* The restricted role is not applicable in our implementation.
       It acts as if it is always enabled, however this is not something
       we can configure, so set the control to always true. */
    table_entry->ieee8021QBridgePortRestrictedVlanRegistration = 1;
#endif /* VTSS_SW_OPTION_MVRP */
    return 0;
}


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-Q-BRIDGE-MIB:ieee8021QBridgeMib.
  **/
void
ieee8021QBridgeMib_init(void)
{
    oid             ieee8021QBridgeMib_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 4 };

    T_D("enter");

    // Register mibContextTable
    mibContextTable_register(ieee8021QBridgeMib_oid,
                             sizeof(ieee8021QBridgeMib_oid) / sizeof(oid),
                             "IEEE8021-Q-BRIDGE-MIB : ieee8021QBridgeMib");

    ucd_snmp_init_ieee8021QBridgeMib();

    T_D("exit");
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get scalar data of ieee8021QBridgeVlanScalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanScalar_get(ieee8021QBridgeVlan_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set scalar data of ieee8021QBridgeVlanScalar
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanScalar_set(ieee8021QBridgeVlan_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_getfirst(ieee8021QBridgeTable_entry_t *
                                   table_entry)
{
    T_D("enter");
    table_entry->ieee8021QBridgeComponentId = IEEE8021QBRIDGECOMPONENTID;
    if (!IEEE8021QBRIDGE_BridgeTable_entry_get(table_entry)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_get(ieee8021QBridgeTable_entry_t *table_entry,
                              int getnext)
{
    ieee8021QBridgeTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));

    if (getnext) {
        if (table_entry->ieee8021QBridgeComponentId >= IEEE8021QBRIDGECOMPONENT_CNT) {
            return -1;
        }
        buf.ieee8021QBridgeComponentId = IEEE8021QBRIDGECOMPONENTID;
    } else {
        if (table_entry->ieee8021QBridgeComponentId != IEEE8021QBRIDGECOMPONENTID) {
            return -1;
        }
        buf.ieee8021QBridgeComponentId = table_entry->ieee8021QBridgeComponentId;
    }

    if (!IEEE8021QBRIDGE_BridgeTable_entry_get(&buf)) {
        return -1;
    }

    memcpy(table_entry, &buf, sizeof(ieee8021QBridgeTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_set(ieee8021QBridgeTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_getfirst
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_get
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_set
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/**
  * \brief Get first table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_getfirst(ieee8021QBridgeFdbTable_entry_t *
                                      table_entry)
{
    ieee8021QBridgeFdbTable_entry_t buf;
    u_long              tmp_bridge_id = 0;
    mesa_vid_t          tmp_vid = VTSS_VID_NULL;

    T_D("enter");

    if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext(&tmp_bridge_id, &tmp_vid)) {
        return -1;
    }

    buf.ieee8021QBridgeFdbComponentId   = tmp_bridge_id;
    buf.ieee8021QBridgeFdbId            = tmp_vid;
    (void) IEEE8021QBRIDGE_FdbTable_entry_get(&buf);
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_get(ieee8021QBridgeFdbTable_entry_t *
                                 table_entry, int getnext)
{
    ieee8021QBridgeFdbTable_entry_t buf;
    u_long              tmp_bridge_id = table_entry->ieee8021QBridgeFdbComponentId;
    mesa_vid_t          tmp_vid = table_entry->ieee8021QBridgeFdbId ;

    T_D("enter");
    if (TRUE == getnext) {
        if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext(&tmp_bridge_id, &tmp_vid)) {
            return -1;
        }

    } else {
        if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_get(&tmp_bridge_id, &tmp_vid)) {
            return -1;
        }
    }

    buf.ieee8021QBridgeFdbComponentId   = tmp_bridge_id;
    buf.ieee8021QBridgeFdbId            = tmp_vid;
    (void) IEEE8021QBRIDGE_FdbTable_entry_get(&buf);
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_set(ieee8021QBridgeFdbTable_entry_t *
                                 table_entry)
{
    mac_age_conf_t age_conf;

    T_D("enter");

    if ( VTSS_RC_OK != mac_mgmt_age_time_get(&age_conf) ) {
        return -1;
    }
    T_D("set mac_age_time to %ld", table_entry->ieee8021QBridgeFdbAgingTime);
    age_conf.mac_age_time = table_entry->ieee8021QBridgeFdbAgingTime;

    T_D("apply mac_mgmt_age_time_set");
    if ( VTSS_RC_OK != mac_mgmt_age_time_set(&age_conf) ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeTpFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpFdbTableEntry_getfirst(ieee8021QBridgeTpFdbTable_entry_t *
                                        table_entry)
{
    mesa_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    memset(&vid_mac, 0, sizeof(vid_mac));
    if ( FALSE == IEEE8021QBRIDGE_TpFdbTable_entry_get(&mac_type, &vid_mac, table_entry, TRUE)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTpFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpFdbTableEntry_get(ieee8021QBridgeTpFdbTable_entry_t *
                                   table_entry, int getnext)
{
    mesa_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if (table_entry->ieee8021QBridgeFdbComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeFdbComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            vid_mac.vid = 0;
            memset(vid_mac.mac.addr, 0, 6);
        }
    } else {
        vid_mac.vid = table_entry->ieee8021QBridgeFdbId;
        memcpy(vid_mac.mac.addr, table_entry->ieee8021QBridgeTpFdbAddress, 6);
    }

    if ( FALSE == IEEE8021QBRIDGE_TpFdbTable_entry_get(&mac_type, &vid_mac, table_entry, getnext)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeTpGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpGroupTableEntry_getfirst
(ieee8021QBridgeTpGroupTable_entry_t *table_entry)
{
    mesa_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 1;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    memset(&vid_mac, 0, sizeof(vid_mac));
    if (IEEE8021QBRIDGE_TpGroupTable_entry_get(&mac_type, &vid_mac, table_entry, TRUE) != VTSS_RC_OK) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTpGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpGroupTableEntry_get(ieee8021QBridgeTpGroupTable_entry_t *
                                     table_entry, int getnext)
{
    mesa_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.only_in_conf = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 1;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            vid_mac.vid = 0;
            memset(vid_mac.mac.addr, 0, 6);
        }
    } else {
        vid_mac.vid = table_entry->ieee8021QBridgeVlanIndex;
        memcpy(vid_mac.mac.addr, table_entry->ieee8021QBridgeTpGroupAddress, 6);
    }

    if (IEEE8021QBRIDGE_TpGroupTable_entry_get(&mac_type, &vid_mac, table_entry, getnext) != VTSS_RC_OK) {
        return -1;
    }

    T_D("exit");
    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_getfirst
(ieee8021QBridgeForwardAllTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_get
(ieee8021QBridgeForwardAllTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_set
(ieee8021QBridgeForwardAllTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_getfirst
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_get
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_set
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/**
  * \brief Get first table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_getfirst
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry)
{
    ieee8021QBridgeStaticUnicastTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (IEEE8021QBRIDGE_StaticUnicastTableEntry_get(&buf, TRUE)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_get
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeStaticUnicastTable_entry_t buf;

    T_D("%s from initial key: %lu.%lu.\"%s\".%lu", getnext ? "GET-NEXT" : "GET",
        table_entry->ieee8021QBridgeStaticUnicastComponentId,
        table_entry->ieee8021QBridgeStaticUnicastVlanIndex,
        misc_mac2str((uchar *)table_entry->ieee8021QBridgeStaticUnicastAddress),
        table_entry->ieee8021QBridgeStaticUnicastReceivePort
       );

    if (table_entry->ieee8021QBridgeStaticUnicastComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021QBridgeStaticUnicastComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeStaticUnicastComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeStaticUnicastReceivePort = 0;
            buf.ieee8021QBridgeStaticUnicastVlanIndex = 0;
            memset(buf.ieee8021QBridgeStaticUnicastAddress, 0, 6);
        }
    } else if (table_entry->ieee8021QBridgeStaticUnicastReceivePort != 0 && FALSE == getnext ) {
        return -1;
    } else {
        buf.ieee8021QBridgeStaticUnicastComponentId = table_entry->ieee8021QBridgeStaticUnicastComponentId;
        buf.ieee8021QBridgeStaticUnicastReceivePort = 0;
        buf.ieee8021QBridgeStaticUnicastVlanIndex = table_entry->ieee8021QBridgeStaticUnicastVlanIndex;
        memcpy(buf.ieee8021QBridgeStaticUnicastAddress, table_entry->ieee8021QBridgeStaticUnicastAddress, 6);
    }

    T_D("the operational key: %lu.%lu.\"%s\".%lu",
        buf.ieee8021QBridgeStaticUnicastComponentId,
        buf.ieee8021QBridgeStaticUnicastVlanIndex,
        misc_mac2str((uchar *)buf.ieee8021QBridgeStaticUnicastAddress),
        buf.ieee8021QBridgeStaticUnicastReceivePort
       );

    if ( IEEE8021QBRIDGE_StaticUnicastTableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_set
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_getfirst
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry)
{
    ieee8021QBridgeStaticMulticastTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (IEEE8021QBRIDGE_StaticMulticastTableEntry_get(&buf, TRUE)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_get
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry,
 int getnext)
{
    ieee8021QBridgeStaticMulticastTable_entry_t buf;

    T_D("enter");

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeStaticMulticastReceivePort = 0;
            buf.ieee8021QBridgeVlanIndex = 0;
            memset(buf.ieee8021QBridgeStaticMulticastAddress, 0, 6);
        }
    } else if (table_entry->ieee8021QBridgeStaticMulticastReceivePort != 0 && FALSE == getnext ) {
        return -1;
    } else {
        buf.ieee8021QBridgeVlanCurrentComponentId = table_entry->ieee8021QBridgeVlanCurrentComponentId;
        buf.ieee8021QBridgeStaticMulticastReceivePort = table_entry->ieee8021QBridgeStaticMulticastReceivePort;
        buf.ieee8021QBridgeVlanIndex = table_entry->ieee8021QBridgeVlanIndex;
        memcpy(buf.ieee8021QBridgeStaticMulticastAddress, table_entry->ieee8021QBridgeStaticMulticastAddress, 6);
    }

    if (IEEE8021QBRIDGE_StaticMulticastTableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_set
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry)
{
    T_D("enter");

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeVlanCurrentTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanCurrentTableEntry_getfirst
(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry)
{
    ieee8021QBridgeVlanCurrentTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (VTSS_RC_OK != IEEE8021QBRIDGE_VlanCurrentTableEntry_get(&buf, TRUE)) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeVlanCurrentTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanCurrentTableEntry_get
(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeVlanCurrentTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));

    if (table_entry->ieee8021QBridgeVlanTimeMark > 0 || table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return VTSS_RC_ERROR;
        } else {
            buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeVlanIndex = 0;
        }
    } else {
        buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
        buf.ieee8021QBridgeVlanIndex = table_entry->ieee8021QBridgeVlanIndex;
    }

    if (IEEE8021QBRIDGE_VlanCurrentTableEntry_get(&buf, getnext) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_getfirst
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry)
{
    ieee8021QBridgeVlanStaticTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    buf.ieee8021QBridgeVlanStaticVlanIndex = 0;
    if (IEEE8021QBRIDGE_VlanStaticTableEntry_get(&buf, TRUE) != VTSS_RC_OK) {
        return -1;
    }

    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_get
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeVlanStaticTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if ( table_entry->ieee8021QBridgeVlanStaticComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanStaticComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeVlanStaticVlanIndex = 0;
        }
    } else {
        buf.ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
        buf.ieee8021QBridgeVlanStaticVlanIndex = table_entry->ieee8021QBridgeVlanStaticVlanIndex;
    }

    if (IEEE8021QBRIDGE_VlanStaticTableEntry_get(&buf, getnext) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_set
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry)
{
    vtss_appl_vlan_entry_t vlan_entry;
    char                   vlan_name[VTSS_APPL_VLAN_NAME_MAX_LEN];
    u_long                 bf_size;
    dot1Port_info_t        info;
    vtss_common_port_t     dot1port_start;
    port_iter_t            pit;
    switch_iter_t          sit;
    mesa_rc                rc;

    T_D("enter");

    if (table_entry->ieee8021QBridgeVlanStaticComponentId > IEEE8021QBRIDGECOMPONENT_CNT ||
        table_entry->ieee8021QBridgeVlanStaticComponentId < IEEE8021QBRIDGECOMPONENTID ) {
        return -1;
    }

    IEEE8021QBRIDGE_PortList_BF_size_get(&bf_size);
    if (table_entry->ieee8021QBridgeVlanStaticEgressPorts_len > bf_size) {
        return -1;
    }

    vlan_entry.vid = table_entry->ieee8021QBridgeVlanStaticVlanIndex;

    if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 4) {

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            memset(vlan_entry.ports, 0, sizeof(vlan_entry.ports));
            if (vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VTSS_APPL_VLAN_USER_STATIC) != VTSS_RC_OK) {
                return -1;
            }
        }
    } else if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 6) {
        vlan_name[0] = '\0';
        (void)vlan_mgmt_vlan_del(VTSS_ISID_GLOBAL, table_entry->ieee8021QBridgeVlanStaticVlanIndex, VTSS_APPL_VLAN_USER_STATIC);
        if (VTSS_RC_OK != (rc = vtss_appl_vlan_name_set(vlan_entry.vid, vlan_name))) {
            return -1;
        }
    } else if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 1) {
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            info.isid = sit.isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void)dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (VTSS_PORTLIST_BF_GET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport)) {
                    vlan_entry.ports[pit.iport] = TRUE;
                } else {
                    vlan_entry.ports[pit.iport] = FALSE;
                }
            }
            (void)vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VTSS_APPL_VLAN_USER_STATIC);

            strncpy(vlan_name, table_entry->ieee8021QBridgeVlanStaticName, sizeof(vlan_name) - 1);
            vlan_name[MIN(table_entry->ieee8021QBridgeVlanStaticName_len, sizeof(vlan_name) - 1)] = '\0';
            if (VTSS_RC_OK != (rc = vtss_appl_vlan_name_set(vlan_entry.vid, vlan_name))) {
                return -1;
            }
        }
    }

    T_D("exit");
    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeNextFreeLocalVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeNextFreeLocalVlanTableEntry_getfirst
(ieee8021QBridgeNextFreeLocalVlanTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeNextFreeLocalVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeNextFreeLocalVlanTableEntry_get
(ieee8021QBridgeNextFreeLocalVlanTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

// Getfirst table entry of ieee8021QBridgePortVlanTableEntry
// Return 0 if access success, non-zero value otherwise.
int
ieee8021QBridgePortVlanTableEntry_getfirst
(ieee8021QBridgePortVlanTable_entry_t *table_entry)
{
    dot1Port_info_t   info;
    ieee8021QBridgePortVlanTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));
    info.dot1port = DOT1PORT_NO_NONE;
    (void) dot1Port_get_next(&info);
    if (IEEE8021QBRIDGE_PortVlanTableEntry_get(&info, &buf) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));
    return VTSS_RC_OK;

}

// Get or Getnext table entry of ieee8021QBridgePortVlanTableEntry
// Return 0 if access success, non-zero value otherwise.
int
ieee8021QBridgePortVlanTableEntry_get(ieee8021QBridgePortVlanTable_entry_t
                                      * table_entry, int getnext)
{
    dot1Port_info_t   info;
    ieee8021QBridgePortVlanTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));
    if ( table_entry->ieee8021BridgeBasePortComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021BridgeBasePortComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return VTSS_RC_ERROR;
        } else {
            info.dot1port = 0;
        }
    } else {
        info.dot1port = table_entry->ieee8021BridgeBasePort;
    }

    if (getnext) {
        if (FALSE == dot1Port_get_next(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if (FALSE == dot1Port_get(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    }

    if (IEEE8021QBRIDGE_PortVlanTableEntry_get(&info, &buf) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));
    return VTSS_RC_OK;
}

/**
  * \brief Set table entry of ieee8021QBridgePortVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanTableEntry_set(ieee8021QBridgePortVlanTable_entry_t
                                      * table_entry)
{
    vtss_appl_vlan_port_conf_t port_conf;
    dot1Port_info_t            info;
    mesa_rc                    rc;

    T_D("enter");
    info.dot1port = table_entry->ieee8021BridgeBasePort;

    if (FALSE == dot1Port_get(&info) || info.type != DOT1PORT_TYPE_PORT ) {
        return VTSS_RC_ERROR;
    }

    (void)vlan_mgmt_port_conf_get(info.isid, info.if_id, &port_conf, VTSS_APPL_VLAN_USER_STATIC, FALSE);

    port_conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID;
    port_conf.hybrid.pvid           = table_entry->ieee8021QBridgePvid;
    port_conf.hybrid.untagged_vid   = table_entry->ieee8021QBridgePvid;
    port_conf.hybrid.frame_type     = (table_entry->ieee8021QBridgePortAcceptableFrameTypes == 1) ? MESA_VLAN_FRAME_ALL : MESA_VLAN_FRAME_TAGGED;
    port_conf.hybrid.ingress_filter = (table_entry->ieee8021QBridgePortIngressFiltering == 1) ? TRUE : FALSE;
    port_conf.hybrid.tx_tag_type    = VTSS_APPL_VLAN_TX_TAG_TYPE_UNTAG_THIS;
    if ((rc = vlan_mgmt_port_conf_set(info.isid, info.if_id, &port_conf, VTSS_APPL_VLAN_USER_STATIC)) != VTSS_RC_OK) {
        T_E("vlan_mgmt_port_conf_set(%u:%u failed (%s)", info.isid, (u32)info.if_id, error_txt(rc));
    }

    T_D("exit");
    return rc;
}

/**
  * \brief Get first table entry of ieee8021QBridgePortVlanStatisticsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanStatisticsTableEntry_getfirst
(ieee8021QBridgePortVlanStatisticsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgePortVlanStatisticsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanStatisticsTableEntry_get
(ieee8021QBridgePortVlanStatisticsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_getfirst
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_get
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_set
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_getfirst
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_get
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_getfirst
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_get
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_set
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_getfirst
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_get
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_set
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
