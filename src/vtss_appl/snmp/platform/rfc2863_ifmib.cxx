/*
 Copyright (c) 2006-2021 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "rfc1213_mib2.h"
#include "ucd_snmp_rfc1213_mib2.h"
#include "misc_api.h"
#include "ifIndex_api.h"
#include "rfc2863_ifmib.h"
#include "ip_api.h"
#include "icli_porting_util.h"


#include "msg_api.h"
#include "sysutil_api.h"

#ifdef VTSS_SW_OPTION_LACP
#include "lacp_api.h"
#endif                          /* VTSS_SW_OPTION_LACP */

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
/*
 * +++ Start (Internal implementation declarations)
 */
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#if RFC2863_SUPPORTED_IFMIB
/* ifmib ----------------------------------------------------------*/
typedef struct {
    u_long           ifIndex;
    u_char           ifName[256];
    u_long           ifInMulticastPkts;
    u_long           ifInBroadcastPkts;
    u_long           ifOutMulticastPkts;
    u_long           ifOutBroadcastPkts;
    struct counter64 ifHCInOctets;
    struct counter64 ifHCInUcastPkts;
    struct counter64 ifHCInMulticastPkts;
    struct counter64 ifHCInBroadcastPkts;
    struct counter64 ifHCOutOctets;
    struct counter64 ifHCOutUcastPkts;
    struct counter64 ifHCOutMulticastPkts;
    struct counter64 ifHCOutBroadcastPkts;
    u_long           ifLinkUpDownTrapEnable;
    u_long           ifHighSpeed;
    /* Not supported in E-StaX34 project
    long             ifPromiscuousMode;
    long             ifConnectorPresent; */
    u_char           ifAlias[64];
    u_long           ifCounterDiscontinuityTime;
    struct counter64 ifHCInPkts; /* internal used */
    struct counter64 ifHCOutPkts; /* internal used */
} ifXTable_entry_t;

/*
 * The entry data structure for ifStackTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ifStackHigherLayer;
    long            ifStackLowerLayer;

    /*
     * Entry columns
     */
    long            ifStackStatus;
} ifStackTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
} ifStackTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ifStackTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ifStackTable_return_t ifStackTable_global_ret;   /* static variables for retuning */



static struct timeval ifTable_LastChange;
static ifXTable_entry_t ip_ifXTable_entry;
static BOOL register_flag = FALSE;

static BOOL update_ifXTable_entry(vtss_isid_t isid, mesa_port_no_t port_idx, ifXTable_entry_t *table_entry_p)
{
    snmp_port_conf_t         snmp_port_conf;
    vtss_appl_port_conf_t    port_conf;
    vtss_appl_port_status_t  port_status;
    mesa_port_counters_t     counters;
    vtss_ifindex_t ifindex;

    if (snmp_mgmt_snmp_port_conf_get(isid, port_idx, &snmp_port_conf) != VTSS_RC_OK) {
        return FALSE;
    };
    if (vtss_ifindex_from_port(isid, port_idx, &ifindex) != VTSS_RC_OK) {
        return FALSE;
    };

    if (vtss_appl_port_conf_get(ifindex, &port_conf) != VTSS_RC_OK) {
        return FALSE;
    }
    if (vtss_appl_port_status_get(ifindex, &port_status) != VTSS_RC_OK) {
        return FALSE;
    }
    if (vtss_appl_port_statistics_get(ifindex, &counters) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry_p->ifInMulticastPkts  += counters.if_group.ifInMulticastPkts;
    table_entry_p->ifInBroadcastPkts  += counters.if_group.ifInBroadcastPkts;
    table_entry_p->ifOutMulticastPkts += counters.if_group.ifOutMulticastPkts;
    table_entry_p->ifOutBroadcastPkts += counters.if_group.ifOutBroadcastPkts;
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCInOctets,         counters.if_group.ifInOctets);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCInUcastPkts,      counters.if_group.ifInUcastPkts);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCInMulticastPkts,  counters.if_group.ifInMulticastPkts);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCInBroadcastPkts,  counters.if_group.ifInBroadcastPkts);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCOutOctets,        counters.if_group.ifOutOctets);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCOutUcastPkts,     counters.if_group.ifOutUcastPkts);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCOutMulticastPkts, counters.if_group.ifOutMulticastPkts);
    vtss_snmp_u64_to_counter64(&table_entry_p->ifHCOutBroadcastPkts, counters.if_group.ifOutBroadcastPkts);

    table_entry_p->ifLinkUpDownTrapEnable = snmp_port_conf.linkupdown_trap_enable ? 1 : 2;

    if (port_status.link) { /* link_up */
        table_entry_p->ifHighSpeed += (port_status.speed == MESA_SPEED_25G ? 25000 : (port_status.speed == MESA_SPEED_10G ? 10000 : (port_status.speed == MESA_SPEED_5G ? 5000 : (port_status.speed == MESA_SPEED_2500M ? 2500 : (port_status.speed == MESA_SPEED_1G ? 1000 : (port_status.speed == MESA_SPEED_100M ? 1000 : 10))))));
    } else { /* link_down */
        table_entry_p->ifHighSpeed += (port_conf.speed == MESA_SPEED_25G ? 25000 : (port_conf.speed == MESA_SPEED_10G ? 10000 : (port_conf.speed == MESA_SPEED_5G ? 5000 : (port_conf.speed == MESA_SPEED_2500M ? 2500 : (port_conf.speed == MESA_SPEED_1G ? 1000 : (port_conf.speed == MESA_SPEED_100M ? 100 : 10))))));
    }

    /* Not supported in E-StaX34 project
    table_entry_p->ifPromiscuousMode          = 0;
    table_entry_p->ifConnectorPresent         = 0; */
    //table_entry_p->ifCounterDiscontinuityTime = 0;

    return TRUE;
}

BOOL get_ifXTable_entry(int table_index, ifXTable_entry_t *table_entry_p)
{
    iftable_info_t           table_info;
#ifdef VTSS_SW_OPTION_AGGR
    vtss_isid_t              isid;
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
#endif /* VTSS_SW_OPTION_AGGR */

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(ifXTable_entry_t));
    table_entry_p->ifIndex = table_index;

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        (void)icli_port_info_txt(topo_isid2usid(table_info.isid), (u32)iport2uport(table_info.if_id), (char *)table_entry_p->ifName);
        (void)icli_port_info_txt_short(topo_isid2usid(table_info.isid), (u32)iport2uport(table_info.if_id), (char *)table_entry_p->ifAlias);

        if (update_ifXTable_entry(table_info.isid, table_info.if_id, table_entry_p) == FALSE) {
            return FALSE;
        }
        break;
#ifdef VTSS_SW_OPTION_AGGR
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

        snprintf((char *)table_entry_p->ifName, sizeof(table_entry_p->ifName), "Link Aggregations %2u", table_info.ifIndex);
        snprintf((char *)table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "LAG %2u", table_info.ifIndex);

        (void)port_iter_init(&pit, NULL, table_info.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            if (update_ifXTable_entry(table_info.isid, pit.iport, table_entry_p) == FALSE) {
                return FALSE;
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, table_info.if_id, &aggr_members, FALSE) != VTSS_RC_OK) {
                continue;
            }

            snprintf((char *)table_entry_p->ifName, sizeof(table_entry_p->ifName), "Global Link Aggregations %u", table_info.ifIndex);
            snprintf((char *)table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "GLAG %u", table_info.ifIndex);

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_ifXTable_entry(isid, pit.iport, table_entry_p) == FALSE) {
                    return FALSE;
                }
            }
        }
        break;
#endif /* VTSS_SW_OPTION_AGGR */
    case IFTABLE_IFINDEX_TYPE_VLAN:
        snprintf((char *)table_entry_p->ifName, sizeof(table_entry_p->ifName), "VLAN %4d", (int)table_info.if_id);
        strcpy((char *)table_entry_p->ifAlias, (char *)table_entry_p->ifName);
        table_entry_p->ifLinkUpDownTrapEnable = 2;
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

static void ifmib_vlan_changed(void)
{
    struct timespec now_n;

    //James: gettimeofday(&ifTable_LastChange, NULL);
    clock_gettime(CLOCK_MONOTONIC, &now_n);
    ifTable_LastChange.tv_sec = now_n.tv_sec;
    ifTable_LastChange.tv_usec = now_n.tv_nsec / 1000;
}

#ifdef VTSS_SW_OPTION_AGGR
static void ifmib_aggr_changed(vtss_isid_t isid, uint aggr_no)
{
    struct timespec now_n;

    //James: gettimeofday(&ifTable_LastChange, NULL);
    clock_gettime(CLOCK_MONOTONIC, &now_n);
    ifTable_LastChange.tv_sec = now_n.tv_sec;
    ifTable_LastChange.tv_usec = now_n.tv_nsec / 1000;

}
#endif /* VTSS_SW_OPTION_AGGR */
#endif /* RFC2863_SUPPORTED_IFMIB */

/*
 * --- End (Internal implementation declarations)
 */

#if RFC2863_SUPPORTED_IFMIB
/* ifmib ----------------------------------------------------------*/
/*
 * ifMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ifMIB_variables_oid[] = { 1, 3, 6, 1, 2, 1, 31 };

/*
 * variable4 ifMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the ifMIB mib section
 */

struct variable4 ifMIB_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define IFNAME                          1
    {IFNAME, ASN_OCTET_STR, RONLY, var_ifXTable, 4, {1, 1, 1, 1}},
#define IFINMULTICASTPKTS               2
    {IFINMULTICASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 2}},
#define IFINBROADCASTPKTS               3
    {IFINBROADCASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 3}},
#define IFOUTMULTICASTPKTS              4
    {IFOUTMULTICASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 4}},
#define IFOUTBROADCASTPKTS              5
    {IFOUTBROADCASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 5}},
#define IFHCINOCTETS                    6
    {IFHCINOCTETS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 6}},
#define IFHCINUCASTPKTS                 7
    {IFHCINUCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 7}},
#define IFHCINMULTICASTPKTS             8
    {IFHCINMULTICASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 8}},
#define IFHCINBROADCASTPKTS             9
    {IFHCINBROADCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 9}},
#define IFHCOUTOCTETS                   10
    {IFHCOUTOCTETS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 10}},
#define IFHCOUTUCASTPKTS                11
    {IFHCOUTUCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 11}},
#define IFHCOUTMULTICASTPKTS            12
    {IFHCOUTMULTICASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 12}},
#define IFHCOUTBROADCASTPKTS            13
    {IFHCOUTBROADCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 13}},
#define IFLINKUPDOWNTRAPENABLE          14
    {IFLINKUPDOWNTRAPENABLE, ASN_INTEGER, RWRITE, var_ifXTable, 4, {1, 1, 1, 14}},
#define IFHIGHSPEED                     15
    {IFHIGHSPEED, ASN_GAUGE, RONLY, var_ifXTable, 4, {1, 1, 1, 15}},
    /* Not supported in E-StaX34 project
    #define IFPROMISCUOUSMODE               16
        {IFPROMISCUOUSMODE, ASN_INTEGER, RWRITE, var_ifXTable, 4, {1, 1, 1, 16}},
    #define IFCONNECTORPRESENT              17
        {IFCONNECTORPRESENT, ASN_INTEGER, RONLY, var_ifXTable, 4, {1, 1, 1, 17}}, */
#define IFALIAS                         18
    {IFALIAS, ASN_OCTET_STR, RWRITE, var_ifXTable, 4, {1, 1, 1, 18}},
#define IFCOUNTERDISCONTINUITYTIME      19
    {IFCOUNTERDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_ifXTable, 4, {1, 1, 1, 19}},
#define IFSTACKHIGHERLAYER              20
    {IFSTACKHIGHERLAYER, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 1}},
#define IFSTACKLOWERLAYER               21
    {IFSTACKLOWERLAYER, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 2}},
#define IFSTACKSTATUS                   22
    {IFSTACKSTATUS, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 3}}, /* the ifStack Table is read only in our implement  */
    /* Not supported in E-StaX34 project
    #define IFTESTID                        23
        {IFTESTID, ASN_INTEGER, RWRITE, var_ifTestTable, 4, {1, 3, 1, 1}},
    #define IFTESTSTATUS                    24
        {IFTESTSTATUS, ASN_INTEGER, RWRITE, var_ifTestTable, 4, {1, 3, 1, 2}},
    #define IFTESTTYPE                      25
        {IFTESTTYPE, ASN_OBJECT_ID, RWRITE, var_ifTestTable, 4, {1, 3, 1, 3}},
    #define IFTESTRESULT                    26
        {IFTESTRESULT, ASN_INTEGER, RONLY, var_ifTestTable, 4, {1, 3, 1, 4}},
    #define IFTESTCODE                      27
        {IFTESTCODE, ASN_OBJECT_ID, RONLY, var_ifTestTable, 4, {1, 3, 1, 5}},
    #define IFTESTOWNER                     28
        {IFTESTOWNER, ASN_OCTET_STR, RWRITE, var_ifTestTable, 4, {1, 3, 1, 6}},
    #define IFRCVADDRESSADDRESS             29
        {IFRCVADDRESSADDRESS, ASN_OCTET_STR, RONLY, var_ifRcvAddressTable, 4, {1, 4, 1, 1}},
    #define IFRCVADDRESSSTATUS              30
        {IFRCVADDRESSSTATUS, ASN_INTEGER, RWRITE, var_ifRcvAddressTable, 4, {1, 4, 1, 2}},
    #define IFRCVADDRESSTYPE                31
        {IFRCVADDRESSTYPE, ASN_INTEGER, RWRITE, var_ifRcvAddressTable, 4, {1, 4, 1, 3}}, */
#define IFTABLELASTCHANGE               32
    {IFTABLELASTCHANGE, ASN_TIMETICKS, RONLY, var_ifMIB, 2, {1, 5}},
    /* Not supported in E-StaX34 project
    #define IFSTACKLASTCHANGE               33
        {IFSTACKLASTCHANGE, ASN_TIMETICKS, RONLY, var_ifMIB, 2, {1, 6}}, */
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the ifMIB module
 */
void
init_ifMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(ifMIB_variables_oid,
                             sizeof(ifMIB_variables_oid) / sizeof(oid),
                             "IF-MIB : ifMIB");

    DEBUGMSGTL(("ifMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ifMIB", ifMIB_variables, variable4, ifMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
    memset(&ip_ifXTable_entry, 0x0, sizeof(ip_ifXTable_entry));

    if (!register_flag) {
        /* VLAN config change register */
        vlan_membership_bulk_change_register(VTSS_MODULE_ID_SNMP, ifmib_vlan_changed);

#ifdef VTSS_SW_OPTION_AGGR
        /* AGGR config change callback */
        aggr_change_register(ifmib_aggr_changed);
#endif /* VTSS_SW_OPTION_AGGR */

        register_flag = TRUE;
    }
}

/*
 * var_ifMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_ifMIB(struct variable *vp,
          oid *name,
          size_t *length,
          int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static u_long ulong_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFTABLELASTCHANGE: {
        ulong_ret = (ifTable_LastChange.tv_sec * 100) + (ifTable_LastChange.tv_usec / 10000);
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFSTACKLASTCHANGE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif /* Not supported in E-StaX34 project */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifMIB\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_ifRcvAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifRcvAddressTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //ifRcvAddressTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];       /* FIXME */
    //table_index = get_available_ifRcvAddressTableIndex(idx_num); /* FIXME */
    //if (!get_ifRcvAddressTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFRCVADDRESSADDRESS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFRCVADDRESSSTATUS: {
        *write_method = write_ifRcvAddressStatus;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFRCVADDRESSTYPE: {
        *write_method = write_ifRcvAddressType;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ifRcvAddressTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* Not supported in E-StaX34 project */

/*
 * var_ifXTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifXTable(struct variable *vp,
             oid *name,
             size_t *length,
             int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                     table_index;
    int                     table_size;
    ifXTable_entry_t        table_entry;
    int                     idx_num;
    static u_long           ulong_ret;
    static u_char           string[100];
    static struct counter64 c64;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    if (!get_ifXTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFNAME: {
        strcpy((char *)string, (char *)table_entry.ifName);
        *var_len = strlen((char *)string);
        return (u_char *) string;
    }
    case IFINMULTICASTPKTS: {
        ulong_ret = table_entry.ifInMulticastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFINBROADCASTPKTS: {
        ulong_ret = table_entry.ifInBroadcastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFOUTMULTICASTPKTS: {
        ulong_ret = table_entry.ifOutMulticastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFOUTBROADCASTPKTS: {
        ulong_ret = table_entry.ifOutBroadcastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFHCINOCTETS: {
        c64 = table_entry.ifHCInOctets;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINUCASTPKTS: {
        c64 = table_entry.ifHCInUcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINMULTICASTPKTS: {
        c64 = table_entry.ifHCInMulticastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINBROADCASTPKTS: {
        c64 = table_entry.ifHCInBroadcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTOCTETS: {
        c64 = table_entry.ifHCOutOctets;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTUCASTPKTS: {
        c64 = table_entry.ifHCOutUcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTMULTICASTPKTS: {
        c64 = table_entry.ifHCOutMulticastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTBROADCASTPKTS: {
        c64 = table_entry.ifHCOutBroadcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHIGHSPEED: {
        ulong_ret = table_entry.ifHighSpeed;
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFPROMISCUOUSMODE: {
        *write_method = write_ifPromiscuousMode;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFCONNECTORPRESENT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif /* Not supported in E-StaX34 project */
    case IFALIAS: {
        /* Not supported in E-StaX34 project,
        *write_method = write_ifAlias; */
        strcpy((char *)string, (char *)table_entry.ifAlias);
        *var_len = strlen((char *)string);
        return (u_char *) string;
    }
    case IFCOUNTERDISCONTINUITYTIME: {
        ulong_ret = table_entry.ifCounterDiscontinuityTime;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifXTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_ifTestTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifTestTable(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //ifTestTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_ifTestTableIndex(idx_num); /* FIXME */
    //if (!get_ifTestTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFTESTID: {
        *write_method = write_ifTestId;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTSTATUS: {
        *write_method = write_ifTestStatus;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTTYPE: {
        *write_method = write_ifTestType;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTRESULT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTCODE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTOWNER: {
        *write_method = write_ifTestOwner;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifTestTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif  /* Not supported in E-StaX34 project */

/**
  * \brief Get the next existent IfIndex in the specific type.
  *
  * \param info [INOUT]:    The info parameter has following members\n
  *                       [IN] type: The interface type
  *                       [INOUT] ifIndex: The first ifIndex, if any
  *                       [OUT] isid: The first ISID, if the output type is neither IFINDEX_TYPE_PORT nor IFINDEX_TYPE_LLAG interface, the isid shouldn't be modified.
  *                       [OUT] if_id: The first interface ID
  * \return
  *    FALSE if there is no available ifIndex.\n
  *     Otherwise, return TRUE.
  */
BOOL ifIndex_get_next_by_type(iftable_info_t *key_info)
{
    iftable_info_t  info;
    BOOL            found = FALSE;
    info.ifIndex = key_info->ifIndex;

    switch (key_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
    case IFTABLE_IFINDEX_TYPE_LLAG:
        while (ifIndex_get_next(&info)) {
            if (info.type == key_info->type) {
                found = TRUE;
                break;
            }
            if (info.type != IFTABLE_IFINDEX_TYPE_PORT && info.type != IFTABLE_IFINDEX_TYPE_LLAG) {
                return FALSE;
            }
        }
        if (found != TRUE) {
            return FALSE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    default:
        return FALSE;
    }

    memcpy(key_info, &info, sizeof(info));
    return TRUE;
}

static BOOL get_or_next_vlanMemberByPort(mesa_vid_t vid, iftable_info_t *key2_info)
{
    port_iter_t            pit;
    switch_iter_t          sit;
    vtss_appl_vlan_entry_t vlan_mgmt_entry;
    BOOL                   port_found = FALSE;
    iftable_info_t         info;
#ifdef VTSS_SW_OPTION_AGGR
    aggr_mgmt_group_no_t   tmp_aggr_no, min_llag_no = 0, min_glag_no = 0;
#endif /* VTSS_SW_OPTION_AGGR */
    u8                     access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc                rc;

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return FALSE;
    }

    if (!VTSS_BF_GET(access_vids, vid)) {
        return FALSE;
    }

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vtss_appl_vlan_get(sit.isid, vid, &vlan_mgmt_entry, FALSE, VTSS_APPL_VLAN_USER_STATIC) != VTSS_RC_OK) {
            return FALSE;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!vlan_mgmt_entry.ports[pit.iport] ) {
                continue;
            }

#ifdef VTSS_SW_OPTION_AGGR
            tmp_aggr_no = aggr_mgmt_get_port_aggr_id (sit.isid, pit.iport);

#if (AGGR_GLAG_CNT != 0)
            if (tmp_aggr_no > 0 &&  AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr_no) ) {
                min_glag_no = min_glag_no == 0 ? tmp_aggr_no : tmp_aggr_no < min_glag_no ? tmp_aggr_no : min_glag_no;
            } else if (tmp_aggr_no > 0) {
#else
            if (tmp_aggr_no > 0) {
#endif
                min_llag_no = min_llag_no == 0 ? tmp_aggr_no : tmp_aggr_no < min_llag_no ? tmp_aggr_no : min_llag_no;
            }
#endif /* VTSS_SW_OPTION_AGGR */

            if (sit.isid < key2_info->isid  || (sit.isid == key2_info->isid && pit.iport < key2_info->if_id)) {
                continue;
            }

#ifdef VTSS_SW_OPTION_AGGR
            if ( 0 == tmp_aggr_no) {
                port_found = TRUE;
                break;
            }
#endif /* VTSS_SW_OPTION_AGGR */

        }
        if (port_found == TRUE ) {
            break;
        }
    }

    if ( port_found == FALSE
#ifdef VTSS_SW_OPTION_AGGR
         && min_llag_no == 0 && min_glag_no == 0
#endif /* VTSS_SW_OPTION_AGGR */
       ) {
        return FALSE;
    } else if (port_found == FALSE) {
#ifdef VTSS_SW_OPTION_AGGR
#if (AGGR_GLAG_CNT != 0)
        info.if_id = (min_llag_no != 0) ? min_llag_no : min_glag_no;
        info.type = (min_llag_no != 0) ? IFTABLE_IFINDEX_TYPE_LLAG : IFTABLE_IFINDEX_TYPE_GLAG;
        if (min_llag_no) {
            info.isid = sit.isid;
        }
#else
        info.if_id = min_llag_no;
        info.type = IFTABLE_IFINDEX_TYPE_LLAG;
        info.isid = sit.isid;
#endif
#endif /* VTSS_SW_OPTION_AGGR */
    } else {
        info.if_id = pit.iport;
        info.isid = sit.isid;
        info.type = IFTABLE_IFINDEX_TYPE_PORT;
    }

    (void) ifIndex_get_by_interface(&info);
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;

}

static BOOL get_vlanMemberByLLAG (mesa_vid_t vid, iftable_info_t *key2_info)
{
#ifdef VTSS_SW_OPTION_AGGR
    port_iter_t              pit;
    aggr_mgmt_group_member_t aggr_members;
#endif /* VTSS_SW_OPTION_AGGR */
    vtss_appl_vlan_entry_t   vlan_mgmt_entry;
    u8                       access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc                  rc;

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return FALSE;
    }

    if (!VTSS_BF_GET(access_vids, vid)) {
        return FALSE;
    }

    if (vtss_appl_vlan_get(key2_info->isid, vid, &vlan_mgmt_entry, FALSE, VTSS_APPL_VLAN_USER_STATIC) != VTSS_RC_OK) {
        return FALSE;
    }

#ifdef VTSS_SW_OPTION_AGGR
    if ((aggr_mgmt_port_members_get(key2_info->isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#ifdef VTSS_SW_OPTION_LACP
        && (aggr_mgmt_lacp_members_get(key2_info->isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#endif /* VTSS_SW_OPTION_LACP */
       ) {
        return FALSE;
    }

    (void)port_iter_init(&pit, NULL, key2_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
    while (port_iter_getnext(&pit)) {
        if (!aggr_members.entry.member[pit.iport] || !vlan_mgmt_entry.ports[pit.iport]) {
            continue;
        }
        return TRUE;
    }
#endif /* VTSS_SW_OPTION_AGGR */
    return FALSE;

}

static BOOL get_vlanMemberByGLAG(mesa_vid_t vid, iftable_info_t *key2_info)
{
#ifdef VTSS_SW_OPTION_AGGR
    port_iter_t              pit;
    switch_iter_t            sit;
    aggr_mgmt_group_member_t aggr_members;
    vtss_appl_vlan_entry_t   vlan_mgmt_entry;
#endif /* VTSS_SW_OPTION_AGGR */
    u8                       access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc                  rc;

    if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
        T_E("Huh? %s\n", error_txt(rc));
        return FALSE;
    }

    if (!VTSS_BF_GET(access_vids, vid)) {
        return FALSE;
    }

#ifdef VTSS_SW_OPTION_AGGR
    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vtss_appl_vlan_get(sit.isid, vid, &vlan_mgmt_entry, FALSE, VTSS_APPL_VLAN_USER_STATIC) != VTSS_RC_OK) {
            return FALSE;
        }

        if (aggr_mgmt_port_members_get(sit.isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK) {
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport] || !vlan_mgmt_entry.ports[pit.iport] ) {
                continue;
            }
            return TRUE;
        }
    }
#endif /* VTSS_SW_OPTION_AGGR */

    return FALSE;
}

static BOOL get_or_next_vlanMemberByGLAG (mesa_vid_t vid, iftable_info_t *key2_info)
{
    iftable_info_t info;
    memcpy(&info, key2_info, sizeof(info));
    if ( FALSE == get_vlanMemberByGLAG ( vid, &info) ) {
        while ( TRUE == ifIndex_get_next(&info)) {
            if (info.type != IFTABLE_IFINDEX_TYPE_GLAG) {
                return FALSE;
            }
            if (TRUE == get_vlanMemberByGLAG ( vid, &info)) {
                break;
            }
            continue;
        }
    }
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;
}

static BOOL get_or_next_vlanMemberByLLAG (mesa_vid_t vid, iftable_info_t *key2_info)
{
    iftable_info_t info;
    memcpy(&info, key2_info, sizeof(info));
    if ( FALSE == get_vlanMemberByLLAG ( vid, &info) ) {
        while ( TRUE == ifIndex_get_next(&info)) {
            switch (info.type) {
            case IFTABLE_IFINDEX_TYPE_LLAG:
                if (TRUE == get_vlanMemberByLLAG ( vid, &info)) {
                    break;
                }
                continue;
            case IFTABLE_IFINDEX_TYPE_PORT:
                if (FALSE == get_or_next_vlanMemberByPort(vid, &info)) {
                    return FALSE;
                }
                break;
            case IFTABLE_IFINDEX_TYPE_GLAG:
                if (FALSE == get_or_next_vlanMemberByGLAG(vid, &info)) {
                    return FALSE;
                }
                break;
            default:
                return FALSE;
            }
        }
    }
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;

}


static BOOL get_next_ifStackTableByKey1( iftable_info_t *key1_info, long *ifStackLowerLayer )
{
    iftable_info_t  info;
    BOOL found = FALSE;
#ifdef VTSS_SW_OPTION_AGGR
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    switch_iter_t            sit;
#endif /* VTSS_SW_OPTION_AGGR */

    info.ifIndex = *ifStackLowerLayer;

    switch (key1_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        break;
#ifdef VTSS_SW_OPTION_AGGR
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

        info.type = IFTABLE_IFINDEX_TYPE_PORT;
        if (FALSE == ifIndex_get_next_by_type(&info) || info.isid != key1_info->isid ) {
            return FALSE;
        }

        (void)port_iter_init(&pit, NULL, key1_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (aggr_members.entry.member[pit.iport]) {
            }
            if (!aggr_members.entry.member[pit.iport] || pit.iport < info.if_id ) {
                continue;
            }

            info.if_id = pit.iport;
            info.type = IFTABLE_IFINDEX_TYPE_PORT;
            info.isid = key1_info->isid;
            (void) ifIndex_get_by_interface(&info);
            *ifStackLowerLayer = info.ifIndex;
            return TRUE;
        }

        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        info.type = IFTABLE_IFINDEX_TYPE_PORT;
        if (FALSE == ifIndex_get_next_by_type(&info) ) {
            return FALSE;
        }

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (sit.isid < info.isid) {
                continue;
            }
            if (aggr_mgmt_port_members_get(sit.isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport] || (sit.isid == info.isid && pit.iport < info.if_id )) {
                    continue;
                }
                info.if_id = pit.iport;
                info.type = IFTABLE_IFINDEX_TYPE_PORT;
                info.isid = sit.isid;
                (void) ifIndex_get_by_interface(&info);
                *ifStackLowerLayer = info.ifIndex;
                return TRUE;
            }
        }
        break;
#endif /* VTSS_SW_OPTION_AGGR */
    case IFTABLE_IFINDEX_TYPE_VLAN:
        /* Find out the next layer of VLAN */
        while (ifIndex_get_next(&info)) {
            if (info.type == IFTABLE_IFINDEX_TYPE_PORT ||
                info.type == IFTABLE_IFINDEX_TYPE_LLAG ||
                info.type == IFTABLE_IFINDEX_TYPE_GLAG) {
                found = TRUE;
                break;
            }
        }
        if (!found) {
            return FALSE;
        }

        switch (info.type) {
        case IFTABLE_IFINDEX_TYPE_PORT:
            if (FALSE == get_or_next_vlanMemberByPort (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        case IFTABLE_IFINDEX_TYPE_LLAG:
            if (FALSE == get_or_next_vlanMemberByLLAG (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        case IFTABLE_IFINDEX_TYPE_GLAG:
            if (FALSE == get_or_next_vlanMemberByGLAG (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        default:
            return FALSE;
        }

        *ifStackLowerLayer = info.ifIndex;
        return TRUE;
    default:
        break;
    }

    return FALSE;

}

static BOOL get_first_ifStackTableKey1(iftable_info_t *key1_info, long *ifStackLowerLayer )
{
    iftable_info_t  info;
#ifdef VTSS_SW_OPTION_AGGR
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    switch_iter_t            sit;
#endif /* VTSS_SW_OPTION_AGGR */

    switch (key1_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        *ifStackLowerLayer = 0;
        return TRUE;
#ifdef VTSS_SW_OPTION_AGGR
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            *ifStackLowerLayer = 0;
            return TRUE;
        }

        (void)port_iter_init(&pit, NULL, key1_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            info.if_id = pit.iport;
            info.type = IFTABLE_IFINDEX_TYPE_PORT;
            info.isid = key1_info->isid;
            (void) ifIndex_get_by_interface(&info);

            *ifStackLowerLayer = info.ifIndex;
            return TRUE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (aggr_mgmt_port_members_get(sit.isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_RC_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport] ) {
                    continue;
                }
                info.if_id = pit.iport;
                info.type = IFTABLE_IFINDEX_TYPE_PORT;
                info.isid = sit.isid;
                (void) ifIndex_get_by_interface(&info);
                *ifStackLowerLayer = info.ifIndex;
                return TRUE;
            }
        }
        break;
#endif /* VTSS_SW_OPTION_AGGR */
    case IFTABLE_IFINDEX_TYPE_VLAN:
        info.ifIndex = 0;
        if ( FALSE == ifIndex_get_next(&info)) {
            break;
        }

        /* Find out the first port instance of VLAN next layer */
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_USID);
        if (switch_iter_getnext(&sit)) {
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            info.isid = sit.isid;
            info.if_id = pit.iport;
        }

        if ( FALSE == get_or_next_vlanMemberByPort(key1_info->if_id, &info)) {
            /* no available member means that the member is NULL */
            *ifStackLowerLayer = 0;
            return TRUE;
        }
        *ifStackLowerLayer = info.ifIndex;
        return TRUE;
    default:
        break;
    }

    return FALSE;

}

static BOOL get_next_ifStacktTableKey(long *ifStackHigherLayer, long *ifStackLowerLayer)
{
    long            k2 = 0;
    iftable_info_t  info;
    BOOL            next_hiLayer = FALSE;

    info.ifIndex = *ifStackHigherLayer;
    if ( FALSE == ifIndex_get( &info )) {
        if (FALSE == ifIndex_get_next( &info )) {
            return FALSE;
        }
        next_hiLayer = TRUE;
    } else {
        k2 = *ifStackLowerLayer;
        if (FALSE == get_next_ifStackTableByKey1 (&info, &k2)) {
            if (FALSE == ifIndex_get_next( &info )) {
                return FALSE;
            }
            next_hiLayer = TRUE;
        }
    }

    if (next_hiLayer == TRUE) {
        if ( FALSE == get_first_ifStackTableKey1 (&info, &k2) ) {
            return FALSE;
        }
    }
    *ifStackHigherLayer = info.ifIndex;
    *ifStackLowerLayer = k2;
    return TRUE;

}

static BOOL get_ifStacktTableKey(long *ifStackHigherLayer, long *ifStackLowerLayer)
{
    long k1, k2;

    if (*ifStackHigherLayer < 1) {
        return FALSE;
    } else if (*ifStackLowerLayer < 1) {
        k1 = *ifStackHigherLayer - 1;
        k2 = IFTABLE_IFINDEX_END;
    } else {
        k1 = *ifStackHigherLayer;
        k2 =  *ifStackLowerLayer - 1;
    }

    if ( FALSE == get_next_ifStacktTableKey (&k1, &k2) ||
         *ifStackHigherLayer != k1 || *ifStackLowerLayer != k2) {
        return FALSE;
    }

    return TRUE;
}

static BOOL get_ifStackTableByKey(ifStackTable_entry_t *table_entry)
{
    table_entry->ifStackStatus = SNMP_ROW_ACTIVE;
    return TRUE;
}

static int
getfirst_ifStackTableEntry(ifStackTable_entry_t *table_entry)
{
    long k1 = 0, k2 = 0;
    if (FALSE == get_next_ifStacktTableKey(&k1, &k2)) {
        return VTSS_RC_ERROR;
    }
    table_entry->ifStackHigherLayer = k1;
    table_entry->ifStackLowerLayer = k2;
    (void) get_ifStackTableByKey(table_entry);

    return VTSS_RC_OK;
}

static int
get_ifStackTableEntry(ifStackTable_entry_t *table_entry, BOOL getnext)
{
    long k1 = table_entry->ifStackHigherLayer, k2 = table_entry->ifStackLowerLayer;

    if ( (FALSE == getnext && FALSE == get_ifStacktTableKey(&k1, &k2)) ||
         (FALSE != getnext  && FALSE == get_next_ifStacktTableKey(&k1, &k2))) {
        return VTSS_RC_ERROR;
    }

    table_entry->ifStackHigherLayer = k1;
    table_entry->ifStackLowerLayer = k2;
    (void) get_ifStackTableByKey(table_entry);

    return VTSS_RC_OK;
}

static int
set_ifStackTableEntry(ifStackTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return VTSS_RC_ERROR;
}

static int
parse_ifStackTable(oid *name,
                   size_t *length,
                   int exact, ifStackTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ifStackTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ifStackHigherLayer = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ifStackLowerLayer = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if ( VTSS_RC_OK == get_ifStackTableEntry(table_entry, FALSE) || VTSS_RC_OK == get_ifStackTableEntry(table_entry, TRUE)) {
            return 1;
        } else {
            return -1;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ifStackTable(oid *name,
                     size_t *length, ifStackTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ifStackHigherLayer;
    name[name_pos++] = (oid) table_entry->ifStackLowerLayer;

    *length = name_pos;
    return 0;
}

/*
 * var_ifStackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifStackTable above.
 */
u_char         *
var_ifStackTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ifStackTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ifStackTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ifStackTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ifStackTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IFSTACKSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry.
                     */
                    *write_method = write_ifStackStatus;
                }
                return NULL;
            }
            if (fillobj_ifStackTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFSTACKSTATUS: {
        *write_method = write_ifStackStatus;
        ifStackTable_global_ret.long_ret = table_entry.ifStackStatus;
        *var_len = sizeof(ifStackTable_global_ret.long_ret);
        return (u_char *) & ifStackTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifStackTable\n",
                    vp->magic));
    }
    return NULL;
}


#if 0 /* Not supported in E-StaX34 project */
int
write_ifRcvAddressStatus(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifRcvAddressType(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not supported in E-StaX34 project */

#if 0 /* Not supported in E-StaX34 project */
int
write_ifPromiscuousMode(int action,
                        u_char *var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifAlias(int action,
              u_char *var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR, "write to ifAlias: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifAlias: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifAlias: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestId(int action,
               u_char *var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to ifTestId: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestId: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestId: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestStatus(int action,
                   u_char *var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifTestStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestType(int action,
                 u_char *var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char *statP, oid *name, size_t name_len)
{
    oid            *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(oid);     /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to ifTestType: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((oid *) var_val);  /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestOwner(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to ifTestOwner: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestOwner: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestOwner: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not supported in E-StaX34 project */

int
write_ifStackStatus(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ifStackTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4 && set_value != 5 && set_value != 6) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ifStackTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /*
         * Return error code when the entry isn't existing
         * except for "createAndGo(4)" or "createAndWait(5)" status
         */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ifStackTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ifStackStatus = set_value;
        if (set_ifStackTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC2863_SUPPORTED_IFMIB */

