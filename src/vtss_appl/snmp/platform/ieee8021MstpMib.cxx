/*
 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 Microchip is aware that some terminology used in this technical document is
 antiquated and inappropriate. As a result of the complex nature of software
 where seemingly simple changes have unpredictable, and often far-reaching
 negative results on the software's functionality (requiring extensive retesting
 and revalidation) we are unable to make the desired changes in all legacy
 systems without compromising our product or our clients' products.
*/

//Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//      Revise the "FIXME" parts to make it as a completed code.

#include <main.h>

#include "vtss_os_wrapper_snmp.h"
#include "vtss_snmp_api.h"
#include "ucd_snmp_ieee8021MstpMib.h"
#include "mibContextTable.h"         //mibContextTable_register()
#include "mibContextTable.h"         // mibContextTable_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#include "msg_api.h"
#include "mstp_api.h"
#include "ieee8021MstpMib.h"
#include "vlan_api.h"
#include "dot1Port_api.h"
#include "vtss_rowStatus.h"


// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

#define SNMP_BRIDGEID_LEN   8
#define MSTID_CIST          0   /* CIST is MSTI0 - MSTID zero */

#define   SNMP_MSTP_FALSE              2
#define   SNMP_MSTP_TRUE               1
#define   SNMP_MSTP_VID_MAX            128
#define   SNMP_MSTP_CFG_DIGEST_MAX     16
#define   SNMP_MSTP_ROOT_PORT          1
#define   SNMP_MSTP_ALTERNATE_PORT     2
#define   SNMP_MSTP_DESIGNATE_PORT     3
#define   SNMP_MSTP_BACKUP_PORT        4
#define   SNMP_MSTP_PORT_ERROR         5

#define   SNMP_SET_MASK_MAX            256
#define   SNMP_SET_MASK_VAL            8

static void send_mstp_trap(u32 event_mask);
static void snmp_new_root_notification(void);
static void snmp_topology_change_notification(void);

/******************************************************************************/
//
// Local functions
//
/******************************************************************************/

/****************************************************************
 *Purpose     : Sets the mask in the appropriate bit corresponding
 *              to the value.
 *Remarks     : This function can be used in any application
 *              provided the size is specified as the size of
 *              the mask array being passed.
 *Restrictions: size should be less than or equal to size of
 *              array mask, value should
 *              be less than size of mask array *8.
 *              First bit stands for value 0
 *see also:
 *Example:
 ******************************************************************/

static void IEEE8021MSTP_setmask(u8 *mask, int value, int size)
{
    int k = SNMP_SET_MASK_MAX;

    if (value / SNMP_SET_MASK_VAL > size) {
        return;
    }
    if ((value % SNMP_SET_MASK_VAL) != 0) {
        if (value > 0 && value / SNMP_SET_MASK_VAL < size) {
            mask[value / SNMP_SET_MASK_VAL]
            |= k >> (value % SNMP_SET_MASK_VAL);
        }
    } else if (value != 0) {
        mask[(value / SNMP_SET_MASK_VAL) - 1] |= 1;
    }
}

static BOOL IEEE8021MSTP_TableEntryByKey_get(ieee8021MstpTable_entry_t *table_entry)
{
    mstp_bridge_status_t status;
    mstp_msti_config_t   msti_config;
    int                  i = 0;
    BOOL                 rc = FALSE;

    memset (&msti_config, 0, sizeof(mstp_msti_config_t));

    if ( table_entry->ieee8021MstpComponentId != 1 || table_entry->ieee8021MstpId >= N_MSTI_MAX ) {
        return FALSE;
    }
    rc = (vtss_appl_mstp_bridge_status_get (table_entry->ieee8021MstpId, &status) == VTSS_RC_OK);

    if (rc == FALSE) {
        memset(&status, 0, sizeof(status));
    }

    table_entry->ieee8021MstpBridgeId_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpBridgeId, status.bridgeId,
            table_entry->ieee8021MstpBridgeId_len);
    table_entry->ieee8021MstpTimeSinceTopologyChange =
        status.timeSinceTopologyChange * 100;
    table_entry->ieee8021MstpTopologyChanges.low = status.topologyChangeCount;
    table_entry->ieee8021MstpTopologyChanges.high = 0;
    table_entry->ieee8021MstpTopologyChange = status.topologyChange ? 1 : 2;
    table_entry->ieee8021MstpDesignatedRoot_len = sizeof(status.designatedRoot);
    memcpy (table_entry->ieee8021MstpDesignatedRoot, status.designatedRoot,
            table_entry->ieee8021MstpDesignatedRoot_len);
    table_entry->ieee8021MstpRootPathCost = status.rootPathCost;
    table_entry->ieee8021MstpRootPort = status.rootPort == L2_NULL ? L2_NULL : status.rootPort + 1;


    /* Bride Identifier (Refer 13.23.2 802.1 Q 2005 Standard)
     *
     * The four significant bits of the Bridge Identifier (the settable
     * priority component) for the CIST and for each MSTI  can be modified
     * independently of the setting of the those bits for all other trees,
     * as a part of allowing full and indenpent configuration control to
     * be extended over each STP instance.
     */
    /*
     * Priority is the first 2 bytes of the bridge Id. MSB of the priority
     * is stored in the first byte of the char array.
     * Therefore copy the content in the reverse order so as to copy the
     * MSB in the right place in the long int.
     */
    table_entry->ieee8021MstpBridgePriority = vtss_mstp_msti_priority_get(table_entry->ieee8021MstpId) << 8;

    if (vtss_appl_mstp_msti_config_get (&msti_config, NULL) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->ieee8021MstpVids0_len = 128;
    table_entry->ieee8021MstpVids1_len = 128;
    table_entry->ieee8021MstpVids2_len = 128;
    table_entry->ieee8021MstpVids3_len = 128;
    for (i = 0; i < MSTP_MAX_VID; i++) {
        if (msti_config.map.map[i] == table_entry->ieee8021MstpId) {
            if (i / SNMP_MSTP_VID_MAX == 0) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids0, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids0));
            } else if (i / SNMP_MSTP_VID_MAX == 1) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids1, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids1));
            } else if (i / SNMP_MSTP_VID_MAX == 2) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids2, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids2));
            } else if (i / SNMP_MSTP_VID_MAX == 3) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids3, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids3));
            } /* end of  else-if */
        } /* end of if */
    } /* end of for */

    table_entry->ieee8021MstpRowStatus = rc == TRUE ? RFC2579_STATE_ACTIVE : RFC2579_STATE_NOT_IN_SERVICE;

    return TRUE;
}

static BOOL IEEE8021MSTP_TableEntryByKey_getnext(ieee8021MstpTable_entry_t *table_entry)
{
    ieee8021MstpTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpComponentId > 1 || (tmp.ieee8021MstpComponentId == 1 && tmp.ieee8021MstpId >= N_MSTI_MAX )) {
        return FALSE;
    }

    if ( tmp.ieee8021MstpComponentId < 1 ) {
        tmp.ieee8021MstpComponentId = 1;
        tmp.ieee8021MstpId = 1;
    } else {
        tmp.ieee8021MstpId++;
    }
    while (tmp.ieee8021MstpId < N_MSTI_MAX && FALSE == IEEE8021MSTP_TableEntryByKey_get( &tmp )) {
        tmp.ieee8021MstpId++;
    }

    if (tmp.ieee8021MstpId == N_MSTI_MAX) {
        return FALSE;
    }
    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_CistPortTableEntryByKey_getnext(ieee8021MstpCistPortTable_entry_t *
                                                         table_entry)
{
    dot1Port_info_t   info;
    BOOL              found = FALSE, enable;
    mstp_port_mgmt_status_t      status;
    mstp_bridge_status_t bs;
    mstp_msti_port_param_t port_parm;
    mstp_port_param_t       pconf;

    if ( table_entry->ieee8021MstpCistPortComponentId > 1 ) {
        return FALSE;
    }

    if (table_entry->ieee8021MstpCistPortComponentId < 1) {
        info.dot1port = 0;
    }

    info.dot1port = table_entry->ieee8021MstpCistPortNum;

    while ( TRUE == dot1Port_get_next(&info) ) {
        T_D ("mstp_get_port_status: l2port = %d", info.dot1port - 1);
        if (TRUE == (found = mstp_get_port_status (MSTID_CIST, info.dot1port - 1, &status))) {
            break;
        }
        T_D("not found");
    }

    if ( FALSE == found ) {
        return FALSE;
    }

    if (vtss_mstp_msti_port_config_get( info.isid, MSTID_CIST,
                                        info.if_id, &port_parm ) != VTSS_RC_OK ) {
        return FALSE;
    }
    if (vtss_mstp_port_config_get (info.isid, info.if_id,
                                   &enable, &pconf) != VTSS_RC_OK) {
        return FALSE;
    }

    if ( VTSS_RC_OK != vtss_appl_mstp_bridge_status_get(MSTID_CIST, &bs)) {
        return FALSE;
    }

    table_entry->ieee8021MstpCistPortAdminPathCost = port_parm.adminPathCost;
    table_entry->ieee8021MstpCistPortAdminEdgePort = pconf.adminEdgePort == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortRestrictedRole = pconf.restrictedRole == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortRestrictedTcn = pconf.restrictedTcn == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortComponentId = 1;
    table_entry->ieee8021MstpCistPortNum = info.dot1port;
    table_entry->ieee8021MstpCistPortUptime = status.core.uptime * 100;
    table_entry->ieee8021MstpCistPortDesignatedRoot_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpCistPortDesignatedRoot,
            status.core.designatedRoot, table_entry->ieee8021MstpCistPortDesignatedRoot_len);
    table_entry->ieee8021MstpCistPortTopologyChangeAck = status.core.tcAck;
    /***** supplying the dummy values if port not active ---as explained in bugzilla # 3702 ******/
    if (status.active ) {
        table_entry->ieee8021MstpCistPortHelloTime = status.core.helloTime * 100;
    } else {
        table_entry->ieee8021MstpCistPortHelloTime = 200;
    }
    table_entry->ieee8021MstpCistPortOperEdgePort = status.core.operEdgePort == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortMacEnabled = pconf.adminPointToPointMAC == P2P_FORCEFALSE ? 2 : 1;
    table_entry->ieee8021MstpCistPortMacOperational =
        status.core.macOperational == TRUE ? 1 : 2;

    if (strcasecmp (status.core.rolestr, "rootport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 1;
    } else if (strcasecmp (status.core.rolestr, "alternateport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 2;
    } else if (strcasecmp (status.core.rolestr, "designatedport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 3;
    } else if (strcasecmp (status.core.rolestr, "backupport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 4;
    }
    table_entry->ieee8021MstpCistPortDisputed = status.core.disputed == TRUE ? 1 : 2;

    table_entry->ieee8021MstpCistPortCistRegionalRootId_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpCistPortCistRegionalRootId,
            bs.cistRegionalRoot, table_entry->ieee8021MstpCistPortCistRegionalRootId_len);
    table_entry->ieee8021MstpCistPortCistPathCost = status.core.pathCost;
    table_entry->ieee8021MstpCistPortProtocolMigration = 1;
    table_entry->ieee8021MstpCistPortIsL2Gp = 2;
    table_entry->ieee8021MstpCistPortEnableBPDURx = !pconf.bpduGuard;
    table_entry->ieee8021MstpCistPortEnableBPDUTx = 1;
    table_entry->active = status.active;

    return TRUE;

}

static BOOL IEEE8021MSTP_CistPortTableEntryByKey_get(ieee8021MstpCistPortTable_entry_t *table_entry)
{
    ieee8021MstpCistPortTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpCistPortNum ) {
        --tmp.ieee8021MstpCistPortNum;
    } else if ( tmp.ieee8021MstpCistPortComponentId ) {
        --tmp.ieee8021MstpCistPortComponentId;
        tmp.ieee8021MstpCistPortNum = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_CistPortTableEntryByKey_getnext( &tmp ) ||
         tmp.ieee8021MstpCistPortComponentId != table_entry->ieee8021MstpCistPortComponentId ||
         tmp.ieee8021MstpCistPortNum != table_entry->ieee8021MstpCistPortNum ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_getnext_vlanId(u_long *vid)
{
    vtss_appl_vlan_entry_t vlan_mgmt_entry;

    vlan_mgmt_entry.vid = *vid;
    T_D("%lu next", *vid);
    if (vtss_appl_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, TRUE, VTSS_APPL_VLAN_USER_ALL) != VTSS_RC_OK) {
        return FALSE;
    }

    *vid = vlan_mgmt_entry.vid;
    T_D("got %lu", *vid);
    return TRUE;
}


static BOOL IEEE8021MSTP_FidToMstiTableEntryByKey_getnext(ieee8021MstpFidToMstiTable_entry_t *table_entry)
{
    u_long vid = table_entry->ieee8021MstpFidToMstiFid, componentId = table_entry->ieee8021MstpFidToMstiComponentId;
    mstp_msti_config_t msti_config;

    if ( componentId > 1 ) {
        return FALSE;
    }

    if ( componentId < 1 ) {
        componentId = 1;
        vid = 0;
    }

    if (vtss_appl_mstp_msti_config_get (&msti_config, NULL) != VTSS_RC_OK) {
        return FALSE;
    }

    /* Skip CIST(MSTI-0) instance */
    do {
        if (FALSE == IEEE8021MSTP_getnext_vlanId(&vid)) {
            return FALSE;
        }
    } while (msti_config.map.map[vid] == 0);

    table_entry->ieee8021MstpFidToMstiComponentId = componentId;
    table_entry->ieee8021MstpFidToMstiFid = vid;
    table_entry->ieee8021MstpFidToMstiMstId = msti_config.map.map[vid];
    return TRUE;
}

static BOOL IEEE8021MSTP_FidToMstiTableEntryByKey_get(ieee8021MstpFidToMstiTable_entry_t *table_entry)
{
    ieee8021MstpFidToMstiTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpFidToMstiFid ) {
        --tmp.ieee8021MstpFidToMstiFid;
    } else if ( tmp.ieee8021MstpFidToMstiComponentId ) {
        --tmp.ieee8021MstpFidToMstiComponentId;
        tmp.ieee8021MstpFidToMstiFid = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext ( &tmp ) ||
         tmp.ieee8021MstpFidToMstiComponentId != table_entry->ieee8021MstpFidToMstiComponentId ||
         tmp.ieee8021MstpFidToMstiFid != table_entry->ieee8021MstpFidToMstiFid ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_VlanTableEntryByKey_getnext(ieee8021MstpVlanTable_entry_t *table_entry)
{
    u_long vid = table_entry->ieee8021MstpVlanId, componentId = table_entry->ieee8021MstpVlanComponentId;
    mstp_msti_config_t msti_config;

    if ( componentId > 1 ) {
        return FALSE;
    }

    if ( componentId < 1 ) {
        componentId = 1;
        vid = 0;
    }

    if (vtss_appl_mstp_msti_config_get (&msti_config, NULL) != VTSS_RC_OK) {
        return FALSE;
    }

    /* Skip CIST(MSTI-0) instance */
    do {
        if (FALSE == IEEE8021MSTP_getnext_vlanId(&vid)) {
            return FALSE;
        }
    } while (msti_config.map.map[vid] == 0);

    table_entry->ieee8021MstpVlanComponentId = componentId;
    table_entry->ieee8021MstpVlanId = vid;
    table_entry->ieee8021MstpVlanMstId = msti_config.map.map[vid];
    return TRUE;
}

static BOOL IEEE8021MSTP_VlanTableEntryByKey_get(ieee8021MstpVlanTable_entry_t *table_entry)
{
    ieee8021MstpVlanTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpVlanId ) {
        --tmp.ieee8021MstpVlanId;
    } else if ( tmp.ieee8021MstpVlanComponentId ) {
        --tmp.ieee8021MstpVlanComponentId;
        tmp.ieee8021MstpVlanId = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_VlanTableEntryByKey_getnext ( &tmp) ||
         tmp.ieee8021MstpVlanComponentId != table_entry->ieee8021MstpVlanComponentId ||
         tmp.ieee8021MstpVlanId != table_entry->ieee8021MstpVlanId ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_PortTableEntryByDot1Port_get(ieee8021MstpPortTable_entry_t *table_entry, mstp_port_mgmt_status_t *status, dot1Port_info_t *info)
{
    mstp_msti_port_param_t  pconf;

    table_entry->ieee8021MstpPortUptime = status->core.uptime;

    if (vtss_mstp_msti_port_config_get (info->isid, table_entry->ieee8021MstpPortMstId, info->if_id, &pconf) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->ieee8021MstpPortPriority = pconf.adminPortPriority;
    table_entry->ieee8021MstpPortPathCost = pconf.adminPathCost;
    table_entry->ieee8021MstpPortDesignatedRoot_len = SNMP_BRIDGEID_LEN;
    table_entry->ieee8021MstpPortDesignatedBridge_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpPortDesignatedRoot,
            status->core.designatedRoot, SNMP_BRIDGEID_LEN);
    table_entry->ieee8021MstpPortDesignatedCost = status->core.designatedCost;
    memcpy (table_entry->ieee8021MstpPortDesignatedBridge,
            status->core.designatedBridge, SNMP_BRIDGEID_LEN);

    table_entry->ieee8021MstpPortDesignatedPort = ((uint32_t)status->core.designatedPort[0] << 8) |
                                                  ((uint32_t)status->core.designatedPort[1] << 0);

    if (strcasecmp (status->core.statestr, "Discarding") == 0) {
        table_entry->ieee8021MstpPortState = 5;
    } else if (strcasecmp (status->core.statestr, "Disabled") == 0) {
        table_entry->ieee8021MstpPortState = 1;
    } else if (strcasecmp (status->core.statestr, "Forwarding") == 0) {
        table_entry->ieee8021MstpPortState = 4;
    } else if (strcasecmp (status->core.statestr, "Learning") == 0) {
        table_entry->ieee8021MstpPortState = 3;
    }

    if (strcasecmp (status->core.rolestr, "rootport") == 0 ) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_ROOT_PORT;
    } else if (strcasecmp (status->core.rolestr, "alternateport") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_ALTERNATE_PORT;
    } else if (strcasecmp (status->core.rolestr, "designatedport") == 0 || strcasecmp(status->core.rolestr, "MasterPort") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_DESIGNATE_PORT;
    } else if (strcasecmp (status->core.rolestr, "backupport") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_BACKUP_PORT;
    } else {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_PORT_ERROR;  //error.
    }
    table_entry->ieee8021MstpPortDisputed = status->core.disputed;
    table_entry->active = status->active;

    return TRUE;
}

static BOOL IEEE8021MSTP_CistTableEntryByKey_get (ieee8021MstpCistTable_entry_t *table_entry)
{
    mstp_bridge_status_t status;
    BOOL                 rc = FALSE;

    if (table_entry->ieee8021MstpCistComponentId != 1) {
        return FALSE;
    }
    rc = (vtss_appl_mstp_bridge_status_get (MSTID_CIST, &status) == VTSS_RC_OK);

    T_D("ieee8021MstpCistComponentId = %lu, rc = %s", table_entry->ieee8021MstpCistComponentId,
        rc ? "TRUE" : "FALSE");
    if (rc == FALSE) {
        T_E("mstp_get_bridge_status fail");
        return FALSE;
    }

    table_entry->ieee8021MstpCistBridgeIdentifier_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpCistBridgeIdentifier, status.bridgeId,
            table_entry->ieee8021MstpCistBridgeIdentifier_len);
    table_entry->ieee8021MstpCistTopologyChange = status.topologyChange ? 1 : 2;

    table_entry->ieee8021MstpCistRegionalRootIdentifier_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpCistRegionalRootIdentifier,
            status.cistRegionalRoot, table_entry->ieee8021MstpCistRegionalRootIdentifier_len);
    table_entry->ieee8021MstpCistPathCost = status.rootPathCost;
    table_entry->ieee8021MstpCistMaxHops = (u32) status.maxHops;

    return TRUE;

}

static BOOL IEEE8021MSTP_CistTableEntryByKey_getnext (ieee8021MstpCistTable_entry_t *table_entry)
{
    ieee8021MstpCistTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpCistComponentId >= 1 ) {
        return FALSE;
    }

    tmp.ieee8021MstpCistComponentId++ ;

    (void) IEEE8021MSTP_CistTableEntryByKey_get ( &tmp);
    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_PortTableEntryByKey_getnext ( ieee8021MstpPortTable_entry_t *table_entry )
{
    u8                          msti = table_entry->ieee8021MstpPortMstId;
    mstp_port_mgmt_status_t     status;
    dot1Port_info_t             info;
    BOOL                        found = FALSE;
    if (table_entry->ieee8021MstpPortComponentId > 1 ||
        (table_entry->ieee8021MstpPortComponentId == 1 && table_entry->ieee8021MstpPortMstId > N_MSTI_MAX) ) {
        return FALSE;
    }


    if (table_entry->ieee8021MstpPortComponentId < 1 ) {
        msti = 1;
        info.dot1port = 0;
    } else {
        msti = table_entry->ieee8021MstpPortMstId;
        info.dot1port = table_entry->ieee8021MstpPortNum;
    }


    T_D("msti = %d, dot1port = %d", msti, info.dot1port);
    while ( msti < N_MSTI_MAX ) {
        while ( TRUE == ( found = dot1Port_get_next( &info )) ) {
            break;
        }
        if ( TRUE == found ) {
            break;
        }
        msti++;
        info.dot1port = 0;
    }

    if ( FALSE == found ) {
        return FALSE;
    }

    if ( FALSE == mstp_get_port_status ( msti, info.dot1port - 1, &status) ) {
        memset( &status, 0, sizeof(status));
    }

    table_entry->ieee8021MstpPortComponentId = 1;
    table_entry->ieee8021MstpPortMstId = msti;
    table_entry->ieee8021MstpPortNum = info.dot1port;

    (void) IEEE8021MSTP_PortTableEntryByDot1Port_get(table_entry, &status, &info);

    return TRUE;

}

static BOOL IEEE8021MSTP_PortTableEntryByKey_get ( ieee8021MstpPortTable_entry_t *table_entry )
{
    ieee8021MstpPortTable_entry_t tmp = *table_entry;
    if ( table_entry->ieee8021MstpPortNum ) {
        --tmp.ieee8021MstpPortNum;
    } else if ( table_entry->ieee8021MstpPortMstId ) {
        --tmp.ieee8021MstpPortMstId;
        tmp.ieee8021MstpPortNum = 0xffffffff;
    } else if ( table_entry->ieee8021MstpPortComponentId ) {
        --table_entry->ieee8021MstpPortComponentId;
        tmp.ieee8021MstpPortMstId = 0xffffffff;
        tmp.ieee8021MstpPortNum = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_PortTableEntryByKey_getnext( &tmp ) ||
         tmp.ieee8021MstpPortComponentId != table_entry->ieee8021MstpPortComponentId ||
         tmp.ieee8021MstpPortMstId != table_entry->ieee8021MstpPortMstId ||
         tmp.ieee8021MstpPortNum != table_entry->ieee8021MstpPortNum ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;

}

static BOOL IEEE8021MSTP_ConfigIdTableEntryByKey_get (ieee8021MstpConfigIdTable_entry_t *table_entry)
{
    mstp_msti_config_t msti_config;
    u8                 config_digest[SNMP_MSTP_CFG_DIGEST_MAX];
    u8                 *ptr = (u8 *) table_entry->ieee8021MstpConfigurationName;

    if ( 1 != table_entry->ieee8021MstpConfigIdComponentId ) {
        return FALSE;
    }

    if (vtss_appl_mstp_msti_config_get (&msti_config,
                                        config_digest) != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->ieee8021MstpConfigIdFormatSelector = 0;
    /* 802.1Q std implementation */
    table_entry->ieee8021MstpConfigurationName_len = 32;
    table_entry->ieee8021MstpConfigurationDigest_len = SNMP_MSTP_CFG_DIGEST_MAX;
    strncpy ((char *)table_entry->ieee8021MstpConfigurationName,
             (char *)msti_config.configname,
             strnlen(msti_config.configname, 32));
    ptr += strnlen(table_entry->ieee8021MstpConfigurationName, 32);
    memset(ptr, 0x20, 32 - (ptr - (u8 *) table_entry->ieee8021MstpConfigurationName));
    strncpy((char *)table_entry->ieee8021MstpConfigurationDigest, (char *)config_digest, SNMP_MSTP_CFG_DIGEST_MAX);
    table_entry->ieee8021MstpRevisionLevel = msti_config.revision;

    return TRUE;
}

static BOOL IEEE8021MSTP_ConfigIdTableEntryByKey_getnext (ieee8021MstpConfigIdTable_entry_t *table_entry)
{
    ieee8021MstpConfigIdTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpConfigIdComponentId >= 1 ) {
        return FALSE;
    }

    tmp.ieee8021MstpConfigIdComponentId++ ;

    (void) IEEE8021MSTP_ConfigIdTableEntryByKey_get ( &tmp);
    *table_entry = tmp;
    return TRUE;
}


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-MSTP-MIB:ieee8021MstpMib.
  **/
void
ieee8021MstpMib_init(void)
{
    oid             ieee8021MstpMib_oid[] = { 1, 3, 111, 2, 802, 1, 1, 6 };

    T_D("enter");

    // Register mibContextTable
    mibContextTable_register(ieee8021MstpMib_oid,
                             sizeof(ieee8021MstpMib_oid) / sizeof(oid),
                             "IEEE8021-MSTP-MIB : ieee8021MstpMib");

    ucd_snmp_init_ieee8021MstpMib();
    if (mstp_register_trap_sink(send_mstp_trap) != TRUE) {
        T_D("Could not register to MSTP Traps\n");
    }

    T_D("exit");
}

static void send_mstp_trap(u32 event_mask)
{
    int event = 1;
    if (event_mask & (event << (int) MSTP_TRAP_NEW_ROOT)) {
        snmp_new_root_notification();
    }
    if (event_mask & (event << (int) MSTP_TRAP_TOPOLOGY_CHANGE)) {
        snmp_topology_change_notification();
    }
}

static void snmp_new_root_notification(void)
{
    oid new_root_notifications_oid[] = {1, 3, 6, 1, 2, 1, 17, 0, 0};
    snmp_vars_trap_entry_t  trap_entry;

    T_D("Notification Change called for new Root detection");

    // Transmit the SNMP trap
    memset (&trap_entry, 0x0, sizeof(trap_entry));
    strncpy(trap_entry.name, TRAP_NAME_NEW_ROOT, TRAP_MAX_TABLE_NAME_LEN);
    trap_entry.oid_len = OID_LENGTH(new_root_notifications_oid);
    new_root_notifications_oid[ trap_entry.oid_len - 1 ] = NEWROOTTRAPINST;
    memcpy (trap_entry.oid, new_root_notifications_oid,
            sizeof(oid) * trap_entry.oid_len);

    trap_entry.vars = NULL ;

    snmp_send_vars_trap(&trap_entry);
}

static void snmp_topology_change_notification(void)
{
    oid topology_change_notifications_oid[] = {1, 3, 6, 1, 2, 1, 17, 0, 0};
    snmp_vars_trap_entry_t  trap_entry;

    T_D("Notification Change called for Topology change detection");

    // Transmit the SNMP trap
    memset(&trap_entry, 0x0, sizeof(trap_entry));
    strncpy(trap_entry.name, TRAP_NAME_TOPO_CHNG, TRAP_MAX_TABLE_NAME_LEN);
    trap_entry.oid_len = OID_LENGTH(topology_change_notifications_oid);
    topology_change_notifications_oid[ trap_entry.oid_len - 1 ] = TOPOLOGYCHANGETRAPINST;
    memcpy(trap_entry.oid, topology_change_notifications_oid,
           sizeof(oid) * trap_entry.oid_len);

    trap_entry.vars = NULL ;

    snmp_send_vars_trap(&trap_entry);
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_getfirst(ieee8021MstpCistTable_entry_t *
                                    table_entry)
{
    T_D("enter");

    table_entry->ieee8021MstpCistComponentId = 0;
    T_D("ieee8021MstpCistComponentId = %lu", table_entry->ieee8021MstpCistComponentId);
    T_D("exit");
    return TRUE == IEEE8021MSTP_CistTableEntryByKey_getnext (table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_get(ieee8021MstpCistTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_CistTableEntryByKey_getnext ( table_entry) ) ||
         (!getnext && FALSE == IEEE8021MSTP_CistTableEntryByKey_get ( table_entry)) ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_set(ieee8021MstpCistTable_entry_t *table_entry)
{
    mstp_bridge_param_t bridge_params;

    T_D("enter");

    if (vtss_appl_mstp_system_config_get(&bridge_params) != VTSS_RC_OK ) {
        return -1;
    }

    bridge_params.MaxHops = table_entry->ieee8021MstpCistMaxHops;
    if (vtss_appl_mstp_system_config_set(&bridge_params) != VTSS_RC_OK) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_getfirst(ieee8021MstpTable_entry_t *table_entry)
{

    T_N("enter");
    table_entry->ieee8021MstpId = 0;
    T_N("exit");
    return TRUE == IEEE8021MSTP_TableEntryByKey_getnext( table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_get(ieee8021MstpTable_entry_t *table_entry,
                           int getnext)
{
    T_N("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_TableEntryByKey_getnext( table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_TableEntryByKey_get( table_entry))) {
        return -1;
    }

    T_N("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_set(ieee8021MstpTable_entry_t *table_entry)
{
    u8 priority = 0;

    T_D("enter");

    if (table_entry == NULL) {
        return -1;
    }

    /* According to 802.1d standard, valid bridge priorities are in the range 0 through 61440,
       in steps of 4096.*/
    if ((table_entry->ieee8021MstpBridgePriority < 0) ||
        (table_entry->ieee8021MstpBridgePriority > 61440) ||
        (table_entry->ieee8021MstpBridgePriority % 4096)) {
        return -1;
    }

    priority = (u8) (table_entry->ieee8021MstpBridgePriority >> 8);
    if ( vtss_mstp_msti_priority_set ((u8) table_entry->ieee8021MstpId, priority ) != VTSS_RC_OK) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_getfirst(ieee8021MstpCistPortTable_entry_t *
                                        table_entry)
{
    T_N("enter");
    table_entry->ieee8021MstpCistPortComponentId = 0;
    table_entry->ieee8021MstpCistPortNum = 0;
    T_N("exit");
    return TRUE == IEEE8021MSTP_CistPortTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_get(ieee8021MstpCistPortTable_entry_t *
                                   table_entry, int getnext)
{
    T_N("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_CistPortTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_CistPortTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_N("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_set(ieee8021MstpCistPortTable_entry_t *
                                   table_entry)
{
    dot1Port_info_t   info;
    mstp_msti_port_param_t port_parm;
    mstp_port_param_t pconf;
    BOOL              enable;

    T_N("enter");

    info.dot1port = table_entry->ieee8021MstpCistPortNum;
    ( void ) dot1Port_get(&info);

    if (vtss_mstp_msti_port_config_get( info.isid, MSTID_CIST,
                                        info.if_id, &port_parm ) != VTSS_RC_OK) {
        return -1;
    }
    if (vtss_mstp_port_config_get (info.isid, info.if_id,
                                   &enable, &pconf) != VTSS_RC_OK) {
        return -1;
    }

    port_parm.adminPathCost     = table_entry->ieee8021MstpCistPortAdminPathCost;
    pconf.adminEdgePort         = table_entry->ieee8021MstpCistPortAdminEdgePort == 1 ? TRUE : FALSE;
    pconf.restrictedRole        = table_entry->ieee8021MstpCistPortRestrictedRole == 1 ? TRUE : FALSE;
    pconf.restrictedTcn         = table_entry->ieee8021MstpCistPortRestrictedTcn == 1 ? TRUE : FALSE;
    pconf.adminPointToPointMAC  = table_entry->ieee8021MstpCistPortMacEnabled == 1 ? P2P_AUTO : P2P_FORCEFALSE;
    pconf.bpduGuard             = table_entry->ieee8021MstpCistPortEnableBPDURx == 1 ? FALSE : TRUE;
    if (vtss_mstp_msti_port_config_set ( info.isid, MSTID_CIST, info.if_id, &port_parm) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    } /* end of if */
    if (vtss_mstp_port_config_set (info.isid, info.if_id,
                                   enable, &pconf) != VTSS_RC_OK) {
        return -1;
    }

    T_N("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_getfirst(ieee8021MstpPortTable_entry_t *
                                    table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpPortComponentId    = 0;
    table_entry->ieee8021MstpPortMstId          = 0;
    table_entry->ieee8021MstpPortNum            = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_PortTableEntryByKey_getnext ( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_get(ieee8021MstpPortTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_PortTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_PortTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_set(ieee8021MstpPortTable_entry_t *table_entry)
{

    dot1Port_info_t        info;
    mstp_msti_port_param_t pconf;

    T_D("enter");

    info.dot1port = table_entry->ieee8021MstpPortNum;
    ( void ) dot1Port_get( &info );

    if (vtss_mstp_msti_port_config_get (info.isid, table_entry->ieee8021MstpPortMstId, info.if_id,
                                        &pconf) != VTSS_RC_OK ) {
        return -1;
    }

    pconf.adminPortPriority = table_entry->ieee8021MstpPortPriority;
    pconf.adminPathCost = table_entry->ieee8021MstpPortPathCost;
    if (vtss_mstp_msti_port_config_set (info.isid, table_entry->ieee8021MstpPortMstId, info.if_id,
                                        &pconf) != VTSS_RC_OK ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_getfirst(ieee8021MstpFidToMstiTable_entry_t
                                         * table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpFidToMstiComponentId = 0;
    table_entry->ieee8021MstpFidToMstiFid = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_get(ieee8021MstpFidToMstiTable_entry_t *
                                    table_entry, int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_set(ieee8021MstpFidToMstiTable_entry_t *
                                    table_entry)
{
    mstp_msti_config_t msti_config;

    T_D("enter");

    if (vtss_appl_mstp_msti_config_get (&msti_config, NULL) != VTSS_RC_OK) {
        return -1;
    }

    msti_config.map.map[table_entry->ieee8021MstpFidToMstiFid] = N_MSTI_MAX == table_entry->ieee8021MstpFidToMstiMstId ?
                                                                 0 : table_entry->ieee8021MstpFidToMstiMstId;
    if (vtss_appl_mstp_msti_config_set (&msti_config) != VTSS_RC_OK) {
        return -1;
    } /* end of if */

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpVlanTableEntry_getfirst(ieee8021MstpVlanTable_entry_t *
                                    table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpVlanComponentId = 0;
    table_entry->ieee8021MstpVlanId = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_VlanTableEntryByKey_getnext(table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpVlanTableEntry_get(ieee8021MstpVlanTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_VlanTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_VlanTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_getfirst(ieee8021MstpConfigIdTable_entry_t *
                                        table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpConfigIdComponentId = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_ConfigIdTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_get(ieee8021MstpConfigIdTable_entry_t *
                                   table_entry, int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_ConfigIdTableEntryByKey_getnext( table_entry )) ||
         (!getnext && FALSE == IEEE8021MSTP_ConfigIdTableEntryByKey_get( table_entry ))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_set(ieee8021MstpConfigIdTable_entry_t *
                                   table_entry)
{
    mstp_msti_config_t  msti_config;
    u8                  *ptr = (u8 *) table_entry->ieee8021MstpConfigurationName;
    size_t              configname_len = 0;

    T_D("enter");

    /* According to IEEE8021-MSTP-MIB, the ConfiguraionName is fixed-length string,
       SNMP handler will append space character if the string length got from MSTP module
       is less than 32. So when SNMP set the instance, the space characters need to be trimmed
       before applying to MSTP module.
    */
    while (*ptr++ != 0x20 && ptr != NULL && configname_len < VTSS_APPL_MSTP_CONFIG_NAME_MAXLEN) {
        configname_len++;
    }

    T_D("The string length is %lu", (unsigned long ) configname_len);
    if (vtss_appl_mstp_msti_config_get (&msti_config, NULL) == VTSS_RC_OK) {
        memcpy(msti_config.configname, table_entry->ieee8021MstpConfigurationName,
               configname_len);
        if (configname_len != VTSS_APPL_MSTP_CONFIG_NAME_MAXLEN) {
            msti_config.configname[configname_len] = '\0';
        }
        msti_config.revision = table_entry->ieee8021MstpRevisionLevel;
        if (vtss_appl_mstp_msti_config_set (&msti_config) != VTSS_RC_OK) {
            return -1;
        }
    }

    T_D("exit");
    return 0;
}
