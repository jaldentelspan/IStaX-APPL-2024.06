/*
 Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

/*
 * * Note: this file originally auto-generated by mib2c using
 * *        : mib2c.old-api.conf,v 1.5 2010/07/19 09:20:45 annapurna Exp $
 */

#include <main.h>
#include <sys/param.h>

#if HAVE_STDLIB_H
#include <stdlib.h>
#endif  /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif  /* HAVE_STRING_H */

#include "mibContextTable.h"    //mibContextTable_register

#include <vtss/appl/ipmc_lib.h>
#include "vtss_os_wrapper_snmp.h"
#include "mgmdMIBObjects.h"

#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

/*
 *
 * * The entry data structure for mgmdHostInterfaceTable
 */
typedef struct {

    /*
    * Entry keys
    */
    long        mgmdHostInterfaceIfIndex;
    long        mgmdHostInterfaceQuerierType;

    /*
    * Entry columns
    */
    char            mgmdHostInterfaceQuerier[SPRINT_MAX_LEN];
    size_t mgmdHostInterfaceQuerier_len;
    long mgmdHostInterfaceStatus;
    u_long mgmdHostInterfaceVersion;
    u_long mgmdHostInterfaceVersion1QuerierTimer;
    u_long mgmdHostInterfaceVersion2QuerierTimer;
    u_long mgmdHostInterfaceVersion3Robustness;
} mgmdHostInterfaceTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterInterfaceTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterInterfaceIfIndex;
    long mgmdRouterInterfaceQuerierType;

    /*
     * Entry columns
     */
    char            mgmdRouterInterfaceQuerier[SPRINT_MAX_LEN];
    size_t mgmdRouterInterfaceQuerier_len;
    u_long mgmdRouterInterfaceQueryInterval;
    long mgmdRouterInterfaceStatus;
    u_long mgmdRouterInterfaceVersion;
    u_long mgmdRouterInterfaceQueryMaxResponseTime;
    u_long mgmdRouterInterfaceQuerierUpTime;
    u_long mgmdRouterInterfaceQuerierExpiryTime;
    u_long mgmdRouterInterfaceWrongVersionQueries;
    u_long mgmdRouterInterfaceJoins;
    long mgmdRouterInterfaceProxyIfIndex;
    u_long mgmdRouterInterfaceGroups;
    u_long mgmdRouterInterfaceRobustness;
    u_long mgmdRouterInterfaceLastMemberQueryInterval;
    u_long mgmdRouterInterfaceLastMemberQueryCount;
    u_long mgmdRouterInterfaceStartupQueryCount;
    u_long mgmdRouterInterfaceStartupQueryInterval;
} mgmdRouterInterfaceTable_entry_t;

/*
 *
 * * The entry data structure for mgmdHostCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdHostCacheAddressType;
    char mgmdHostCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdHostCacheAddress_len;
    long mgmdHostCacheIfIndex;

    /*
     * Entry columns
     */
    u_long mgmdHostCacheUpTime;
    char mgmdHostCacheLastReporter[SPRINT_MAX_LEN];
    size_t mgmdHostCacheLastReporter_len;
    long mgmdHostCacheSourceFilterMode;
} mgmdHostCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterCacheAddressType;
    char mgmdRouterCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterCacheAddress_len;
    long mgmdRouterCacheIfIndex;

    /*
     * Entry columns
     */
    char            mgmdRouterCacheLastReporter[SPRINT_MAX_LEN];
    size_t mgmdRouterCacheLastReporter_len;
    u_long mgmdRouterCacheUpTime;
    u_long mgmdRouterCacheExpiryTime;
    u_long mgmdRouterCacheExcludeModeExpiryTimer;
    u_long mgmdRouterCacheVersion1HostTimer;
    u_long mgmdRouterCacheVersion2HostTimer;
    long mgmdRouterCacheSourceFilterMode;
} mgmdRouterCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdInverseHostCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdInverseHostCacheIfIndex;
    long mgmdInverseHostCacheAddressType;
    char mgmdInverseHostCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdInverseHostCacheAddress_len;

    /*
     * Entry columns
     */
} mgmdInverseHostCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdInverseRouterCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdInverseRouterCacheIfIndex;
    long mgmdInverseRouterCacheAddressType;
    char mgmdInverseRouterCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdInverseRouterCacheAddress_len;

    /*
     * Entry columns
     */
} mgmdInverseRouterCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdHostSrcListTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdHostSrcListAddressType;
    char mgmdHostSrcListAddress[SPRINT_MAX_LEN];
    size_t mgmdHostSrcListAddress_len;
    long mgmdHostSrcListIfIndex;
    char mgmdHostSrcListHostAddress[SPRINT_MAX_LEN];
    size_t mgmdHostSrcListHostAddress_len;

    /*
     * Entry columns
     */
    u_long mgmdHostSrcListExpire;

} mgmdHostSrcListTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterSrcListTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterSrcListAddressType;
    char mgmdRouterSrcListAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterSrcListAddress_len;
    long mgmdRouterSrcListIfIndex;
    char mgmdRouterSrcListHostAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterSrcListHostAddress_len;

    /*
     * Entry columns
     */
    u_long mgmdRouterSrcListExpire;

} mgmdRouterSrcListTable_entry_t;

/*
 *
 * * The return data structure
 */
typedef struct {

    long           long_ret;
    char string_ret[SPRINT_MAX_LEN];
    u_long ulong_ret;
} ucdSnmp_return_t;

/*
 *
 * * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ucdSnmp_return_t global_ret;     /* static variables for retuning */

/*
 *
 * * mgmdMIBObjects_variables_oid:
 * *   this is the top level oid that we want to register under.  This
 * *   is essentially a prefix, with the suffix appearing in the
 * *   variable below.
 */

oid mgmdMIBObjects_variables_oid[] = {
    1, 3, 6, 1, 2, 1, 185, 1
};

/*
 *
 * * variable mgmdMIBObjects_variables:
 * *   this variable defines function callbacks and type return information
 * *   for the mgmdMIBObjects mib section
 */

struct variable4 mgmdMIBObjects_variables[] = {
    /*
     *
     * * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define MGMDHOSTINTERFACEQUERIER        1
    {
        MGMDHOSTINTERFACEQUERIER, ASN_OCTET_STR, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 3}
    },
#define MGMDHOSTINTERFACESTATUS     2
    {
        MGMDHOSTINTERFACESTATUS, ASN_INTEGER, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 4}
    },
#define MGMDHOSTINTERFACEVERSION        3
    {
        MGMDHOSTINTERFACEVERSION, ASN_UNSIGNED, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 5}
    },
#define MGMDHOSTINTERFACEVERSION1QUERIERTIMER       4
    {
        MGMDHOSTINTERFACEVERSION1QUERIERTIMER, ASN_TIMETICKS, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 6}
    },
#define MGMDHOSTINTERFACEVERSION2QUERIERTIMER       5
    {
        MGMDHOSTINTERFACEVERSION2QUERIERTIMER, ASN_TIMETICKS, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 7}
    },
#define MGMDHOSTINTERFACEVERSION3ROBUSTNESS     6
    {
        MGMDHOSTINTERFACEVERSION3ROBUSTNESS, ASN_UNSIGNED, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 8}
    },
#define MGMDROUTERINTERFACEQUERIER      7
    {
        MGMDROUTERINTERFACEQUERIER, ASN_OCTET_STR, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 3}
    },
#define MGMDROUTERINTERFACEQUERYINTERVAL        8
    {
        MGMDROUTERINTERFACEQUERYINTERVAL, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 4}
    },
#define MGMDROUTERINTERFACESTATUS       9
    {
        MGMDROUTERINTERFACESTATUS, ASN_INTEGER, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 5}
    },
#define MGMDROUTERINTERFACEVERSION      10
    {
        MGMDROUTERINTERFACEVERSION, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 6}
    },
#define MGMDROUTERINTERFACEQUERYMAXRESPONSETIME     11
    {
        MGMDROUTERINTERFACEQUERYMAXRESPONSETIME, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 7}
    },
#define MGMDROUTERINTERFACEQUERIERUPTIME        12
    {
        MGMDROUTERINTERFACEQUERIERUPTIME, ASN_TIMETICKS, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 8}
    },
#define MGMDROUTERINTERFACEQUERIEREXPIRYTIME        13
    {
        MGMDROUTERINTERFACEQUERIEREXPIRYTIME, ASN_TIMETICKS, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 9}
    },
#define MGMDROUTERINTERFACEWRONGVERSIONQUERIES      14
    {
        MGMDROUTERINTERFACEWRONGVERSIONQUERIES, ASN_COUNTER, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 10}
    },
#define MGMDROUTERINTERFACEJOINS        15
    {
        MGMDROUTERINTERFACEJOINS, ASN_COUNTER, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 11}
    },
#define MGMDROUTERINTERFACEPROXYIFINDEX     16
    {
        MGMDROUTERINTERFACEPROXYIFINDEX, ASN_INTEGER, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 12}
    },
#define MGMDROUTERINTERFACEGROUPS       17
    {
        MGMDROUTERINTERFACEGROUPS, ASN_GAUGE, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 13}
    },
#define MGMDROUTERINTERFACEROBUSTNESS       18
    {
        MGMDROUTERINTERFACEROBUSTNESS, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 14}
    },
#define MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL      19
    {
        MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 15}
    },
#define MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT     20
    {
        MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 16}
    },
#define MGMDROUTERINTERFACESTARTUPQUERYCOUNT        21
    {
        MGMDROUTERINTERFACESTARTUPQUERYCOUNT, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 17}
    },
#define MGMDROUTERINTERFACESTARTUPQUERYINTERVAL     22
    {
        MGMDROUTERINTERFACESTARTUPQUERYINTERVAL, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 18}
    },
    /*#define MGMDHOSTCACHEUPTIME       23
        {MGMDHOSTCACHEUPTIME, ASN_TIMETICKS, RONLY, var_mgmdHostCacheTable, 3,
         {3, 1, 4}},
    #define MGMDHOSTCACHELASTREPORTER       24
        {MGMDHOSTCACHELASTREPORTER, ASN_OCTET_STR, RONLY,
         var_mgmdHostCacheTable, 3, {3, 1, 5}},
    #define MGMDHOSTCACHESOURCEFILTERMODE       25
        {MGMDHOSTCACHESOURCEFILTERMODE, ASN_INTEGER, RONLY,
         var_mgmdHostCacheTable, 3, {3, 1, 6}},
    #define MGMDROUTERCACHELASTREPORTER     26
        {MGMDROUTERCACHELASTREPORTER, ASN_OCTET_STR, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 4}},
    #define MGMDROUTERCACHEUPTIME       27
        {MGMDROUTERCACHEUPTIME, ASN_TIMETICKS, RONLY, var_mgmdRouterCacheTable,
         3, {4, 1, 5}},
    #define MGMDROUTERCACHEEXPIRYTIME       28
        {MGMDROUTERCACHEEXPIRYTIME, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 6}},
    #define MGMDROUTERCACHEEXCLUDEMODEEXPIRYTIMER       29
        {MGMDROUTERCACHEEXCLUDEMODEEXPIRYTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 7}},
    #define MGMDROUTERCACHEVERSION1HOSTTIMER        30
        {MGMDROUTERCACHEVERSION1HOSTTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 8}},
    #define MGMDROUTERCACHEVERSION2HOSTTIMER        31
        {MGMDROUTERCACHEVERSION2HOSTTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 9}},
    #define MGMDROUTERCACHESOURCEFILTERMODE     32
        {MGMDROUTERCACHESOURCEFILTERMODE, ASN_INTEGER, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 10}},
    #define MGMDINVERSEHOSTCACHEADDRESS     33
        {MGMDINVERSEHOSTCACHEADDRESS, ASN_OCTET_STR, RONLY,
         var_mgmdInverseHostCacheTable, 3, {5, 1, 3}},
    #define MGMDINVERSEROUTERCACHEADDRESS       34
        {MGMDINVERSEROUTERCACHEADDRESS, ASN_OCTET_STR, RONLY,
         var_mgmdInverseRouterCacheTable, 3, {6, 1, 3}},
    #define MGMDHOSTSRCLISTEXPIRE       35
        {MGMDHOSTSRCLISTEXPIRE, ASN_TIMETICKS, RONLY, var_mgmdHostSrcListTable,
         3, {7, 1, 5}},
    #define MGMDROUTERSRCLISTEXPIRE     36
        {MGMDROUTERSRCLISTEXPIRE, ASN_TIMETICKS, RONLY,
         var_mgmdRouterSrcListTable, 3, {8, 1, 5}}, */
};

/*
 *
 * * Initializes the mgmdMIBObjects module
 */
void
init_mgmdMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(mgmdMIBObjects_variables_oid,
                             sizeof(mgmdMIBObjects_variables_oid) / sizeof(oid),
                             "MGMD-MIB : mgmdMIBObjects");

    DEBUGMSGTL(("mgmdMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("mgmdMIBObjects", mgmdMIBObjects_variables, variable4, mgmdMIBObjects_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/******************************************************************************/
// vlan_key_get()
/******************************************************************************/
static bool vlan_key_get(vtss_appl_ipmc_lib_vlan_key_t &vlan_key, mesa_vid_t vid, mesa_ip_type_t ip_type, bool get_next)
{
    vtss_clear(vlan_key);

    if (get_next) {
#ifdef VTSS_SW_OPTION_SMB_IPMC
        // We need to toggle between IPv4 and IPv6 for the same VLAN.
        // The following only works because we know that both IGMP and MLD
        // entries are created whenever a VLAN interface is created.
        if (ip_type == MESA_IP_TYPE_NONE) {
            // Get-next on NONE::VID means get-next on IPv4::VID - 1
            vlan_key.is_ipv4 = true;
            vlan_key.vid     = vid ? vid - 1 : 0;
        } else if (ip_type == MESA_IP_TYPE_IPV4) {
            // Get-next on IPv4::VID means get-next on IPv6::VID - 1
            vlan_key.is_ipv4 = false;
            vlan_key.vid     = vid ? vid - 1 : 0;
        } else if (ip_type == MESA_IP_TYPE_IPV6) {
            // Get-next on IPv6::VID means get-next on IPv4::VID
            vlan_key.is_ipv4 = true;
            vlan_key.vid     = vid;
        } else {
            // Get-next on Unknown::VID means get-next on IPv4::VID
            vlan_key.is_ipv4 = true;
            vlan_key.vid     = vid;
        }
#else
        // IPv6 not supported.
        if (ip_type == MESA_IP_TYPE_NONE) {
            // Get-next on NONE::VID means get-next on IPv4::VID - 1
            vlan_key.is_ipv4 = true;
            vlan_key.vid     = vid ? vid - 1 : 0;
        } else {
            // Get-next on IPv4::VID, IPv6::VID, or Unknown::VID means get-next
            // on IPv4::VID
            vlan_key.is_ipv4 = true;
            vlan_key.vid     = vid;
        }
#endif

        if (vtss_appl_ipmc_lib_vlan_itr(&vlan_key, &vlan_key, true) != VTSS_RC_OK) {
            return false;
        }
    } else {
#ifdef VTSS_SW_OPTION_SMB_IPMC
        if (ip_type != MESA_IP_TYPE_IPV4 && ip_type != MESA_IP_TYPE_IPV6) {
            return false;
        }
#else
        if (ip_type != MESA_IP_TYPE_IPV4) {
            return false;
        }
#endif

        vlan_key.is_ipv4 = ip_type == MESA_IP_TYPE_IPV4;
        vlan_key.vid     = vid;
    }

    return true;
}

BOOL get_mgmdHostInterfaceTable_entry(vtss_appl_ipmc_lib_vlan_key_t &vlan_key, mgmdHostInterfaceTable_entry_t &entry)
{
    vtss_appl_ipmc_lib_global_conf_t global_conf;
    vtss_appl_ipmc_lib_vlan_conf_t   vlan_conf;
    vtss_appl_ipmc_lib_vlan_status_t vlan_status;
    vtss_ifindex_t                   ifindex;

    if (vtss_appl_ipmc_lib_global_conf_get(static_cast<vtss_appl_ipmc_lib_key_t>(vlan_key), &global_conf) != VTSS_RC_OK ||
        vtss_appl_ipmc_lib_vlan_conf_get(  vlan_key,                                        &vlan_conf)   != VTSS_RC_OK ||
        vtss_appl_ipmc_lib_vlan_status_get(vlan_key,                                        &vlan_status) != VTSS_RC_OK) {
        return FALSE;
    }

    vtss_clear(entry);

    if ((global_conf.proxy_enable || global_conf.leave_proxy_enable) && vlan_conf.admin_active) {
        entry.mgmdHostInterfaceStatus = SNMP_ROW_ACTIVE;
    } else {
        entry.mgmdHostInterfaceStatus = SNMP_ROW_NOTINSERVICE;
    }

    entry.mgmdHostInterfaceVersion3Robustness = vlan_conf.rv;
    if (vlan_key.is_ipv4) {
        memcpy(entry.mgmdHostInterfaceQuerier, &vlan_status.active_querier_address.ipv4, sizeof(mesa_ipv4_t));
        entry.mgmdHostInterfaceQuerier_len = sizeof(mesa_ipv4_t);

        if (vlan_status.querier_compat == VTSS_APPL_IPMC_LIB_COMPATIBILITY_OLD) {   /* IGMPv1 */
            entry.mgmdHostInterfaceVersion1QuerierTimer = vlan_status.older_version_querier_present_timeout_old * 100; // Seconds -> 1/100 of a second
        } else if (vlan_status.querier_compat == VTSS_APPL_IPMC_LIB_COMPATIBILITY_GEN) {   /* IGMPv2 */
            entry.mgmdHostInterfaceVersion2QuerierTimer = vlan_status.older_version_querier_present_timeout_gen * 100; // Seconds -> 1/100 of a second
        }
    } else {
        memcpy(entry.mgmdHostInterfaceQuerier, &vlan_status.active_querier_address.ipv6, sizeof(mesa_ipv6_t));
        entry.mgmdHostInterfaceQuerier_len = sizeof(mesa_ipv6_t);

        if (vlan_status.querier_compat == VTSS_APPL_IPMC_LIB_COMPATIBILITY_GEN) {   /* MLDv1 */
            entry.mgmdHostInterfaceVersion2QuerierTimer = vlan_status.older_version_querier_present_timeout_gen;
        }
    }

    (void)vtss_ifindex_from_vlan(vlan_key.vid, &ifindex);

    /* The maximum version of MGMD which the host can run on this interface. */
    entry.mgmdHostInterfaceVersion = 2;
    entry.mgmdHostInterfaceIfIndex = vtss_ifindex_cast_to_u32(ifindex);
    entry.mgmdHostInterfaceQuerierType = vlan_key.is_ipv4 ? MESA_IP_TYPE_IPV4 : MESA_IP_TYPE_IPV6;

    return TRUE;
}

static int getfirst_mgmdHostInterfaceTableEntry(mgmdHostInterfaceTable_entry_t *table_entry)
{
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;

    if (!table_entry) {
        return 1;
    }

    if (!vlan_key_get(vlan_key, 0, MESA_IP_TYPE_NONE, true)) {
        return 1;
    }

    if (!get_mgmdHostInterfaceTable_entry(vlan_key, *table_entry)) {
        return 1;
    }

    return 0;
}

static int get_mgmdHostInterfaceTableEntry(mgmdHostInterfaceTable_entry_t *table_entry, BOOL getnext)
{
    mesa_ip_type_t                ip_type;
    vtss_ifindex_t                ifindex;
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;
    vtss_ifindex_elm_t            ife;

    if (!table_entry) {
        return 1;
    }

    vtss_ifindex_cast_to_u32(ifindex) = table_entry->mgmdHostInterfaceIfIndex;
    if (vtss_ifindex_decompose(ifindex, &ife) != VTSS_RC_OK || ife.iftype != VTSS_IFINDEX_TYPE_VLAN) {
        ife.ordinal = table_entry->mgmdHostInterfaceIfIndex == 0 ? MESA_VID_NULL : MESA_VIDS;
    }

    ip_type = (mesa_ip_type_t)table_entry->mgmdHostInterfaceQuerierType;

    if (!vlan_key_get(vlan_key, ife.ordinal, ip_type, getnext)) {
        return 1;
    }

    if (!get_mgmdHostInterfaceTable_entry(vlan_key, *table_entry)) {
        return 1;
    }

    return 0;
}

static int
parse_mgmdHostInterfaceTable(oid *name,
                             size_t *length,
                             int exact,

                             mgmdHostInterfaceTable_entry_t *
                             table_entry)
{
    size_t         op_pos = 9 + 2;
    oid *op = (oid *) (name + op_pos);

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_mgmdHostInterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1;              /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->mgmdHostInterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (*length > op_pos) {
        table_entry->mgmdHostInterfaceQuerierType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_mgmdHostInterfaceTable(oid *name,
                               size_t *length,

                               mgmdHostInterfaceTable_entry_t *
                               table_entry)
{

    int            name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->mgmdHostInterfaceIfIndex;

    name[name_pos++] = (oid) table_entry->mgmdHostInterfaceQuerierType;

    *length = name_pos;

    return 0;

}

/*
 *
 * * var_mgmdHostInterfaceTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdHostInterfaceTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len,
                           WriteMethod **write_method)
{
    int            rc;
    oid newname[MAX_OID_LEN];
    size_t         newname_len;
    mgmdHostInterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;
    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_mgmdHostInterfaceTable(name, length, exact,
                                          &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {       /* getfirst */
        if (fillobj_mgmdHostInterfaceTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_mgmdHostInterfaceTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }

            if (fillobj_mgmdHostInterfaceTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }

            if (exact) {
                break;
            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;

    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case MGMDHOSTINTERFACEQUERIER: {
        memcpy(global_ret.string_ret,
               table_entry.mgmdHostInterfaceQuerier, table_entry.mgmdHostInterfaceQuerier_len);
        *var_len = table_entry.mgmdHostInterfaceQuerier_len;

        return (u_char *) global_ret.string_ret;
    }
    case MGMDHOSTINTERFACESTATUS: {
        *write_method = NULL;   //write_mgmdHostInterfaceStatus;
        global_ret.long_ret = table_entry.mgmdHostInterfaceStatus;
        *var_len = sizeof(global_ret.long_ret);

        return (u_char *) & global_ret.long_ret;
    }
    case MGMDHOSTINTERFACEVERSION: {
        *write_method = NULL;   //write_mgmdHostInterfaceVersion;
        global_ret.ulong_ret = table_entry.mgmdHostInterfaceVersion;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION1QUERIERTIMER: {
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion1QuerierTimer;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION2QUERIERTIMER: {
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion2QuerierTimer;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION3ROBUSTNESS: {
        *write_method = NULL;   //write_mgmdHostInterfaceVersion3Robustness;
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion3Robustness;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdHostInterfaceTable\n",
                    vp->magic));
    }

    return NULL;
}

static u_long compat_to_ver(vtss_appl_ipmc_lib_compatibility_t compat, bool is_ipv4)
{
    switch (compat) {
    case VTSS_APPL_IPMC_LIB_COMPATIBILITY_OLD:
        return is_ipv4 ? 1 : 3;

    case VTSS_APPL_IPMC_LIB_COMPATIBILITY_GEN:
        return 2;

    default:
        return 3;
    }
}

static bool get_mgmdRouterInterfaceTable_entry(vtss_appl_ipmc_lib_vlan_key_t &vlan_key, mgmdRouterInterfaceTable_entry_t &entry)
{
    vtss_appl_ipmc_lib_global_conf_t     global_conf;
    vtss_appl_ipmc_lib_vlan_conf_t       vlan_conf;
    vtss_appl_ipmc_lib_vlan_status_t     vlan_status;
    vtss_appl_ipmc_lib_vlan_statistics_t vlan_statistics;
    vtss_ifindex_t                       ifindex;

    if (vtss_appl_ipmc_lib_global_conf_get(    static_cast<vtss_appl_ipmc_lib_key_t>(vlan_key), &global_conf)     != VTSS_RC_OK ||
        vtss_appl_ipmc_lib_vlan_conf_get(      vlan_key,                                        &vlan_conf)       != VTSS_RC_OK ||
        vtss_appl_ipmc_lib_vlan_status_get(    vlan_key,                                        &vlan_status)     != VTSS_RC_OK ||
        vtss_appl_ipmc_lib_vlan_statistics_get(vlan_key,                                        &vlan_statistics) != VTSS_RC_OK) {
        return false;
    }

    vtss_clear(entry);
    if (vlan_key.is_ipv4) {
        memcpy(entry.mgmdRouterInterfaceQuerier, &vlan_status.active_querier_address.ipv4, sizeof(mesa_ipv4_t));
        entry.mgmdRouterInterfaceQuerier_len = sizeof(mesa_ipv4_t);
    } else {
        memcpy(entry.mgmdRouterInterfaceQuerier, &vlan_status.active_querier_address.ipv6, sizeof(mesa_ipv6_t));
        entry.mgmdRouterInterfaceQuerier_len = sizeof(mesa_ipv6_t);
    }

    entry.mgmdRouterInterfaceQueryInterval = vlan_conf.qi;
    if (vlan_conf.admin_active) {
        entry.mgmdRouterInterfaceStatus = SNMP_ROW_ACTIVE;
    } else {
        entry.mgmdRouterInterfaceStatus = SNMP_ROW_NOTINSERVICE;
    }

    entry.mgmdRouterInterfaceVersion              = compat_to_ver(vlan_status.querier_compat, vlan_key.is_ipv4);
    entry.mgmdRouterInterfaceQueryMaxResponseTime = vlan_conf.qri;
    entry.mgmdRouterInterfaceQuerierUpTime        = vlan_status.querier_uptime * 100;            // Seconds -> 1/100 of a second
    entry.mgmdRouterInterfaceQuerierExpiryTime    = vlan_status.other_querier_expiry_time * 100; // Seconds -> 1/100 of a second
    entry.mgmdRouterInterfaceWrongVersionQueries  = vlan_statistics.rx_errors; /* We don't actually support this object. */

    if (vlan_key.is_ipv4) {
        entry.mgmdRouterInterfaceJoins = vlan_statistics.rx.igmp.utilized.v1_report + vlan_statistics.rx.igmp.ignored.v1_report +
                                         vlan_statistics.rx.igmp.utilized.v2_report + vlan_statistics.rx.igmp.ignored.v2_report +
                                         vlan_statistics.rx.igmp.utilized.v3_report + vlan_statistics.rx.igmp.ignored.v3_report;
    } else {
        entry.mgmdRouterInterfaceJoins = vlan_statistics.rx.mld.utilized.v1_report + vlan_statistics.rx.mld.ignored.v1_report +
                                         vlan_statistics.rx.mld.utilized.v2_report + vlan_statistics.rx.mld.ignored.v2_report;
    }

    (void)vtss_ifindex_from_vlan(vlan_key.vid, &ifindex);

    if (global_conf.proxy_enable || global_conf.leave_proxy_enable) {
        entry.mgmdRouterInterfaceProxyIfIndex = vtss_ifindex_cast_to_u32(ifindex);
    }

    entry.mgmdRouterInterfaceRobustness              = vlan_conf.rv;
    entry.mgmdRouterInterfaceLastMemberQueryInterval = vlan_conf.lmqi;
    entry.mgmdRouterInterfaceLastMemberQueryCount    = vlan_conf.rv;
    entry.mgmdRouterInterfaceStartupQueryCount       = vlan_conf.rv;
    entry.mgmdRouterInterfaceStartupQueryInterval    = vlan_conf.qi / 4;
    entry.mgmdRouterInterfaceIfIndex                 = vtss_ifindex_cast_to_u32(ifindex);
    entry.mgmdRouterInterfaceQuerierType             = vlan_key.is_ipv4 ? MESA_IP_TYPE_IPV4 : MESA_IP_TYPE_IPV6;

    return true;
}

static int getfirst_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *table_entry)
{
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;;

    if (!table_entry) {
        return 1;
    }

    if (!vlan_key_get(vlan_key, 0, MESA_IP_TYPE_NONE, true)) {
        return 1;
    }

    if (!get_mgmdRouterInterfaceTable_entry(vlan_key, *table_entry)) {
        return 1;
    }

    return 0;
}

static int get_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *table_entry, BOOL getnext)
{
    mesa_ip_type_t                ip_type;
    vtss_ifindex_t                ifindex;
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;
    vtss_ifindex_elm_t            ife;

    if (!table_entry) {
        return 1;
    }

    vtss_ifindex_cast_to_u32(ifindex) = table_entry->mgmdRouterInterfaceIfIndex;
    if (vtss_ifindex_decompose(ifindex, &ife) != VTSS_RC_OK || ife.iftype != VTSS_IFINDEX_TYPE_VLAN) {
        ife.ordinal = table_entry->mgmdRouterInterfaceIfIndex == 0 ? MESA_VID_NULL : MESA_VIDS;
    }

    ip_type = (mesa_ip_type_t)table_entry->mgmdRouterInterfaceQuerierType;

    if (!vlan_key_get(vlan_key, ife.ordinal, ip_type, getnext)) {
        return 1;
    }

    if (!get_mgmdRouterInterfaceTable_entry(vlan_key, *table_entry)) {
        return 1;
    }

    return 0;
}

static int
set_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *table_entry)
{
    vtss_appl_ipmc_lib_vlan_key_t  vlan_key;
    vtss_appl_ipmc_lib_vlan_conf_t vlan_conf;
    mesa_ip_type_t                 ip_type;
    vtss_ifindex_t                 ifindex;
    vtss_ifindex_elm_t             ife;

    if (!table_entry) {
        return 1;
    }

    vtss_ifindex_cast_to_u32(ifindex) = table_entry->mgmdRouterInterfaceIfIndex;
    if (vtss_ifindex_decompose(ifindex, &ife) != VTSS_RC_OK || ife.iftype != VTSS_IFINDEX_TYPE_VLAN) {
        return 1;
    }

    ip_type = (mesa_ip_type_t)table_entry->mgmdRouterInterfaceQuerierType;

#ifdef VTSS_SW_OPTION_IPMC
    if (ip_type != MESA_IP_TYPE_IPV4 && ip_type != MESA_IP_TYPE_IPV6) {
        return 1;
    }
#else
    if (ip_type != MESA_IP_TYPE_IPV4) {
        return 1;
    }
#endif

    vlan_key.is_mvr  = false;
    vlan_key.is_ipv4 = ip_type == MESA_IP_TYPE_IPV4;
    vlan_key.vid     = ife.ordinal;

    if (vtss_appl_ipmc_lib_vlan_conf_get(vlan_key, &vlan_conf) != VTSS_RC_OK) {
        return 1;
    }

    vlan_conf.rv           = table_entry->mgmdRouterInterfaceRobustness;
    vlan_conf.qi           = table_entry->mgmdRouterInterfaceQueryInterval;
    vlan_conf.qri          = table_entry->mgmdRouterInterfaceQueryMaxResponseTime;
    vlan_conf.lmqi         = table_entry->mgmdRouterInterfaceLastMemberQueryInterval;
    vlan_conf.admin_active = table_entry->mgmdRouterInterfaceStatus == SNMP_ROW_ACTIVE;

    if (vtss_appl_ipmc_lib_vlan_conf_set(vlan_key, &vlan_conf) != VTSS_RC_OK) {
        return SNMP_ERR_BADVALUE;
    }

    return 0;
}

static int
parse_mgmdRouterInterfaceTable(oid *name,
                               size_t *length,
                               int exact,

                               mgmdRouterInterfaceTable_entry_t *
                               table_entry)
{
    size_t         op_pos = 9 + 2;
    oid *op = (oid *) (name + op_pos);

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_mgmdRouterInterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1;              /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->mgmdRouterInterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (*length > op_pos) {
        table_entry->mgmdRouterInterfaceQuerierType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_mgmdRouterInterfaceTable(oid *name,
                                 size_t *length,
                                 mgmdRouterInterfaceTable_entry_t *
                                 table_entry)
{
    int            name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->mgmdRouterInterfaceIfIndex;
    name[name_pos++] = (oid) table_entry->mgmdRouterInterfaceQuerierType;

    *length = name_pos;
    return 0;
}

/*
 *
 * * var_mgmdRouterInterfaceTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdRouterInterfaceTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len,
                             WriteMethod **write_method)
{
    int            rc;
    oid newname[MAX_OID_LEN];
    size_t         newname_len;
    mgmdRouterInterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_mgmdRouterInterfaceTable(name, length, exact,
                                            &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {       /* getfirst */
        if (fillobj_mgmdRouterInterfaceTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_mgmdRouterInterfaceTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }

            if (fillobj_mgmdRouterInterfaceTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }

            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case MGMDROUTERINTERFACEQUERIER: {
        memcpy(global_ret.string_ret,
               table_entry.mgmdRouterInterfaceQuerier, table_entry.mgmdRouterInterfaceQuerier_len);
        *var_len = table_entry.mgmdRouterInterfaceQuerier_len;
        return (u_char *) global_ret.string_ret;
    }

    case MGMDROUTERINTERFACEQUERYINTERVAL: {
        *write_method = write_mgmdRouterInterfaceQueryInterval;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTATUS: {
        *write_method = write_mgmdRouterInterfaceStatus;
        global_ret.long_ret = table_entry.mgmdRouterInterfaceStatus;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }

    case MGMDROUTERINTERFACEVERSION: {
        *write_method = NULL;   //write_mgmdRouterInterfaceVersion;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceVersion;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERYMAXRESPONSETIME: {
        *write_method = write_mgmdRouterInterfaceQueryMaxResponseTime;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQueryMaxResponseTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERIERUPTIME: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQuerierUpTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERIEREXPIRYTIME: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQuerierExpiryTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEWRONGVERSIONQUERIES: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceWrongVersionQueries;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEJOINS: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceJoins;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEPROXYIFINDEX: {
        *write_method = NULL;   //write_mgmdRouterInterfaceProxyIfIndex;
        global_ret.long_ret = table_entry.mgmdRouterInterfaceProxyIfIndex;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }

    case MGMDROUTERINTERFACEGROUPS: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceGroups;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEROBUSTNESS: {
        *write_method = write_mgmdRouterInterfaceRobustness;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceRobustness;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL: {
        *write_method = write_mgmdRouterInterfaceLastMemberQueryInterval;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceLastMemberQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceLastMemberQueryCount;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTARTUPQUERYCOUNT: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceStartupQueryCount;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTARTUPQUERYINTERVAL: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceStartupQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdRouterInterfaceTable\n",
                    vp->magic));
    }

    return NULL;
}

int
write_mgmdRouterInterfaceQueryInterval(int action,
                                       u_char *var_val,

                                       u_char var_val_type,

                                       size_t var_val_len,

                                       u_char *statP,
                                       oid *name,

                                       size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryInterval: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryInterval: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /* Range: 1 - 31744 seconds */
        if (set_value < 1 || set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceQueryInterval = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }

    return SNMP_ERR_NOERROR;
}

int
write_mgmdRouterInterfaceStatus(int action,
                                u_char *var_val,

                                u_char var_val_type,
                                size_t var_val_len,

                                u_char *statP,
                                oid *name,

                                size_t name_len)
{

    long           set_value = var_val ? *((long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_INTEGER) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: not ASN_INTEGER\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(long)) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: bad value\n");

            return SNMP_ERR_WRONGVALUE;

        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceStatus = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }

    return SNMP_ERR_NOERROR;

}

int
write_mgmdRouterInterfaceQueryMaxResponseTime(int action,

                                              u_char *var_val,

                                              u_char var_val_type,

                                              size_t var_val_len,

                                              u_char *statP,
                                              oid *name,

                                              size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryMaxResponseTime: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryMaxResponseTime: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /* Range: 0 - 31744 tenths of seconds */
        if (set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceQueryMaxResponseTime = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }

    return SNMP_ERR_NOERROR;

}

int
write_mgmdRouterInterfaceRobustness(int action,
                                    u_char *var_val,

                                    u_char var_val_type,

                                    size_t var_val_len,
                                    u_char *statP,

                                    oid *name,
                                    size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceRobustness: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceRobustness: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /* Range: Packet loss tolerance count from 1 to 255, but 1 is not reasonable to be used. */
        if (set_value < 2 || set_value > 0xFF) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceRobustness = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }

    return SNMP_ERR_NOERROR;

}

int
write_mgmdRouterInterfaceLastMemberQueryInterval(int action,

                                                 u_char *var_val,

                                                 u_char var_val_type,

                                                 size_t var_val_len,

                                                 u_char *statP,

                                                 oid *name,

                                                 size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceLastMemberQueryInterval: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceLastMemberQueryInterval: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /* Range: 0 - 31744 tenths of seconds */
        if (set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }
    case UNDO: {
        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceLastMemberQueryInterval = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }

    return SNMP_ERR_NOERROR;

}
