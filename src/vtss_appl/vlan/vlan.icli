#
# Copyright (c) 2006-2022 Microsemi Corporation "Microsemi". All Rights Reserved.
#
# Unpublished rights reserved under the copyright laws of the United States of
# America, other countries and international treaties. Permission to use, copy,
# store and modify, the software and its source code is granted but only in
# connection with products utilizing the Microsemi switch and PHY products.
# Permission is also granted for you to integrate into other products, disclose,
# transmit and distribute the software only in an absolute machine readable
# format (e.g. HEX file) and only in or with products utilizing the Microsemi
# switch and PHY products.  The source code of the software may not be
# disclosed, transmitted or distributed without the prior written permission of
# Microsemi.
#
# This copyright notice must appear in any copy, modification, disclosure,
# transmission or distribution of the software.  Microsemi retains all
# ownership, copyright, trade secret and proprietary rights in the software and
# its source code, including all modifications thereto.
#
# THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
# WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
# ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
# NON-INFRINGEMENT.

MODULE_IF_FLAG = defined(VTSS_SW_OPTION_VLAN)

INCLUDE_BEGIN
#include "icli_porting_util.h"
#include "vlan_api.h"
#include "mgmt_api.h"
#include "misc_api.h"        /* For uport2iport(), iport2uport()         */
#include "port_iter.hxx"     /* For switch_iter_init(), port_iter_init() */
#include "msg_api.h"
#include "vlan_icli_functions.h"

#include "standalone_api.h"  /* For topo_usid2isid(), topo_isid2usid()   */

#if defined(VTSS_SW_OPTION_DOT1X)      || defined(VTSS_SW_OPTION_MSTP) || \
    defined(VTSS_SW_OPTION_MVR)        || defined(VTSS_SW_OPTION_MVRP) || \
    defined(VTSS_SW_OPTION_VOICE_VLAN) || defined(VTSS_SW_OPTION_ERPS) || \
    defined(VTSS_SW_OPTION_IEC_MRP)    || defined(VTSS_SW_OPTION_VCL)
#define VLAN_USER_DEBUG_CMD_ENABLE
#endif
INCLUDE_END

// Shared help
VLAN_SWITCHPORT_HELP = Set VLAN switching mode characteristics

FUNCTION_BEGIN
#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_VLAN

/******************************************************************************/
/******************************************************************************/
static char *_vlan_iport_list_txt(mesa_port_list_t &port_list, char *buf)
{
    char *ret_buf;

    ret_buf = mgmt_iport_list2txt(port_list, buf);
    if (strlen(ret_buf) == 0) {
        strcpy(buf, "None");
    }
    return buf;
}

static BOOL vlan_icli_svl_present(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return icli_present_cap(ask, runtime, MESA_CAP_L2_SVL_FID_CNT);
}

static BOOL vlan_icli_flooding_present(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return icli_present_cap(ask, runtime, VTSS_APPL_CAP_VLAN_FLOODING);
}

#if defined(VLAN_USER_DEBUG_CMD_ENABLE)
static BOOL vlan_icli_counters_present(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return icli_present_cap(ask, runtime, VTSS_APPL_CAP_VLAN_COUNTERS);
}
#endif

/******************************************************************************/
// _runtime_svl_range_type()
/******************************************************************************/
static BOOL _runtime_svl_range_type(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_RANGE) {
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1; // One valid range
        runtime->range.u.sr.range[0].min = 1;
        runtime->range.u.sr.range[0].max = VTSS_APPL_VLAN_FID_CNT;
        return TRUE;
    }

    return FALSE;
}

/******************************************************************************/
// _is_in_list()
/******************************************************************************/
static BOOL _is_in_list(icli_unsigned_range_t *list, u32 val)
{
    u32 idx;

    for (idx = 0; idx < list->cnt; idx++) {
        if (val >= list->range[idx].min && val <= list->range[idx].max) {
            return TRUE;
        }
    }

    return FALSE;
}

FUNCTION_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport mode {access | trunk | hybrid}

DOC_CMD_DESC    = Use the switchport mode command to define the type of the port.
DOC_CMD_DEFAULT = Use the no form of this command to return to the default mode that is access mode.
DOC_CMD_USAGE   = To configure a switch port as access port select the mode to access else to trunk or hybrid.
DOC_CMD_EXAMPLE = This example shows to configure a switch port as trunk port.
DOC_CMD_EXAMPLE = Switch(config-if)#switchport mode trunk
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.
#

FUNC_NAME = icli_vlan_port_mode_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set mode of the interface
   HELP = Set mode to ACCESS unconditionally
   HELP = Set mode to TRUNK unconditionally
   HELP = Set mode to HYBRID unconditionally

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_access
   CMD_VAR   = has_trunk
   CMD_VAR   = has_hybrid

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if (has_access || has_trunk || has_hybrid) {
        vtss_appl_vlan_port_mode_t new_mode;

        if (has_access) {
            new_mode = VTSS_APPL_VLAN_PORT_MODE_ACCESS;
        } else if (has_trunk) {
            new_mode = VTSS_APPL_VLAN_PORT_MODE_TRUNK;
        } else {
            new_mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID;
        }

        ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_mode_set(session_id, plist, new_mode));
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND   = no switchport mode

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

PROPERTY  = ICLI_CMD_PROP_LOOSELY

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set mode to default

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf_default;
VARIABLE_END

CODE_BEGIN
    (void)vlan_mgmt_port_conf_default_get(&conf_default);
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_mode_set(session_id, plist, conf_default.mode));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport access vlan <vlan_id>

DOC_CMD_DESC    = Use the switchport access vlan command to configure a port to a VLAN.
DOC_CMD_DEFAULT = The no switchport access command resets the access mode VLAN to the appropriate default VLAN.
DOC_CMD_USAGE   = This command configures the Port VLAN ID (PVID) of an access port.
DOC_CMD_EXAMPLE = This example shows to configure a PVID of an access port.
DOC_CMD_EXAMPLE = Switch(config-if)#switchport access vlan 2
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.

FUNC_NAME = icli_vlan_access_vlan_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set access mode characteristics of the interface
   HELP = Set VLAN when interface is in access mode
   HELP = VLAN ID of the VLAN when this port is in access mode

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = pvid

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_ACCESS, pvid));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport access vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY
CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set access mode characteristics of the interface
HELP = Set VLAN to default

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_ACCESS, VTSS_APPL_VLAN_ID_DEFAULT));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport trunk native vlan <vlan_id>

DOC_CMD_DESC    = Use the switchport native vlan command to configure a port VLAN ID for a trunk port.
DOC_CMD_DEFAULT = The no switchport trunk command resets the trunk native VLAN to the appropriate default VLAN.
DOC_CMD_USAGE   = This command configures the PVID of a trunk port.
DOC_CMD_EXAMPLE = This example shows to configure a PVID of a trunk port.
DOC_CMD_EXAMPLE = Switch(config-if)#switchport trunk native vlan 7
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.

PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

HELP = ##VLAN_SWITCHPORT_HELP
HELP = Change PVID for trunk port
HELP = Set native VLAN
HELP = Set native VLAN when interface is in trunk mode
HELP = VLAN ID of the native VLAN when this port is in trunk mode

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = pvid

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_TRUNK, pvid));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport trunk native vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY
CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set trunk mode characteristics of the interface
HELP = Change native VLAN
HELP = Set VLAN to default

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_TRUNK, VTSS_APPL_VLAN_ID_DEFAULT));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid native vlan <vlan_id>

DOC_CMD_DESC    = Use the switchport native vlan command to configure a port VLAN ID for a hybrid port.
DOC_CMD_DEFAULT = The no switchport hybrid command resets the hybrid native VLAN to the appropriate default VLAN.
DOC_CMD_USAGE   = This command configures the PVID of a hybrid port.
DOC_CMD_EXAMPLE = This example shows to configure a PVID of a hybrid port.
DOC_CMD_EXAMPLE = Switch(config-if)#switchport hybrid native vlan 7
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.

PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

HELP = ##VLAN_SWITCHPORT_HELP
HELP = Change PVID for hybrid port
HELP = Set native VLAN
HELP = Set native VLAN when interface is in hybrid mode
HELP = VLAN ID of the native VLAN when this port is in hybrid mode

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = pvid

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_HYBRID, pvid));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport hybrid native vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY
CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR  = plist

RUNTIME
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set hybrid mode characteristics of the interface
HELP = Change native VLAN
HELP = Set VLAN to default

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_pvid_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_HYBRID, VTSS_APPL_VLAN_ID_DEFAULT));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid port-type { unaware | c-port | s-port | s-custom-port }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
#

FUNC_NAME = icli_vlan_hybrid_port_type_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set hybrid characteristics of the interface
   HELP = Set port type
   HELP = Port in not aware of VLAN tags.
   HELP = Customer port
   HELP = Provider port
   HELP = Custom Provider port

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_unaware
   CMD_VAR   = has_c_port
   CMD_VAR   = has_s_port
   CMD_VAR   = has_s_custom_port

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf;
VARIABLE_END

CODE_BEGIN
    // Populate Port Type
    if (has_unaware) {
        conf.hybrid.port_type = VTSS_APPL_VLAN_PORT_TYPE_UNAWARE;
    } else if (has_c_port) {
        conf.hybrid.port_type = VTSS_APPL_VLAN_PORT_TYPE_C;
    } else if (has_s_port) {
        conf.hybrid.port_type = VTSS_APPL_VLAN_PORT_TYPE_S;
    } else if (has_s_custom_port) {
        conf.hybrid.port_type = VTSS_APPL_VLAN_PORT_TYPE_S_CUSTOM;
    }

    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 0, 1, 0));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport hybrid port-type

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set hybrid characteristics of the interface
HELP = Set port type to default

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf, conf_default;
VARIABLE_END

CODE_BEGIN
    (void)vlan_mgmt_port_conf_default_get(&conf_default);
    conf.hybrid.port_type = conf_default.hybrid.port_type;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 0, 1, 0));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid ingress-filtering

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

FUNC_NAME = icli_vlan_hybrid_ing_filter_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

IF_FLAG = defined(VTSS_SW_OPTION_VLAN_INGRESS_FILTERING)

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set hybrid characteristics of the interface
   HELP = VLAN Ingress filter configuration

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf;
VARIABLE_END

CODE_BEGIN
    conf.hybrid.ingress_filter = TRUE;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 1, 0, 0));
CODE_END

NO_FORM_VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf;
NO_FORM_VARIABLE_END

NO_FORM_CODE_BEGIN
    conf.hybrid.ingress_filter = FALSE;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 1, 0, 0));
NO_FORM_CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid acceptable-frame-type { all | tagged | untagged }
#
DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
#

FUNC_NAME = icli_vlan_hybrid_acceptable_frame_type_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set hybrid characteristics of the interface
   HELP = Set acceptable frame type on a port
   HELP = Allow all frames
   HELP = Allow only tagged frames
   HELP = Allow only untagged frames

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_all
   CMD_VAR   = has_tagged
   CMD_VAR   = has_untagged

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf;
VARIABLE_END

CODE_BEGIN
    // Populate Port Type
    if (has_all) {
        conf.hybrid.frame_type = MESA_VLAN_FRAME_ALL;
    } else if (has_tagged) {
        conf.hybrid.frame_type = MESA_VLAN_FRAME_TAGGED;
    } else if (has_untagged) {
        conf.hybrid.frame_type = MESA_VLAN_FRAME_UNTAGGED;
    }

    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 1, 0, 0, 0));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport hybrid acceptable-frame-type

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

PROPERTY  = ICLI_CMD_PROP_LOOSELY

MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set hybrid characteristics of the interface
HELP = Set acceptable frame type on a port to default

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf, conf_default;
VARIABLE_END

CODE_BEGIN
    (void)vlan_mgmt_port_conf_default_get(&conf_default);
    conf.hybrid.frame_type = conf_default.hybrid.frame_type;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 1, 0, 0, 0));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid egress-tag {none | all [except-native]}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

FUNC_NAME = icli_vlan_egr_tag_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set hybrid characteristics of the interface
   HELP = Egress VLAN tagging configuration
   HELP = No egress tagging
   HELP = Tag all frames
   HELP = Tag all frames except frames classified to native VLAN of the hybrid port

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_none
   CMD_VAR   = has_all
   CMD_VAR   = has_except_native

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (has_none) {
        conf.hybrid.tx_tag_type = VTSS_APPL_VLAN_TX_TAG_TYPE_UNTAG_ALL;
    } else if (has_all) {
        if (has_except_native) {
            conf.hybrid.tx_tag_type = VTSS_APPL_VLAN_TX_TAG_TYPE_UNTAG_THIS;
        } else {
            conf.hybrid.tx_tag_type = VTSS_APPL_VLAN_TX_TAG_TYPE_TAG_ALL;
        }
    } else {
        ICLI_PRINTF("Invalid option\n");
        return ICLI_RC_ERROR;
    }

    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 0, 0, 1));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport hybrid egress-tag

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set hybrid characteristics of the interface
HELP = Egress VLAN tagging configuration set to default

VARIABLE_BEGIN
    vtss_appl_vlan_port_conf_t conf, conf_default;
VARIABLE_END

CODE_BEGIN
    (void)vlan_mgmt_port_conf_default_get(&conf_default);
    conf.hybrid.tx_tag_type = conf_default.hybrid.tx_tag_type;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_hybrid_port_conf(session_id, plist, &conf, 0, 0, 0, 1));
CODE_END

CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport trunk vlan tag native

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
#

FUNC_NAME = icli_vlan_native_vlan_egr_tag_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

RUNTIME = icli_is_switchport_runtime

MODE_VAR  = plist

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set trunk characteristics of the interface
   HELP = VLAN commands
   HELP = tag parameters
   HELP = tag native VLAN

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_trunk_tag_pvid_set(session_id, plist, TRUE));
CODE_END

NO_FORM_CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_trunk_tag_pvid_set(session_id, plist, FALSE));
NO_FORM_CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport trunk allowed vlan {all | none | [add | remove | except] <vlan_list>}
#
DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
#

FUNC_NAME = icli_vlan_trunk_allowed_vids_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set trunk mode characteristics of the interface
   HELP = Set allowed VLAN characteristics when interface is in trunk mode
   HELP = Set allowed VLANs when interface is in trunk mode
   HELP = All VLANs
   HELP = No VLANs
   HELP = Add VLANs to the current list
   HELP = Remove VLANs from the current list
   HELP = All VLANs except the following
   HELP = VLAN IDs of the allowed VLANs when this port is in trunk mode

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_all
   CMD_VAR   = has_none
   CMD_VAR   = has_add
   CMD_VAR   = has_remove
   CMD_VAR   = has_except
   CMD_VAR   = vlan_list

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_allowed_vids_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_TRUNK, vlan_list, FALSE /* has_default */, has_all, has_none, has_add, has_remove, has_except));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND   = no switchport trunk allowed vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

PROPERTY  = ICLI_CMD_PROP_LOOSELY

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set trunk characteristics of the interface,
HELP = Set allowed VLAN characteristics when interface is in trunk mode.
HELP = Set allowed VLANs to default.

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_allowed_vids_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_TRUNK, NULL, TRUE /* has_default */, FALSE /* has_all */, FALSE /* has_none */, FALSE /* has_add */, FALSE /* has_remove */, FALSE /* has_except */));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = switchport hybrid allowed vlan {all | none | [add | remove | except] <vlan_list>}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

FUNC_NAME = icli_vlan_hybrid_allowed_vids_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME = icli_is_switchport_runtime

   HELP = ##VLAN_SWITCHPORT_HELP
   HELP = Set hybrid characteristics of the interface
   HELP = Set allowed VLAN characteristics when interface is in hybrid mode
   HELP = Set allowed VLANs when interface is in hybrid mode
   HELP = All VLANs
   HELP = No VLANs
   HELP = Add VLANs to the current list
   HELP = Remove VLANs from the current list
   HELP = All VLANs except the following
   HELP = VLAN IDs of the allowed VLANs when this port is in hybrid mode

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = has_all
   CMD_VAR   = has_none
   CMD_VAR   = has_add
   CMD_VAR   = has_remove
   CMD_VAR   = has_except
   CMD_VAR   = vlan_list

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_allowed_vids_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_HYBRID, vlan_list, FALSE /* has_default */, has_all, has_none, has_add, has_remove, has_except));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no switchport hybrid allowed vlan

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE  = ICLI_CMD_MODE_INTERFACE_PORT_LIST

MODE_VAR  = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Set hybrid characteristics of the interface
HELP = Set hybrid characteristics of the interface
HELP = Set allowed VLAN characteristics when interface is in hybrid mode
HELP = Set allowed VLANs when interface is in hybrid mode

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_allowed_vids_set(session_id, plist, VTSS_APPL_VLAN_PORT_MODE_HYBRID, NULL, TRUE /* has_default */, FALSE /* has_all */, FALSE /* has_none */, FALSE /* has_add */, FALSE /* has_remove */, FALSE /* has_except */));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = vlan ethertype s-custom-port <0x0600-0xffff>

IF_FLAG =
DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =
#

FUNC_NAME = icli_vlan_s_custom_port_etype_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_GLOBAL_CONFIG

   HELP = VLAN commands
   HELP = EtherType for Custom S-ports
   HELP = Custom S-ports configuration
   HELP = EtherType (Range: 0x0600-0xffff)

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = etype

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_vlan_s_custom_etype_set(etype) != VTSS_RC_OK) {
        ICLI_PRINTF("%% Unable to set Ethertype\n");
        return ICLI_RC_ERROR;
    }
CODE_END

NO_FORM_VARIABLE_BEGIN
NO_FORM_VARIABLE_END

NO_FORM_CODE_BEGIN
NO_FORM_CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN

IF_FLAG =

COMMAND = no vlan {{ethertype s-custom-port} | <vlan_list>}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: no
! 2: vlan
! 3: ethertype
! 4: s-custom-port
! 5: <vlan_list>

CMD_VAR =
CMD_VAR =
CMD_VAR = has_ethertype
CMD_VAR =
CMD_VAR = vlan_list

HELP =
HELP =
HELP =
HELP =
HELP =

BYWORD =
BYWORD =
BYWORD = <Ethertype : option>
BYWORD =
BYWORD =

VARIABLE_BEGIN
    u8      access_vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    mesa_rc rc;
VARIABLE_END

CODE_BEGIN
    if (has_ethertype) {
        if ((rc = vtss_appl_vlan_s_custom_etype_set(VTSS_APPL_VLAN_CUSTOM_S_TAG_DEFAULT)) != VTSS_RC_OK) {
             ICLI_PRINTF("%% Unable to set Ethertype (%s)\n", error_txt(rc));
             return ICLI_RC_ERROR;
        }
    } else if (vlan_list) {
        u32        idx;
        mesa_vid_t vid;
        char       vlan_name[VTSS_APPL_VLAN_NAME_MAX_LEN];

        vlan_name[0] = '\0'; // This will default the names

        // Get current list of access VLANs
        if ((rc = vtss_appl_vlan_access_vids_get(access_vids)) != VTSS_RC_OK) {
            T_E("%s\n",  error_txt(rc));
            ICLI_PRINTF("%% Unable to get current list of access VLANs. Error message: %s\n", error_txt(rc));
            return ICLI_RC_ERROR;
        }

        for (idx = 0; idx < vlan_list->cnt; idx++) {
            for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
                VTSS_BF_SET(access_vids, vid, 0);

                // Also clear the VLAN name when deleting the access VLAN.
                if ((rc = vtss_appl_vlan_name_set(vid, vlan_name)) != VTSS_RC_OK) {
                    ICLI_PRINTF("%% Failed to default VLAN name for VLAN %u (%s)\n", vid, error_txt(rc));
                    vlan_bulk_update_end();
                    return ICLI_RC_ERROR;
                }

            }
        }

        if ((rc = vtss_appl_vlan_access_vids_set(access_vids)) != VTSS_RC_OK) {
            T_E("%s\n", error_txt(rc));
            ICLI_PRINTF("%% Unable to set new list of access VLANs. Error Error message: %s\n", error_txt(rc));
            return ICLI_RC_ERROR;
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = svl fid <uint> vlan <vlan_list>

IF_FLAG         =
DOC_CMD_DESC    = Shared VLAN Learning (SVL) makes it possible to learn multiple VLANs (VIDs) on the same FID. MAC addresses that get classified to a given VID will be mapped to its FID and learned on that FID.
DOC_CMD_DEFAULT = The no-form of this command changes all VIDs currently mapped to the FID back to being independent (IVL).
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = Let VID 2, 4 and 20-200 map to the same shared VLAN, 13 (notice that VID 13 by default is member of FID 13), so that the whole range will become 2,4,13,20-200):
DOC_CMD_EXAMPLE = (config)# svl fid 13 vlan 2,4,20-200
DOC_CMD_EXAMPLE = A given VID can only be mapped to one single FID.
DOC_CMD_EXAMPLE = Verify your settings with 'show svl'
#

FUNC_NAME = vlan_icli_svl_set
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_GLOBAL_CONFIG

HELP = Shared VLAN Learning
HELP = Filter ID keyword
HELP = Filter ID
HELP = VLAN keyword
HELP = VLAN List

CMD_VAR =
CMD_VAR =
CMD_VAR = fid
CMD_VAR =
CMD_VAR = vlan_list

RUNTIME = vlan_icli_svl_present
RUNTIME =
RUNTIME = _runtime_svl_range_type

VARIABLE_BEGIN
    mesa_vid_t vid, temp_fid;
    mesa_rc    rc;
VARIABLE_END

CODE_BEGIN

    // If a VID in <vlan_list> is currently assigned to another FID, silently assign it to this new one.
    for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
        if (_is_in_list(vlan_list, vid)) {
            if ((rc = vtss_appl_vlan_fid_set(vid, fid)) != VTSS_RC_OK) {
                ICLI_PRINTF("%% Grouping VLAN %u into FID %u failed. %s\n", vid, fid, error_txt(rc));
                return ICLI_RC_ERROR;
            }
        } else {
            if ((rc = vtss_appl_vlan_fid_get(vid, &temp_fid)) != VTSS_RC_OK) {
                T_E("Unable to get FID for VLAN %u. rc = %s", vid, error_txt(rc));
                return ICLI_RC_ERROR;
            }

            if (temp_fid == fid) {
                // Clear the membership
                if ((rc = vtss_appl_vlan_fid_set(vid, 0)) != VTSS_RC_OK) {
                   ICLI_PRINTF("%% Ungrouping VLAN %u out of FID %u failed. %s\n", vid, fid, error_txt(rc));
                   return ICLI_RC_ERROR;
                }
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no svl fid {<range_list> | all}

IF_FLAG         =
DOC_CMD_DESC    = Unset Shared VLAN Learning (SVL) for one, more or all Filter IDs (FIDs).
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = Let all VLANs currently mapped to FID 7 and 10 return to Independent VLAN Learning (IVL):
DOC_CMD_EXAMPLE = (config)# no svl fid 7,10
DOC_CMD_EXAMPLE = Let all VLANs return to being independent VLANs (IVL):
DOC_CMD_EXAMPLE = (config)# no svl fid all
DOC_CMD_EXAMPLE = Verify your settings with 'show svl'
#

FUNC_NAME = vlan_icli_svl_unset
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_GLOBAL_CONFIG

HELP =
HELP = Unmap Shared VLAN Learning for a range or all FIDs
HELP = Filter ID keyword
HELP = List of filter IDs to default
HELP = Default all Filter IDs

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = fid_list
CMD_VAR =

RUNTIME =
RUNTIME = vlan_icli_svl_present
RUNTIME =
RUNTIME = _runtime_svl_range_type
RUNTIME =

VARIABLE_BEGIN
    mesa_vid_t vid, fid;
    mesa_rc    rc;

VARIABLE_END

CODE_BEGIN
    for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
        if ((rc = vtss_appl_vlan_fid_get(vid, &fid)) != VTSS_RC_OK) {
            T_E("Unable to get FID for VLAN %u. rc = %s", vid, error_txt(rc));
            return ICLI_RC_ERROR;
        }

        if (fid != 0) {
            // Candidate for reset.
            if (fid_list) {
                if (!_is_in_list(&fid_list->u.ur, fid)) {
                    continue; // Next VID
                }
            }

            // Reset it
            if ((rc = vtss_appl_vlan_fid_set(vid, 0)) != VTSS_RC_OK) {
                T_E("Unable to reset FID for VLAN %u. rc = %s", vid, error_txt(rc));
                return ICLI_RC_ERROR;
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = show svl {[fid [<range_list>]] | [vlan [<vlan_list>]]}

IF_FLAG         =
DOC_CMD_DESC    = Show the current Shared VLAN Learning configuration. Without arguments, this command only shows non-default configuration
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = Show all non-default SVLs, sorted by FID:
DOC_CMD_EXAMPLE = # show svl or show svl fid

DOC_CMD_EXAMPLE = Show all non-default SVLs, sorted by VID:
DOC_CMD_EXAMPLE = # show svl vlan

DOC_CMD_EXAMPLE = Show only FID 3 and 7-10 entries:
DOC_CMD_EXAMPLE = # show svl fid 3,7-10

DOC_CMD_EXAMPLE = Show which FID VLAN 100 and 200-300 belong to
DOC_CMD_EXAMPLE = # show svl vlan 100,200-300

FUNC_NAME = vlan_icli_svl_show
PRIVILEGE = ICLI_PRIVILEGE_0
PROPERTY  = ICLI_CMD_PROP_GREP
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP = Show running system information
HELP = Shared VLAN Learning configuration
HELP = Show a given FID
HELP = List of FIDs to show
HELP = Show a given VLAN ID
HELP = List of VIDs to show

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = has_fid
CMD_VAR   = fid_list
CMD_VAR   = has_vlan
CMD_VAR   = vlan_list

RUNTIME = vlan_icli_svl_present
RUNTIME =
RUNTIME =
RUNTIME = _runtime_svl_range_type

VARIABLE_BEGIN
    mesa_vid_t fid, vid;
    char       fid_in_use[((VTSS_APPL_VLAN_FID_CNT + 1) + 7) / 8], str[100], *vid_buf = NULL;
    u8         vids[VTSS_APPL_VLAN_BITMASK_LEN_BYTES];
    BOOL       found = FALSE, at_least_one_printed = FALSE, print_it;
    mesa_rc    rc;
VARIABLE_END

CODE_BEGIN
    if (has_fid || !has_vlan) {
        // Sort by FID (which is also the default)

        // This can be quite time-consuming, because the table
        // is sorted the opposite way in the vtss_appl_vlan_fid_get() call,
        // so let's start by figuring out which FIDs are actually configured.

        memset(fid_in_use, 0, sizeof(fid_in_use));

        for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
            if ((rc = vtss_appl_vlan_fid_get(vid, &fid)) != VTSS_RC_OK) {
                T_E("Unable to get FID for VLAN %u. rc = %s", vid, error_txt(rc));
                return ICLI_RC_ERROR;
            }

            if (fid != 0) {
                VTSS_BF_SET(fid_in_use, fid, 1);
                found = TRUE;
            }
        }

        // Time to display the FID->VID table
        sprintf(str, "%-4s  %-32s", "FID", "VLANs");
        icli_table_header(session_id, str);

        if (found || fid_list) {
            // At least one non-default mapping found or user is asking for specific FIDs (which we always show)
            for (fid = 1; fid <= VTSS_APPL_VLAN_FID_CNT; fid++) {

                if (fid_list) {
                    // User asked for specific FIDs
                    print_it = _is_in_list(&fid_list->u.ur, fid);
                } else {
                    // User asked for all non-default FIDs
                    print_it = VTSS_BF_GET(fid_in_use, fid);
                }

                if (print_it) {
                    at_least_one_printed = TRUE;

                    if (VTSS_BF_GET(fid_in_use, fid)) {
                        // Gotta traverse all VIDs once more while building up an array of members.
                        memset(vids, 0, sizeof(vids));
                        for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
                            mesa_vid_t temp_fid;

                            if ((rc = vtss_appl_vlan_fid_get(vid, &temp_fid)) != VTSS_RC_OK) {
                                T_E("Unable to get FID for VLAN %u. rc = %s", vid, error_txt(rc));
                                VTSS_FREE(vid_buf);
                                return ICLI_RC_ERROR;
                            }

                            if (fid == temp_fid || (vid == fid && temp_fid == 0)) {
                                VTSS_BF_SET(vids, vid, 1);
                            }
                        }

                        // If not already allocated, allocate a buffer for it.
                        if (!vid_buf) {
                            if ((vid_buf = (char *)VTSS_MALLOC(VLAN_VID_LIST_AS_STRING_LEN_BYTES)) == NULL) {
                                T_E("Out of memory");
                                return ICLI_RC_ERROR;
                            }
                        }

                        ICLI_PRINTF("%4u  %s\n", fid, vlan_mgmt_vid_bitmask_to_txt(vids, vid_buf));
                    } else {
                        // Here, we know that this FID is only used for default, so no need to
                        // traverse again.
                        ICLI_PRINTF("%4u  %u (default)\n", fid, fid);
                    }
                }
            }
        }

        if (vid_buf) {
            VTSS_FREE(vid_buf);
        }
    } else {

        // Display a VID->FID table
        sprintf(str, "%-4s  %-4s", "VLAN", "FID");
        icli_table_header(session_id, str);

        // Sort by VID. This is much easier.
        for (vid = VTSS_APPL_VLAN_ID_MIN; vid <= VTSS_APPL_VLAN_ID_MAX; vid++) {
            print_it = FALSE;

            if (vlan_list) {
                if ((print_it = _is_in_list(vlan_list, vid)) == FALSE) {
                    continue; // Next VID
                }
            }

            // If we get here, we either are forced to print it, or
            // we should print it unless it's default
            if ((rc = vtss_appl_vlan_fid_get(vid, &fid)) != VTSS_RC_OK) {
                T_E("Unable to get FID for VLAN %u. rc = %s", vid, error_txt(rc));
                return ICLI_RC_ERROR;
            }

            if (!vlan_list) {
                print_it = fid != 0;
            }

            if (print_it) {
                at_least_one_printed = TRUE;

                if (fid == 0) {
                    // Default VID-to-FID mapping
                    ICLI_PRINTF("%4u  VLAN\n", vid);
                } else {
                    ICLI_PRINTF("%4u  %4u\n", vid, fid);
                }
            }
        }
    }

    if (!at_least_one_printed) {
        // No entries were non-default and specific FIDs/VIDs were not specified.
        ICLI_PRINTF("None\n");
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = show interface <port_type_list> switchport [access | trunk | hybrid]

DOC_CMD_DESC    = Use the show interface command to display the administrative and operational status of all interfaces \
                  or a specified interface.
#DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = Use this command to display the switch port characteristics of all interfaces on that switch in the stack.
DOC_CMD_EXAMPLE = This example shows the VLAN status for interface Gi 1/1
DOC_CMD_EXAMPLE = # show interface GigabitEthernet 1/1 switchport

FUNC_NAME = icli_vlan_interfaces_show
PRIVILEGE = ICLI_PRIVILEGE_0
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE  = ICLI_CMD_MODE_EXEC

   HELP = Show running system information
   HELP = Interface status
   HELP = ports list
   HELP = Show interface switchport information
   HELP = Show access ports status
   HELP = Show trunk ports status
   HELP = Show hybrid ports status

   CMD_VAR   =
   CMD_VAR   =
   CMD_VAR   = in_port_list
   CMD_VAR   = has_switchport
   CMD_VAR   = has_access
   CMD_VAR   = has_trunk
   CMD_VAR   = has_hybrid

VARIABLE_BEGIN
    u32                        range_idx, cnt_idx;
    vtss_usid_t                usid;
    mesa_port_no_t             uport;
    char                       buf[ICLI_PORTING_STR_BUF_SIZE], *vlan_buf;
    vtss_appl_vlan_port_conf_t conf;
    vtss_appl_vlan_port_mode_t mode = VTSS_APPL_VLAN_PORT_MODE_ACCESS;
VARIABLE_END

CODE_BEGIN
    if (has_switchport) {
        if ((vlan_buf = (char *)VTSS_MALLOC(VLAN_VID_LIST_AS_STRING_LEN_BYTES)) == NULL) {
            ICLI_PRINTF("%% Out of memory\n");
            return ICLI_RC_ERROR;
        }

        for (range_idx = 0; range_idx < in_port_list->cnt; range_idx++) {
            usid = in_port_list->switch_range[range_idx].usid;
            for (cnt_idx = 0; cnt_idx < in_port_list->switch_range[range_idx].port_cnt; cnt_idx++) {
                uport = in_port_list->switch_range[range_idx].begin_uport + cnt_idx;

                if (has_access) {
                    mode = VTSS_APPL_VLAN_PORT_MODE_ACCESS;
                } else if (has_trunk) {
                    mode = VTSS_APPL_VLAN_PORT_MODE_TRUNK;
                } else if (has_hybrid) {
                    mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID;
                }

                if (vlan_mgmt_port_conf_get(topo_usid2isid(usid), uport2iport(uport), &conf, VTSS_APPL_VLAN_USER_STATIC, FALSE) != VTSS_RC_OK) {
                    // Stack port? Try next.
                    continue;
                }

                if (has_access || has_trunk || has_hybrid) {
                    if (mode != conf.mode) {
                        continue;
                    }
                }

                // What a mess:
                ICLI_PRINTF("Name: %s\n", icli_port_info_txt(usid, uport, buf));
                ICLI_PRINTF("Administrative mode: %s\n", VLAN_ICLI_port_mode_txt(conf.mode));
                ICLI_PRINTF("Access Mode VLAN: %u\n", conf.access_pvid);
                ICLI_PRINTF("Trunk Native Mode VLAN: %u\n", conf.trunk_pvid);
                ICLI_PRINTF("Administrative Native VLAN tagging: %s\n", conf.trunk_tag_pvid ? "enabled" : "disabled");
                ICLI_PRINTF("Allowed VLANs: %s\n", vlan_mgmt_vid_bitmask_to_txt(conf.trunk_allowed_vids, vlan_buf));

                ICLI_PRINTF("Hybrid port configuration\n");
                ICLI_PRINTF("-------------------------\n");
                ICLI_PRINTF("Port Type: %s\n", vlan_mgmt_port_type_to_txt(conf.hybrid.port_type));
                ICLI_PRINTF("Acceptable Frame Type: %s\n", vlan_mgmt_frame_type_to_txt(conf.hybrid.frame_type));
                ICLI_PRINTF("Ingress filter: %s\n", ((conf.hybrid.ingress_filter) ? "Enabled" : "Disabled"));
                ICLI_PRINTF("Egress tagging: %s\n", VLAN_ICLI_tx_tag_type_to_txt(conf.hybrid.tx_tag_type));
                ICLI_PRINTF("Hybrid Native Mode VLAN: %u\n", conf.hybrid.pvid);
                ICLI_PRINTF("Hybrid VLANs Enabled: %s\n", vlan_mgmt_vid_bitmask_to_txt(conf.hybrid_allowed_vids, vlan_buf));

                ICLI_PRINTF("\n");
            }
        }

        VTSS_FREE(vlan_buf);
    }

CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = show vlan [id <vlan_list> | name <vword32> | brief] [all]

DOC_CMD_DESC    = Use the show vlan command to view the VLAN configuration.
#DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = To view the VLAN members by VLAN ID used id option. To view the VLAN members \
                  by name use the name option.
DOC_CMD_EXAMPLE = This example shows viewing of VLAN membership configuration by VLAN ID.
DOC_CMD_EXAMPLE = Switch(config-if)#show vlan id 2

FUNC_NAME = vlan_show
PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_EXEC
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = VLAN_ICLI_runtime_vlan_name
RUNTIME = VLAN_ICLI_runtime_vlan_name

HELP = Show running system information
HELP = VLAN status
HELP = VLAN status by VLAN id
HELP = VLAN IDs
HELP = VLAN status by VLAN name
HELP = VLAN name
HELP = VLAN summary information
HELP = Show all VLANs (if left out only access VLANs are shown)

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = has_vid
CMD_VAR   = vlan_list
CMD_VAR   = has_name
CMD_VAR   = name
CMD_VAR   = has_brief
CMD_VAR   = has_all

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    (void)has_brief; // Unused parameter
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_show_vlan(session_id, vlan_list, name, has_vid, has_name, has_all, FALSE));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
# Keep the keywords sorted alphabetically, or it will quickly become a mess.
COMMAND         = show vlan status [interface <port_type_list>] [admin|all|combined|conflicts|erps|gvrp|mrp|mstp|mvr|nas|rmirror|vcl|voice-vlan]

DOC_CMD_DESC    = Use the show VLAN status command to view the VLANs configured for each interface.
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP = Show running system information
HELP = VLAN status
HELP = Show the VLANs configured for each interface.
HELP = Show the VLANs configured for a specific interface or interfaces.
HELP = The specific interface or interfaces to show VLANs for.
HELP = Show the VLANs configured by administrator.
HELP = Show VLANs configured VLANs for all VLAN users.
HELP = Show the combined set of configured VLANs.
HELP = Show VLAN configurations that have conflicts.
HELP = Show the VLANs configured by ERPS.
HELP = Show the VLANs configured by GVRP.
HELP = Show the VLANs configured by MRP.
HELP = Show the VLANs configured by MSTP.
HELP = Show the VLANs configured by MVR.
HELP = Show the VLANs configured by NAS.
HELP = Show the VLANs configured by Remote mirroring.
HELP = Show the VLANs configured by VCL.
HELP = Show the VLANs configured by Voice VLAN.

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = VLAN_ICLI_runtime_erps
RUNTIME = VLAN_ICLI_runtime_gvrp
RUNTIME = VLAN_ICLI_runtime_mrp
RUNTIME = VLAN_ICLI_runtime_mstp
RUNTIME = VLAN_ICLI_runtime_mvr
RUNTIME = VLAN_ICLI_runtime_nas
RUNTIME = VLAN_ICLI_runtime_rmirror
RUNTIME = VLAN_ICLI_runtime_vcl
RUNTIME = VLAN_ICLI_runtime_voice_vlan

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   = has_admin
CMD_VAR   =
CMD_VAR   = has_combined
CMD_VAR   = has_conflicts
CMD_VAR   = has_erps
CMD_VAR   = has_gvrp
CMD_VAR   = has_mrp
CMD_VAR   = has_mstp
CMD_VAR   = has_mvr
CMD_VAR   = has_nas
CMD_VAR   = has_rmirror
CMD_VAR   = has_vcl
CMD_VAR   = has_voice_vlan

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_show_status(session_id, plist, has_admin, has_combined, has_conflicts, has_erps, has_gvrp, has_mrp, has_mstp, has_mvr, has_nas, has_rmirror, has_vcl, has_voice_vlan));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = name <vword32>

DOC_CMD_DESC    = Use the name <vword32> command to configure VLAN name.
DOC_CMD_DEFAULT = The no form of this command will delete the VLAN name to VLAN mapping.
DOC_CMD_USAGE   = You can enter up to 32 alphanumeric characters to name the VLAN. First character must be a letter
DOC_CMD_EXAMPLE = This example shows how to configure the VLAN name
DOC_CMD_EXAMPLE = config-vlan# name guest
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.

FUNC_NAME = icli_vlan_name_set
PRIVILEGE = ICLI_PRIVILEGE_15

MODE_VAR = vlist

CMD_MODE  = ICLI_CMD_MODE_CONFIG_VLAN

   HELP = ASCII name of the VLAN
   HELP = The ASCII name for the VLAN

   CMD_VAR   =
   CMD_VAR   = vlan_name

CODE_BEGIN
    if (vlist->cnt != 1 || vlist->range[0].max - vlist->range[0].min > 0) {
        ICLI_PRINTF("%% Cannot modify name for multiple VLANs\n");
        return ICLI_RC_ERROR;
    }

    if (!vlan_name) {
         ICLI_PRINTF("%% Que?\n");
         return ICLI_RC_ERROR;
    }

    ICLI_RC_CHECK_PRINT_RC(vtss_appl_vlan_name_set(vlist->range[0].min, vlan_name));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no name

DOC_CMD_DEFAULT = The no form of this command will restore the VLAN name to its default.
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = This example shows to default the VLAN name for VLAN 7.
DOC_CMD_EXAMPLE = # configure terminal; (config)# vlan 7; (config-vlan)# no name
DOC_CMD_EXAMPLE = You can verify your settings by entering the show vlan privileged EXEC command.

PRIVILEGE = ICLI_PRIVILEGE_15

MODE_VAR = vlist

PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE  = ICLI_CMD_MODE_CONFIG_VLAN

HELP =
HELP = ASCII name of the VLAN

VARIABLE_BEGIN
    u32        idx;
    mesa_vid_t vid;
    char       vlan_name[VTSS_APPL_VLAN_NAME_MAX_LEN];
VARIABLE_END

CODE_BEGIN
    vlan_name[0] = '\0'; // This will default the names

    for (idx = 0; idx < vlist->cnt; idx++) {
        for (vid = vlist->range[idx].min; vid <= vlist->range[idx].max; vid++) {
            ICLI_RC_CHECK_PRINT_RC(vtss_appl_vlan_name_set(vid, vlan_name));
        }
    }
CODE_END
CMD_END


#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = flooding

DOC_CMD_DESC    = Use the flooding command to enable VLAN flooding
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = This example shows how to enable VLAN flooding
DOC_CMD_EXAMPLE = config-vlan# flooding

PRIVILEGE = ICLI_PRIVILEGE_15

MODE_VAR = vlist

CMD_MODE  = ICLI_CMD_MODE_CONFIG_VLAN

HELP = Flood frames with unknown DMAC to all ports that are members of this VLAN.

CMD_VAR   =

RUNTIME = vlan_icli_flooding_present

VARIABLE_BEGIN
    u32        idx;
    mesa_vid_t vid;
VARIABLE_END

CODE_BEGIN
    for (idx = 0; idx < vlist->cnt; idx++) {
        for (vid = vlist->range[idx].min; vid <= vlist->range[idx].max; vid++) {
            ICLI_RC_CHECK_PRINT_RC(vtss_appl_vlan_flooding_set(vid, true));
        }
    }
CODE_END
CMD_END


#==============================================================================
#==============================================================================
CMD_BEGIN
COMMAND         = no flooding

DOC_CMD_DESC    = Use the no flooding command to disable VLAN flooding
DOC_CMD_DEFAULT = The no form of this command will disable flooding for this VLAN.
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE = This example shows how to disable VLAN flooding
DOC_CMD_EXAMPLE = config-vlan# no flooding

PRIVILEGE = ICLI_PRIVILEGE_15

MODE_VAR = vlist

CMD_MODE  = ICLI_CMD_MODE_CONFIG_VLAN

HELP =
HELP = Do not flood frames in VLAN. Do forward frames, the DMAC must be present in the MAC address table

CMD_VAR   =
CMD_VAR   =

RUNTIME = vlan_icli_flooding_present
RUNTIME = vlan_icli_flooding_present

VARIABLE_BEGIN
    u32        idx;
    mesa_vid_t vid;
VARIABLE_END

CODE_BEGIN
    for (idx = 0; idx < vlist->cnt; idx++) {
        for (vid = vlist->range[idx].min; vid <= vlist->range[idx].max; vid++) {
            ICLI_RC_CHECK_PRINT_RC(vtss_appl_vlan_flooding_set(vid, false));
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
IF_FLAG =
COMMAND = switchport forbidden vlan {add|remove} <vlan_list>
VLAN_FORBIDDEN_HELP = Adds or removes forbidden VLANs from the current list of forbidden VLANs
DOC_CMD_DESC    = ##VLAN_FORBIDDEN_HELP
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = ##VLAN_FORBIDDEN_HELP
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: switchport
! 2: forbidden
! 3: vlan
! 4: add
! 5: remove
! 6: <vlan_list>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = has_add
CMD_VAR =
CMD_VAR = vlan_list

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =

HELP = ##VLAN_SWITCHPORT_HELP
HELP = ##VLAN_FORBIDDEN_HELP
HELP = Add or modify VLAN entry in forbidden table.
HELP = Add to existing list.
HELP = Remove from existing list.
HELP = VLAN IDs

BYWORD =
BYWORD =
BYWORD = add : Option
BYWORD = remove : Option

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_add_remove_forbidden(plist, vlan_list, has_add));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN
IF_FLAG =
COMMAND = no switchport forbidden vlan
DOC_CMD_DESC    = Allows for adding VLANs to an interface
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: switchport
! 3: forbidden
! 4: vlan

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =

HELP =
HELP = ##VLAN_SWITCHPORT_HELP
HELP = Forbidden VLANs
HELP = VLANs

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    icli_unsigned_range_t vlan_list;
VARIABLE_END

CODE_BEGIN
    // The no-form corresponds to removing all forbidden VLANs
    vlan_list.cnt = 1;
    vlan_list.range[0].min = VTSS_APPL_VLAN_ID_MIN;
    vlan_list.range[0].max = VTSS_APPL_VLAN_ID_MAX;
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_add_remove_forbidden(plist, &vlan_list, FALSE));
CODE_END
CMD_END

#==============================================================================
#==============================================================================
CMD_BEGIN

IF_FLAG =

COMMAND = show switchport forbidden [{vlan <vlan_list>} | {name <vword32>}]

VLAN_FORBIDDEN_SHOW_HELP = Lookup VLAN Forbidden port entry.

DOC_CMD_DESC    = ##VLAN_FORBIDDEN_SHOW_HELP
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = ##VLAN_FORBIDDEN_SHOW_HELP
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_0
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

! 1: show
! 2: switchport
! 3: forbidden
! 4: vlan
! 5: <vlan_list>
! 6: name
! 7: <vword32>

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = VLAN_ICLI_runtime_vlan_name
RUNTIME = VLAN_ICLI_runtime_vlan_name

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = has_vid
CMD_VAR = vlan_list
CMD_VAR = has_name
CMD_VAR = name

HELP =
HELP = Display switching mode characteristics
HELP = ##VLAN_FORBIDDEN_SHOW_HELP
HELP = Forbidden VLAN by VLAN ID
HELP = VLAN IDs
HELP = Forbidden VLANs by VLAN name
HELP = VLAN name

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK_PRINT_RC(VLAN_ICLI_show_vlan(session_id, vlan_list, name, has_vid, has_name, FALSE, TRUE));
CODE_END
CMD_END

#==============================================================================
#==============================================================================

HELP_DEBUG_VLAN = Virtual LAN

CMD_BEGIN
COMMAND   = debug vlan add <vlan_id> interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror }
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Add member ports to a VLAN
HELP      = VLAN ID
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_entry_t      conf;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    vtss_clear(conf);
    conf.vid = vid;

    isid = 0;
    for (i = 0; i < plist->cnt; ++i) {

        // isid
        if (isid == 0) {
            isid = plist->switch_range[i].isid;
        } else {
            if (isid != plist->switch_range[i].isid) {
                ICLI_PRINTF("Ports of switch %u not be added into VLAN.\n", plist->switch_range[0].usid);
                continue;
            }
        }

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;

            // get member port
            conf.ports[iport] = TRUE;
        }
    }

    if ((rc = vlan_mgmt_vlan_add(isid, &conf, vlan_user)) != VTSS_RC_OK) {
        ICLI_PRINTF("%% %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan del <vlan_id> <switch_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror }
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Delete VLAN entry
HELP      = VLAN ID
HELP      = List of switch ID
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid
CMD_VAR   = slist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror

VARIABLE_BEGIN
    vtss_appl_vlan_user_t       vlan_user = VTSS_APPL_VLAN_USER_STATIC;
    mesa_rc                     rc;
    u32                         i;
    u32                         usid;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    }

    if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    }

    if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    }

    if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    }

    if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    }

    if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    }

    if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    }

    if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    }

    if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < slist->cnt; ++i) {
        for (usid = slist->range[i].min; usid <= slist->range[i].max; ++usid) {
            rc = vlan_mgmt_vlan_del(topo_usid2isid(usid), vid, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% Couldn't delete VLAN on switch %u: %s\n", usid, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan fillup <vlan_id>
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Fill up the VLAN table
HELP      = VLAN ID

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid

VARIABLE_BEGIN
    u32                     i;
    mesa_port_no_t          iport;
    vtss_appl_vlan_entry_t  conf;
    mesa_rc                 rc;
VARIABLE_END

CODE_BEGIN
    for (i = vid; i <= VTSS_APPL_VLAN_ID_MAX; i++) {
        vtss_clear(conf);
        conf.vid = i;
        for (iport = 0; iport < fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT); ++iport) {
            conf.ports[iport] = TRUE;
        }

        rc = vlan_mgmt_vlan_add(VTSS_ISID_GLOBAL, &conf, VTSS_APPL_VLAN_USER_ALL);
        if (rc != VTSS_RC_OK) {
            ICLI_PRINTF("%% VLAN %u: %s\n", i, error_txt(rc));
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan empty
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Empty the VLAN table

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =

VARIABLE_BEGIN
    u32         i;
    mesa_rc     rc;
VARIABLE_END

CODE_BEGIN
    for (i = VTSS_APPL_VLAN_ID_MIN; i <= VTSS_APPL_VLAN_ID_MAX; ++i) {
        rc = vlan_mgmt_vlan_del(VTSS_ISID_GLOBAL, i, VTSS_APPL_VLAN_USER_ALL);
        if (rc != VTSS_RC_OK) {
            ICLI_PRINTF("%% VLAN %u: %s\n", i, error_txt(rc));
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug show vlan config
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC
PROPERTY  = ICLI_CMD_PROP_GREP

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_DEBUG_VLAN
HELP      = Read the VLAN configuration from the Hardware

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =

VARIABLE_BEGIN
    u16                         i;
    mesa_port_list_t            b_mports;
    vtss_appl_vlan_entry_t      entry_conf;
    char                        buf[MGMT_PORT_BUF_SIZE];
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
VARIABLE_END

CODE_BEGIN
    ICLI_PRINTF("VID   USID  Ports                 \n");
    ICLI_PRINTF("----  ----  ----------------------\n");

    for (i = VTSS_APPL_VLAN_ID_MIN; i <= VTSS_APPL_VLAN_ID_MAX; ++i) {
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; ++isid) {
            if (vtss_appl_vlan_get(isid, i, &entry_conf, FALSE, VTSS_APPL_VLAN_USER_ALL) == VTSS_RC_OK) {
                for (iport = 0; iport < fast_cap(MEBA_CAP_BOARD_PORT_MAP_COUNT); ++iport) {
                    b_mports[iport] = entry_conf.ports[iport];
                }
                ICLI_PRINTF("%-4d  %-4u  %s\n", entry_conf.vid, topo_isid2usid(isid), _vlan_iport_list_txt(b_mports, buf));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug show vlan port-config interface <port_type_list>
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC
PROPERTY  = ICLI_CMD_PROP_GREP

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_DEBUG_VLAN
HELP      = Fetch the VLAN port configuration

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
#ifdef VTSS_SW_OPTION_VLAN_INGRESS_FILTERING
    ICLI_PRINTF("Usid  Uport  PVID  Frame Type  UVID  Ingress Filter  Port Type      \n");
    ICLI_PRINTF("----  -----  ----  ----------  ----  --------------  ---------------\n");
#else
    ICLI_PRINTF("Usid  Uport  PVID  Frame Type  UVID  Port Type      \n");
    ICLI_PRINTF("----  ----  ----  ----------  ----  ---------------\n");
#endif

    for (i = 0; i < plist->cnt; ++i) {

        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, VTSS_APPL_VLAN_USER_ALL, TRUE) != VTSS_RC_OK) {
                continue;
            }

            ICLI_PRINTF("%-4u  ", usid);
            ICLI_PRINTF("%-5u  ", uport);
            ICLI_PRINTF("%-4d  ", conf.hybrid.pvid);
            ICLI_PRINTF("%-11s ", vlan_mgmt_frame_type_to_txt(conf.hybrid.frame_type));
            ICLI_PRINTF("%-4d  ", conf.hybrid.untagged_vid);
#ifdef VTSS_SW_OPTION_VLAN_INGRESS_FILTERING
            ICLI_PRINTF("%-16s", conf.hybrid.ingress_filter ? "enabled" : "disabled");
#endif /* VTSS_SW_OPTION_VLAN_INGRESS_FILTERING */
            ICLI_PRINTF("%-15s", vlan_mgmt_port_type_to_txt(conf.hybrid.port_type));
            ICLI_PRINTF("\n");
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug show vlan bulk-update
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC
PROPERTY  = ICLI_CMD_PROP_GREP

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_DEBUG_VLAN
HELP      = Show reference counts of bulk update

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_PRINTF("Current bulk update reference count: %u\n", vlan_bulk_update_ref_cnt_get());
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan bulk-update { enable | disable }
IF_FLAG   =
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Bulk update
HELP      = Enable callbacks of bulk VLAN registrants
HELP      = Disable callbacks of bulk VLAN registrants

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = b_enable
CMD_VAR   =

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if (b_enable) {
        vlan_bulk_update_begin();
    } else {
        vlan_bulk_update_end();
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan port-type interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror } { unaware | c-port | s-port | s-custom-port }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Port type
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user
HELP      = On ingress, all frames, whether carrying a VLAN tag or not, \
            get classified to the Port VLAN, and possible tags are not \
            removed on egress
HELP      = On ingress, frames with a VLAN tag with TPID = 0x8100 get \
            classified to the VLAN ID embedded in the tag. If a frame is \
            untagged or priority tagged, the frame gets classified to the \
            Port VLAN. If frames must be tagged on egress, they will be \
            tagged with a C-tag
HELP      = On ingress, frames with a VLAN tag with TPID = 0x8100 or \
            0x88A8 get classified to the VLAN ID embedded in the tag. \
            If a frame is untagged or priority tagged, the frame gets \
            classified to the Port VLAN. If frames must be tagged on egress, \
            they will be tagged with an S-tag
HELP      = On ingress, frames with a VLAN tag with a TPID = 0x8100 or equal \
            to the EtherType configured for Custom-S ports get classified to \
            the VLAN ID embedded in the tag. If a frame is untagged or \
            priority tagged, the frame gets classified to the Port VLAN. \
            If frames must be tagged on egress, they will be tagged with \
            the custom S-tag.

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror
CMD_VAR   = b_unaware
CMD_VAR   = b_c_port
CMD_VAR   = b_s_port
CMD_VAR   =

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    vtss_appl_vlan_port_type_t  port_type;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    if (b_unaware) {
        port_type = VTSS_APPL_VLAN_PORT_TYPE_UNAWARE;
    } else if (b_c_port) {
        port_type = VTSS_APPL_VLAN_PORT_TYPE_C;
    } else if (b_s_port) {
        port_type = VTSS_APPL_VLAN_PORT_TYPE_S;
    } else {
        port_type = VTSS_APPL_VLAN_PORT_TYPE_S_CUSTOM;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            conf.hybrid.port_type = port_type;
            conf.hybrid.flags |= VTSS_APPL_VLAN_PORT_FLAGS_AWARE;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan pvid interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror } <vlan_id>
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Port VLAN
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user
HELP      = Port VLAN ID

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror
CMD_VAR   = pvid

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            conf.hybrid.pvid = pvid;
            conf.hybrid.flags |= VTSS_APPL_VLAN_PORT_FLAGS_PVID;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan frame-type interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror } { all | tagged | untagged }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Type of frame
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user
HELP      = Both of tagged and untagged frames are considered
HELP      = Tagged frames are considered
HELP      = Untagged frames are considered

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror
CMD_VAR   = b_all
CMD_VAR   = b_tagged
CMD_VAR   =

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror
RUNTIME   =
RUNTIME   =
RUNTIME   =

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            if (b_all) {
                conf.hybrid.frame_type = MESA_VLAN_FRAME_ALL;
            } else if (b_tagged) {
                conf.hybrid.frame_type = MESA_VLAN_FRAME_TAGGED;
            } else {
                conf.hybrid.frame_type = MESA_VLAN_FRAME_UNTAGGED;
            }
            conf.hybrid.flags |= VTSS_APPL_VLAN_PORT_FLAGS_RX_TAG_TYPE;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan ingress-filter interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror } { enable | disable }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE) && defined(VTSS_SW_OPTION_VLAN_INGRESS_FILTERING)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Set ingress filter for volatile VLAN user
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user
HELP      = Enable ingress filter
HELP      = Disable ingress filter

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror
CMD_VAR   = b_enable
CMD_VAR   =

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror
RUNTIME   =
RUNTIME   =

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            conf.hybrid.ingress_filter = b_enable;
            conf.hybrid.flags |= VTSS_APPL_VLAN_PORT_FLAGS_INGR_FILT;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan tx-tag interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror } { tag-this <vlan_id> | untag-this <vlan_id> | tag-all | untag-all }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Set Tx tag type for volatile VLAN user
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user

HELP      = Frames classified to the Port VLAN are transmitted tagged. \
            Other frames are transmitted without tag.
HELP      = Port VLAN
HELP      = Frames classified to the Port VLAN are transmitted untagged. \
            Other frames are transmitted with the relevant tag.
HELP      = Port VLAN
HELP      = All frames, whether classified to the Port VLAN or not, \
            are transmitted with a tag.
HELP      = All frames, whether classified to the Port VLAN or not, \
            are transmitted without a tag.

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror

CMD_VAR   = b_tag_this
CMD_VAR   = tag_vid
CMD_VAR   = b_untag_this
CMD_VAR   = untag_vid
CMD_VAR   = b_tag_all
CMD_VAR   =

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            if (b_tag_this) {
                conf.hybrid.tx_tag_type  = VTSS_APPL_VLAN_TX_TAG_TYPE_TAG_THIS;
                conf.hybrid.untagged_vid = tag_vid;
            } else if (b_untag_this) {
                conf.hybrid.tx_tag_type  = VTSS_APPL_VLAN_TX_TAG_TYPE_UNTAG_THIS;
                conf.hybrid.untagged_vid = untag_vid;
            } else if (b_tag_all) {
                conf.hybrid.tx_tag_type = VTSS_APPL_VLAN_TX_TAG_TYPE_TAG_ALL;
            } else {
                conf.hybrid.tx_tag_type = VTSS_APPL_VLAN_TX_TAG_TYPE_UNTAG_ALL;
            }
            conf.hybrid.flags |= VTSS_APPL_VLAN_PORT_FLAGS_TX_TAG_TYPE;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan port-del interface <port_type_list> { static | dot1x | mvr | voice-vlan | mstp | erps | mrp | vcl | gvrp | rmirror }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Delete the VLAN port configuration set by volatile VLAN user
HELP      = Port interface
HELP      = Port list
HELP      = Static user
HELP      = NAS user
HELP      = MVR user
HELP      = Voice VLAN user
HELP      = MSTP user
HELP      = ERPS user
HELP      = MRP user
HELP      = VCL user
HELP      = GVRP user
HELP      = RMirror user

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   =
CMD_VAR   = b_dot1x
CMD_VAR   = b_mvr
CMD_VAR   = b_voice_vlan
CMD_VAR   = b_mstp
CMD_VAR   = b_erps
CMD_VAR   = b_mrp
CMD_VAR   = b_vcl
CMD_VAR   = b_gvrp
CMD_VAR   = b_rmirror

RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   =
RUNTIME   = VLAN_ICLI_runtime_nas
RUNTIME   = VLAN_ICLI_runtime_mvr
RUNTIME   = VLAN_ICLI_runtime_voice_vlan
RUNTIME   = VLAN_ICLI_runtime_mstp
RUNTIME   = VLAN_ICLI_runtime_erps
RUNTIME   = VLAN_ICLI_runtime_mrp
RUNTIME   = VLAN_ICLI_runtime_vcl
RUNTIME   = VLAN_ICLI_runtime_gvrp
RUNTIME   = VLAN_ICLI_runtime_rmirror

VARIABLE_BEGIN
    u32                         i;
    u32                         j;
    vtss_isid_t                 isid;
    mesa_port_no_t              iport;
    vtss_appl_vlan_user_t       vlan_user;
    mesa_rc                     rc;
    vtss_appl_vlan_port_conf_t  conf;
    u32                         usid;
    u32                         uport;
VARIABLE_END

CODE_BEGIN
    vlan_user = VTSS_APPL_VLAN_USER_STATIC;

    if (b_dot1x) {
        vlan_user = VTSS_APPL_VLAN_USER_DOT1X;
    } else if (b_mvr) {
        vlan_user = VTSS_APPL_VLAN_USER_MVR;
    } else if (b_voice_vlan) {
        vlan_user = VTSS_APPL_VLAN_USER_VOICE_VLAN;
    } else if (b_mstp) {
        vlan_user = VTSS_APPL_VLAN_USER_MSTP;
    } else if (b_erps) {
        vlan_user = VTSS_APPL_VLAN_USER_ERPS;
    } else if (b_mrp) {
        vlan_user = VTSS_APPL_VLAN_USER_IEC_MRP;
    } else if (b_vcl) {
        vlan_user = VTSS_APPL_VLAN_USER_VCL;
    } else if (b_gvrp) {
        vlan_user = VTSS_APPL_VLAN_USER_GVRP;
    } else if (b_rmirror) {
        vlan_user = VTSS_APPL_VLAN_USER_RMIRROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        // isid
        isid = plist->switch_range[i].isid;
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            if (vlan_mgmt_port_conf_get(isid, iport, &conf, vlan_user, TRUE) != VTSS_RC_OK) {
                continue;
            }

            conf.hybrid.flags = 0;

            conf.mode = VTSS_APPL_VLAN_PORT_MODE_HYBRID; // Required if user is VTSS_APPL_VLAN_USER_STATIC

            rc = vlan_mgmt_port_conf_set(isid, iport, &conf, vlan_user);
            if (rc != VTSS_RC_OK) {
                ICLI_PRINTF("%% usid = %u, uport = %u, %s\n", usid, uport, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug show vlan counter <vlan_id>
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC
PROPERTY  = ICLI_CMD_PROP_GREP

RUNTIME = vlan_icli_counters_present

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_DEBUG_VLAN
HELP      = Read the VLAN Counters from the Hardware
HELP      = VLAN ID

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid

VARIABLE_BEGIN
    mesa_vlan_counters_t    counter;
    mesa_rc                 rc;
VARIABLE_END

CODE_BEGIN
    ICLI_PRINTF("VLAN = %d\n", vid);

    rc = mesa_vlan_counters_get(NULL, vid, &counter);
    if (rc != VTSS_RC_OK) {
        ICLI_PRINTF("%% get VLAN counter, %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }

    ICLI_PRINTF("  unicast frames   : 0x" VPRI64x "\n", counter.rx_vlan_unicast.frames);
    ICLI_PRINTF("  unicast bytes    : 0x" VPRI64x "\n", counter.rx_vlan_unicast.bytes);
    ICLI_PRINTF("  multicast frames : 0x" VPRI64x "\n", counter.rx_vlan_multicast.frames);
    ICLI_PRINTF("  multicast bytes  : 0x" VPRI64x "\n", counter.rx_vlan_multicast.bytes);
    ICLI_PRINTF("  broadcast frames : 0x" VPRI64x "\n", counter.rx_vlan_broadcast.frames);
    ICLI_PRINTF("  broadcast bytes  : 0x" VPRI64x "\n", counter.rx_vlan_broadcast.bytes);
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug clear vlan counter <vlan_id>
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

RUNTIME = vlan_icli_counters_present

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_CLEAR
HELP      = ##HELP_DEBUG_VLAN
HELP      = VLAN Counter
HELP      = VLAN ID

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid

VARIABLE_BEGIN
    mesa_rc                 rc;
VARIABLE_END

CODE_BEGIN
    rc = mesa_vlan_counters_clear(NULL, vid);
    if (rc != VTSS_RC_OK) {
        ICLI_PRINTF("%% clear VLAN counter, %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug show vlan tag <vlan_id> interface <port_type_list>
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC
PROPERTY  = ICLI_CMD_PROP_GREP

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_DEBUG_VLAN
HELP      = Show VLAN Tx tag
HELP      = VLAN ID
HELP      = Port interface
HELP      = Port list

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid
CMD_VAR   =
CMD_VAR   = plist

VARIABLE_BEGIN
    CapArray<mesa_vlan_tx_tag_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> tx_tag;
    mesa_rc                 rc;
    u32                     i;
    u32                     j;
    mesa_port_no_t          iport;
    u32                     usid;
    u32                     uport;
VARIABLE_END

CODE_BEGIN
    rc = mesa_vlan_tx_tag_get(NULL, vid, tx_tag.size(), tx_tag.data());
    if (rc != VTSS_RC_OK) {
        ICLI_PRINTF("%% Get VLAN Tx tag configuration, %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }

    ICLI_PRINTF("USID  UPort  Tx Tag\n");
    ICLI_PRINTF("----  -----  ------\n");


    for (i = 0; i < plist->cnt; ++i) {
        // usid
        usid = plist->switch_range[i].usid;

        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;
            uport = plist->switch_range[i].begin_uport + j;

            ICLI_PRINTF("%-4u  %-5u  %s\n", usid, uport,
                tx_tag[iport] == MESA_VLAN_TX_TAG_PORT   ? "Port" :
                tx_tag[iport] == MESA_VLAN_TX_TAG_ENABLE ? "Enabled" : "Disabled");
        }
    }
    ICLI_PRINTF("\n");
CODE_END
CMD_END

#==============================================================================
#==============================================================================

CMD_BEGIN
COMMAND   = debug vlan tag <vlan_id> interface <port_type_list> { port | enable | disable }
IF_FLAG   = defined(VLAN_USER_DEBUG_CMD_ENABLE)
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_VLAN
HELP      = Set VLAN Tx tag
HELP      = VLAN ID
HELP      = Port interface
HELP      = Port list
HELP      = Egress tagging determined by VLAN port configuration
HELP      = Egress tagging enabled
HELP      = Egress tagging disabled

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = vid
CMD_VAR   =
CMD_VAR   = plist
CMD_VAR   = b_port
CMD_VAR   = b_enable
CMD_VAR   =


VARIABLE_BEGIN
    CapArray<mesa_vlan_tx_tag_t, MEBA_CAP_BOARD_PORT_MAP_COUNT> tx_tag;
    mesa_rc                 rc;
    u32                     i;
    u32                     j;
    mesa_port_no_t          iport;
VARIABLE_END

CODE_BEGIN
    rc = mesa_vlan_tx_tag_get(NULL, vid, tx_tag.size(), tx_tag.data());
    if (rc != VTSS_RC_OK) {
        ICLI_PRINTF("%% Get VLAN Tx tag configuration, %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }

    for (i = 0; i < plist->cnt; ++i) {
        for (j = 0; j < plist->switch_range[i].port_cnt; ++j) {
            // iport
            iport = plist->switch_range[i].begin_iport + j;

            if (b_port) {
                tx_tag[iport] = MESA_VLAN_TX_TAG_PORT;
            } else if (b_enable) {
                tx_tag[iport] = MESA_VLAN_TX_TAG_ENABLE;
            } else {
                tx_tag[iport] = MESA_VLAN_TX_TAG_DISABLE;
            }
        }
    }

    rc = mesa_vlan_tx_tag_set(NULL, vid, tx_tag.size(), tx_tag.data());
    if (rc != VTSS_RC_OK) {
        ICLI_PRINTF("%% Set VLAN Tx tag configuration, %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }
CODE_END
CMD_END

