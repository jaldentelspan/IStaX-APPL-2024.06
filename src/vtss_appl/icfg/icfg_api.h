/*
 Copyright (c) 2006-2024 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.
*/

#ifndef __ICFG_API_H__
#define __ICFG_API_H__

#include "vtss/basics/enum_macros.hxx"

/**
 * \file
 *
 * \brief ICFG API.
 *
 * \details ICFG implements a library of functions for text-mode synthesis of
 * the currently running configuration. This configuration is expressed as
 * a structured and ordered set of ICLI-format command lines.
 *
 * A module with relevant configuration information must register itself with
 * ICFG at system startup-time. The module inserts a callback function pointer
 * to itself into the hard-coded synthesis order defined by enum
 * #vtss_icfg_ordering_t.
 *
 * Then, later, when synthesis is requested by the operator (through the GUI or
 * CLI), all callbacks are invoked in the correct order and with relevant
 * parameters (struct #vtss_icfg_query_request_t), allowing the callbacks to
 * generate appropriate output.
 *
 * This generation is done using a #printf-style function, #vtss_icfg_printf,
 * into a result data structure, #vtss_icfg_query_result_t. Client modules
 * should treat this data type as opaque. One call to the printf function may
 * freely generate several lines of output.
 *
 * Note that there is an upper limit to the amount of text that can be generated
 * in one call to #vtss_icfg_printf: #VTSS_ICFG_QUERY_RESULT_BLOCK_SIZE.
 *
 * NOTE WELL: Registration must be performed on all switches in a stack, but
 *            all query-related functions are only valid on the switch stack's
 *            primary switch. Do not call on secondary switches or
 *            VTSS_RC_ERROR will be returned.
 *
 * Per-module Integration
 * ======================
 * For a module to integrate with ICLI, the following steps must be taken:
 *
 * 1. Determine where the module fits in the ordering, #vtss_icfg_ordering_t,
 *    and create new constants there. Observe the naming recommendations.
 *    Note that one module may appear several times in the ordering, but each
 *    time with a unique constant.
 *
 * 2. Create one or more callback functions with the prototype given by
 *    #vtss_icfg_query_func_t and, in the module's intialization, register them
 *    with ICFG using #vtss_icfg_query_register and the constants created in
 *    step 1.
 */

#include <sys/stat.h>
#include <main_types.h>
#include "icli_api.h"

/* for public APIs */
#include "vtss/appl/icfg.h"

/** \brief Comment lead-in.
 *
 * \details Comments are one-lined with a specific lead-in character. Callbacks
 * are allowed to generate comment lines, but must do so very sparingly and
 * only in essential cases. As a rule, don't try to tell the system
 * administrator things he/she can reasonably be expected to know.
 */
#define VTSS_ICFG_COMMENT_LEADIN "!"



/** \brief ICFG Query Ordering.
 *
 * \details This enum orders the output generated by ICFG querying all
 * registered callbacks.
 *
 * Some of the enum values are reserved and used for grouping per ICLI command
 * submode; they are recognizable by the ...BEGIN and ..._END suffixes.
 *
 * IMPORTANT: All enum names should obey this naming convention:
 *
 *     VTSS_ICFG_module-name_command-identity
 *
 * The module-name is obvious, e.g. PORT or VLAN; the command-identity should
 * identify the command/set-of-commands generated here.
 *
 * For example, we could imagine an identifier like VTSS_ICFG_PORT_SPEED_DUPLEX
 * for the port module's synthesis of 'speed' and 'duplex' commands.
 *
 * Note how global config can be inserted between all submodes, if appropriate.
 *
 * Note: It is not allowed for multiple modules to use the same position in the
 * ordering. This so we avoid unexpected behavior depending on, say, runtime
 * module initialization order.
 */

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
#ifdef VTSS_SW_OPTION_ICLI
    VTSS_ICFG_GLOBAL_ICLI,
#endif

    // System boot will occur a system boot log, so we run the syslog configuration first.
#if defined(VTSS_SW_OPTION_SYSLOG)
    VTSS_ICFG_SYSLOG_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_SYSLOG */

#ifdef VTSS_SW_OPTION_USERS
    VTSS_ICFG_GLOBAL_USERS,
#endif

#ifdef VTSS_SW_OPTION_SYSUTIL
    VTSS_ICFG_GLOBAL_SYSUTIL,
#endif

#ifdef VTSS_SW_OPTION_ACCESS_MGMT
    VTSS_ICFG_GLOBAL_ACCESS_MGMT,
#endif

#ifdef VTSS_SW_OPTION_LOOP_PROTECTION
    VTSS_ICFG_GLOBAL_LOOP_PROTECT,
#endif


#ifdef VTSS_SW_OPTION_DHCP_SERVER
    VTSS_ICFG_GLOBAL_DHCP_SERVER,
#endif

    //------------------------- VLAN submode begin ----------------------------
    VTSS_ICFG_VLAN_BEGIN,
#if defined(VTSS_SW_OPTION_VLAN)
    VTSS_ICFG_VLAN_CONF,
#endif /* VTSS_SW_OPTION_VLAN */
    VTSS_ICFG_VLAN_END,
    //------------------------- VLAN submode end ------------------------------

#if defined(VTSS_SW_OPTION_IPMC_LIB)
    VTSS_ICFG_IPMC_PROFILE_RANGE,

    //------------------------- IPMC profile submode begin --------------------
    VTSS_ICFG_IPMC_PROFILE_BEGIN,
    VTSS_ICFG_IPMC_PROFILE_CONF,
    VTSS_ICFG_IPMC_PROFILE_END,
    //------------------------- IPMC profile submode end ----------------------

    VTSS_ICFG_IPMC_PROFILE_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_IPMC_LIB */

#if defined(VTSS_SW_OPTION_SNMP)
    //------------------------- SNMP server host submode begin ----------------
    VTSS_ICFG_SNMPSERVER_HOST_BEGIN,
    VTSS_ICFG_TRAP_HOST_CONF,
    VTSS_ICFG_SNMPSERVER_HOST_END,
    //------------------------- SNMP server host submode end ------------------
#endif /* VTSS_SW_OPTION_SNMP */

#if defined(VTSS_SW_OPTION_JSON_RPC_NOTIFICATION)
    //------------------------- JSON-RPC Notification host submode begin -------
    VTSS_ICFG_JSON_NOTI_HOST_BEGIN,
    VTSS_ICFG_JSON_NOTI_HOST,
    VTSS_ICFG_JSON_NOTI_HOST_END,
    //------------------------- JSON-RPC Notification host submode end ---------
#endif /* VTSS_SW_OPTION_SNMP */

#ifdef VTSS_SW_OPTION_IP
    VTSS_ICFG_IPV4_GLOBAL,
#endif /* VTSS_SW_OPTION_IP */

#ifdef VTSS_SW_OPTION_IPV6
    VTSS_ICFG_IPV6_GLOBAL,
#endif /* VTSS_SW_OPTION_IPV6 */

#ifdef VTSS_SW_OPTION_ZTP
    VTSS_ICFG_ZTP_GLOBAL,
#endif /* VTSS_SW_OPTION_ZTP */

#ifdef VTSS_SW_OPTION_DNS
    VTSS_ICFG_IP_DNS_CONF,
#endif /* VTSS_SW_OPTION_DNS */

#if defined(VTSS_SW_OPTION_MVR)
    VTSS_ICFG_IPMC_MVR_GLOBAL,
    VTSS_ICFG_IPMC_MVR_INTF,
#endif /* VTSS_SW_OPTION_MVR */

#if defined(VTSS_SW_OPTION_IPMC)
    VTSS_ICFG_IPMC_IGMP_GLOBAL,
#if defined(VTSS_SW_OPTION_SMB_IPMC)
    VTSS_ICFG_IPMC_MLD_GLOBAL,
#endif /* VTSS_SW_OPTION_SMB_IPMC */
#endif /* VTSS_SW_OPTION_IPMC */

#if defined(VTSS_SW_OPTION_VLAN)
    VTSS_ICFG_VLAN_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_VLAN */

#if defined(VTSS_SW_OPTION_VCL)
    VTSS_ICFG_VCL_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_VCL */

#if defined(VTSS_SW_OPTION_DHCP_SNOOPING)
    VTSS_ICFG_DHCP_SNOOPING_GLOBAL_CONF,
    VTSS_ICFG_DHCP6_SNOOPING_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_DHCP_SNOOPING */

#if defined(VTSS_SW_OPTION_DHCP_RELAY)
    VTSS_ICFG_DHCP_RELAY_CONFIG,
#endif /* VTSS_SW_OPTION_DHCP_RELAY */

#if defined(VTSS_SW_OPTION_ARP_INSPECTION)
    VTSS_ICFG_ARP_INSPECTION_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_ARP_INSPECTION */
#if defined(VTSS_SW_OPTION_IP_SOURCE_GUARD)
    VTSS_ICFG_IP_SOURCE_GUARD_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_IP_SOURCE_GUARD */
#if defined(VTSS_SW_OPTION_IPV6_SOURCE_GUARD)
    VTSS_ICFG_IPV6_SOURCE_GUARD_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_IPV6_SOURCE_GUARD */
#if defined(VTSS_SW_OPTION_NTP)
    VTSS_ICFG_VTSS_NTP_GLOBAL_CONF,
#else
    VTSS_ICFG_VTSS_SNTP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_NTP */
#if defined(VTSS_SW_OPTION_DAYLIGHT_SAVING)
    VTSS_ICFG_DAYLIGHT_SAVING_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_DAYLIGHT_SAVING */

#if defined(VTSS_SW_OPTION_FAST_CGI) || defined(VTSS_SW_OPTION_HTTPS)
    VTSS_HTTPS_ICFG_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_HTTPS */

#if defined(VTSS_SW_OPTION_SSH)
    VTSS_SSH_ICFG_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_SSH */

#if defined(VTSS_SW_OPTION_MIRROR)
    VTSS_ICFG_MIRROR_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_MIRROR */

#if defined(VTSS_SW_OPTION_MAC)
    VTSS_ICFG_MAC_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_MAC */

#if defined(VTSS_SW_OPTION_AGGR)
    VTSS_ICFG_AGGR_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_AGGR */

#if defined(VTSS_SW_OPTION_LACP)
    VTSS_ICFG_LACP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_LACP */

#if defined(VTSS_SW_OPTION_MSTP)
    VTSS_ICFG_MSTP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_MSTP */

#if defined(VTSS_SW_OPTION_EEE)
    VTSS_ICFG_EEE_GLOBAL_CONF,
#endif // VTSS_SW_OPTION_EEE

#if defined(VTSS_SW_OPTION_FAN)
    VTSS_ICFG_FAN_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_FAN */

#if defined(VTSS_SW_OPTION_LED_POW_REDUC)
    VTSS_ICFG_LED_POW_REDUC_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_LED_POW_REDUC */

#if defined(VTSS_SW_OPTION_LLDP)
    VTSS_ICFG_LLDP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_LLDP */

#if defined(VTSS_SW_OPTION_LLDP_MED)
    VTSS_ICFG_LLDPMED_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_LLDP_MED */

#if defined(VTSS_SW_OPTION_SFLOW)
    VTSS_ICFG_SFLOW_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_SFLOW */

#if defined(VTSS_SW_OPTION_POE)
    VTSS_ICFG_POE_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_POE*/

#if defined(VTSS_SW_OPTION_THERMAL_PROTECT)
    VTSS_ICFG_THERMAL_PROTECT_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_THERMAL_PROTECT */

#if defined(VTSS_SW_OPTION_SNMP)
    VTSS_ICFG_SNMP_GLOBAL_CONF,
    VTSS_ICFG_TRAP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_SNMP */

#if defined(VTSS_SW_OPTION_AUTH)
    VTSS_ICFG_AUTH_AGENT_CONF,
    VTSS_ICFG_AUTH_RADIUS_CONF,
    VTSS_ICFG_AUTH_TACACS_CONF,
#endif /* VTSS_SW_OPTION_AUTH */

#if defined(VTSS_SW_OPTION_UPNP)
    VTSS_ICFG_UPNP_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_UPNP */

#if defined(VTSS_SW_OPTION_QOS)
    VTSS_ICFG_QOS_GLOBAL_CONF,
    VTSS_ICFG_QOS_QCE_CONF,
    //------------------------- QOS Ingress Map submode begin ---------------------
    VTSS_ICFG_QOS_INGRESS_MAP_BEGIN,
    VTSS_ICFG_QOS_INGRESS_MAP_CONF,
    VTSS_ICFG_QOS_INGRESS_MAP_END,
    //------------------------- QOS Ingress Map submode end -----------------------
    //------------------------- QOS Egress Map submode begin ---------------------
    VTSS_ICFG_QOS_EGRESS_MAP_BEGIN,
    VTSS_ICFG_QOS_EGRESS_MAP_CONF,
    VTSS_ICFG_QOS_EGRESS_MAP_END,
    //------------------------- QOS Egress Map submode end -----------------------
#endif /* VTSS_SW_OPTION_QOS */

#if defined(VTSS_SW_OPTION_STREAM)
    //------------------------- Stream submode begin ---------------------
    VTSS_ICFG_STREAM_BEGIN,
    VTSS_ICFG_STREAM_CONF,
    VTSS_ICFG_STREAM_END,
    //------------------------- Stream submode end -----------------------

    //------------------------- Stream collection submode begin ----------------
    VTSS_ICFG_STREAM_COLLECTION_BEGIN,
    VTSS_ICFG_STREAM_COLLECTION_CONF,
    VTSS_ICFG_STREAM_COLLECTION_END,
    //------------------------- Stream collection submode end ------------------
#endif /* VTSS_SW_OPTION_STREAM */

    //------------------------- TSN global ----------------
#if defined(VTSS_SW_OPTION_TSN)
    VTSS_ICFG_TSN_GLOBAL_CONF,
    VTSS_ICFG_TSN_FP_GLOBAL_CONF,
    VTSS_ICFG_TSN_TAS_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_TSN */

    //------------------------- Interface LLAG submode begin ----------------
    VTSS_ICFG_INTERFACE_LLAG_BEGIN,
#if defined(VTSS_SW_OPTION_LACP)
    VTSS_ICFG_LACP_INTERFACE_LLAG_CONF,
#endif /* VTSS_SW_OPTION_LACP */
    VTSS_ICFG_INTERFACE_LLAG_END,
    //------------------------- Interface LLAG submode end ----------------

#if defined(VTSS_SW_OPTION_ACL)
    VTSS_ICFG_ACL_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_ACL */

#ifdef VTSS_SW_OPTION_VOICE_VLAN
    VTSS_ICFG_GLOBAL_VOICE_VLAN,
#endif

#ifdef VTSS_SW_OPTION_PHY
    VTSS_ICFG_PHY_GLOBAL_CONF,
#endif





#if defined(VTSS_SW_OPTION_DOT1X)
    VTSS_ICFG_DOT1X_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_PSEC_LIMIT)
    VTSS_ICFG_PSEC_LIMIT_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_SYNCE)
    VTSS_ICFG_SYNCE_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_VLAN_TRANSLATION)
    VTSS_ICFG_VLAN_TRANSLATION_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_PRIV_LVL)
    VTSS_ICFG_WEB_PRIV_LVL_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_PTP)
    VTSS_ICFG_PTP_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_GVRP)
    VTSS_ICFG_GVRP_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_MVRP)
    VTSS_ICFG_MVRP_GLOBAL_CONF,
#endif

#if defined(VTSS_SW_OPTION_RMIRROR)
    VTSS_ICFG_RMIRROR_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_RMIRROR */

#if defined(VTSS_SW_OPTION_DDMI)
    VTSS_ICFG_DDMI_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_RMIRROR */

#if defined(VTSS_SW_OPTION_PHY_POWER_CONTROL)
    VTSS_ICFG_PORT_POWER_SAVINGS_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_PHY_POWER_CONTROL */

#if defined(VTSS_SW_OPTION_CFM)
    VTSS_ICFG_CFM_GLOBAL,

    //------------------------- CFM MD submode begin ----------------------------
    VTSS_ICFG_CFM_MD_BEGIN,
    VTSS_ICFG_CFM_MD,
    VTSS_ICFG_CFM_MD_END,
    //------------------------- CFM MD submode end ------------------------------
#endif /* VTSS_SW_OPTION_CFM */

    //------------------------- Interface Ethernet submode begin --------------
    VTSS_ICFG_INTERFACE_ETHERNET_BEGIN,

#ifdef VTSS_SW_OPTION_VOICE_VLAN
    VTSS_ICFG_INTERFACE_ETHERNET_VOICE_VLAN,
#endif

#ifdef VTSS_SW_OPTION_LOOP_PROTECTION
    VTSS_ICFG_INTERFACE_ETHERNET_LOOP_PROTECT,
#endif

#if defined(VTSS_SW_OPTION_VLAN)
    VTSS_ICFG_VLAN_PORT_CONF,
#endif /* VTSS_SW_OPTION_VLAN */

#if defined(VTSS_SW_OPTION_VCL)
    VTSS_ICFG_VCL_PORT_CONF,
#endif /* VTSS_SW_OPTION_VCL */

#if defined(VTSS_SW_OPTION_STREAM)
    VTSS_ICFG_STREAM_PORT_CONF,
#endif /* VTSS_SW_OPTION_STREAM */

#if defined(VTSS_SW_OPTION_PVLAN)
    VTSS_ICFG_PVLAN_PORT_CONF,
#endif /* VTSS_SW_OPTION_PVLAN */

#if defined(VTSS_SW_OPTION_MVR)
    VTSS_ICFG_IPMC_MVR_PORT,
#endif /* VTSS_SW_OPTION_MVR */

#if defined(VTSS_SW_OPTION_IPMC)
    VTSS_ICFG_IPMC_IGMP_PORT,
#if defined(VTSS_SW_OPTION_SMB_IPMC)
    VTSS_ICFG_IPMC_MLD_PORT,
#endif /* VTSS_SW_OPTION_SMB_IPMC */
#endif /* VTSS_SW_OPTION_IPMC */

#if defined(VTSS_SW_OPTION_DHCP_SNOOPING)
    VTSS_ICFG_DHCP_SNOOPING_PORT_CONF,
    VTSS_ICFG_DHCP6_SNOOPING_PORT_CONF,
#endif /* VTSS_SW_OPTION_DHCP_SNOOPING */

#if defined(VTSS_SW_OPTION_ARP_INSPECTION)
    VTSS_ICFG_ARP_INSPECTION_PORT_CONF,
#endif /* VTSS_SW_OPTION_ARP_INSPECTION */

#if defined(VTSS_SW_OPTION_IP_SOURCE_GUARD)
    VTSS_ICFG_IP_SOURCE_GUARD_PORT_CONF,
#endif /* VTSS_SW_OPTION_IP_SOURCE_GUARD */

#if defined(VTSS_SW_OPTION_IPV6_SOURCE_GUARD)
    VTSS_ICFG_IPV6_SOURCE_GUARD_PORT_CONF,
#endif /* VTSS_SW_OPTION_IPV6_SOURCE_GUARD */

#ifdef VTSS_SW_OPTION_RMON
    VTSS_ICFG_INTERFACE_ETHERNET_RMON,
#endif
#if defined(VTSS_SW_OPTION_LLDP)
    VTSS_ICFG_LLDP_PORT_CONF,
#endif /* VTSS_SW_OPTION_LLDP */

#if defined(VTSS_SW_OPTION_LLDP_MED)
    VTSS_ICFG_LLDPMED_PORT_CONF,
#endif /* VTSS_SW_OPTION_LLDP_MED */

#if defined(VTSS_SW_OPTION_SFLOW)
    VTSS_ICFG_SFLOW_PORT_CONF,
#endif /* VTSS_SW_OPTION_SFLOW */

#if defined(VTSS_SW_OPTION_POE)
    VTSS_ICFG_POE_PORT_CONF,
#endif /* VTSS_SW_OPTION_POE */

#if defined(VTSS_SW_OPTION_QOS)
    VTSS_ICFG_QOS_PORT_CONF,
#endif /* VTSS_SW_OPTION_QOS */

#if defined(VTSS_SW_OPTION_ACL)
    VTSS_ICFG_ACL_PORT_CONF,
#endif /* VTSS_SW_OPTION_ACL */

#if defined(VTSS_SW_OPTION_THERMAL_PROTECT)
    VTSS_ICFG_THERMAL_PROTECT_PORT_CONF,
#endif /* VTSS_SW_OPTION_THERMAL_PROTECT */

#if defined(VTSS_SW_OPTION_EEE)
    VTSS_ICFG_EEE_PORT_CONF,
#endif // VTSS_SW_OPTION_EEE

#if defined(VTSS_SW_OPTION_MAC)
    VTSS_ICFG_MAC_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_MAC */

#if defined(VTSS_SW_OPTION_MSTP)
    VTSS_ICFG_MSTP_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_MSTP */

#if defined(VTSS_SW_OPTION_LACP)
    VTSS_ICFG_LACP_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_LACP */

#if defined(VTSS_SW_OPTION_ETH_LINK_OAM)
    VTSS_ICFG_ETH_LINK_OAM_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_ETH_LINK_OAM */

#if defined(VTSS_SW_OPTION_SNMP)
    VTSS_ICFG_TRAP_PORT_CONF,
#endif /* VTSS_SW_OPTION_SNMP */

#if defined(VTSS_SW_OPTION_PORT)
    VTSS_ICFG_PORT_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_IP)
    VTSS_ICFG_IPV4_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_PHY_POWER_CONTROL)
    VTSS_ICFG_PORT_POWER_SAVINGS_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_DOT1X)
    VTSS_ICFG_DOT1X_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_DOT1X */

#if defined(VTSS_SW_OPTION_PSEC_LIMIT)
    VTSS_ICFG_PSEC_LIMIT_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_SYNCE)
    VTSS_ICFG_SYNCE_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_PTP)
    VTSS_ICFG_PTP_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_VLAN_TRANSLATION)
    VTSS_ICFG_VLAN_TRANSLATION_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_AGGR)
    VTSS_ICFG_AGGR_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_AGGR */

#if defined(VTSS_SW_OPTION_GVRP)
    VTSS_ICFG_GVRP_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_GVRP */

#if defined(VTSS_SW_OPTION_MRP)
    VTSS_ICFG_MRP_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_MVRP)
    VTSS_ICFG_MVRP_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_PHY)
    VTSS_ICFG_PHY_INTERFACE_CONF,
#endif

#if defined(VTSS_SW_OPTION_UDLD)
    VTSS_ICFG_UDLD_INTERFACE_CONF,
#endif /* VTSS_SW_OPTION_UDLD */

#if defined(VTSS_SW_OPTION_TSN)
    VTSS_ICFG_TSN_FP_PORT_CONF,
    VTSS_ICFG_TSN_TAS_PORT_CONF,
#endif /* VTSS_SW_OPTION_TSN */

#if defined(VTSS_SW_OPTION_KR)
    VTSS_ICFG_KR_CONF,
#endif





    VTSS_ICFG_INTERFACE_ETHERNET_END,
    //------------------------- Interface Ethernet submode end ----------------

    //------------------------- Interface VLAN submode begin ------------------
    VTSS_ICFG_INTERFACE_VLAN_BEGIN,

#ifdef VTSS_SW_OPTION_IP
    VTSS_ICFG_IPV4_VLAN_INTERFACE,
#endif /* VTSS_SW_OPTION_IP */

#ifdef VTSS_SW_OPTION_IPV6
    VTSS_ICFG_IPV6_VLAN_INTERFACE,
#endif /* VTSS_SW_OPTION_IPV6 */

#ifdef VTSS_SW_OPTION_DHCP6_CLIENT
    VTSS_ICFG_DHCP6C_INTERFACE,
#endif /* VTSS_SW_OPTION_DHCP6_CLIENT */

#ifdef VTSS_SW_OPTION_DHCP6_RELAY
    VTSS_ICFG_DHCP6_RELAY_INTERFACE,
#endif /* VTSS_SW_OPTION_DHCP6_RELAY */

#if defined(VTSS_SW_OPTION_IPMC)
    VTSS_ICFG_IPMC_IGMP_VLAN_INTERFACE,
#if defined(VTSS_SW_OPTION_SMB_IPMC)
    VTSS_ICFG_IPMC_MLD_VLAN_INTERFACE,
#endif /* VTSS_SW_OPTION_SMB_IPMC */
#endif /* VTSS_SW_OPTION_IPMC */

#ifdef VTSS_SW_OPTION_DHCP_SERVER
    VTSS_ICFG_INTERFACE_VLAN_DHCP_SERVER,
#endif

#ifdef VTSS_SW_OPTION_FRR_OSPF
    VTSS_ICFG_INTERFACE_VLAN_OSPF,
#endif /* VTSS_SW_OPTION_FRR_OSPF */

#ifdef VTSS_SW_OPTION_FRR_OSPF6
    VTSS_ICFG_INTERFACE_VLAN_OSPF6,
#endif /* VTSS_SW_OPTION_FRR_OSPF6 */

#ifdef VTSS_SW_OPTION_FRR_RIP
    VTSS_ICFG_INTERFACE_VLAN_RIP,
#endif /* VTSS_SW_OPTION_FRR_RIP */

    VTSS_ICFG_INTERFACE_VLAN_END,
    //------------------------- Interface VLAN submode end --------------------

#if defined(VTSS_SW_OPTION_APS)
    //------------------------- APS submode begin -----------------------------
    VTSS_ICFG_APS_BEGIN,
    VTSS_ICFG_APS,
    VTSS_ICFG_APS_END,
    //------------------------- APS submode end -------------------------------
#endif /* VTSS_SW_OPTION_APS */

#if defined(VTSS_SW_OPTION_ERPS)
    //------------------------- ERPS submode begin ----------------------------
    VTSS_ICFG_ERPS_BEGIN,
    VTSS_ICFG_ERPS,
    VTSS_ICFG_ERPS_END,
    //------------------------- ERPS submode end ------------------------------
#endif

#if defined(VTSS_SW_OPTION_IEC_MRP)
    //------------------------- MRP submode begin -----------------------------
    VTSS_ICFG_IEC_MRP_BEGIN,
    VTSS_ICFG_IEC_MRP,
    VTSS_ICFG_IEC_MRP_END,
    //------------------------- MRP submode end -------------------------------
#endif

#if defined(VTSS_SW_OPTION_REDBOX)
    //------------------------- Redbox submode begin ---------------------------
    VTSS_ICFG_REDBOX_BEGIN,
    VTSS_ICFG_REDBOX,
    VTSS_ICFG_REDBOX_END,
    //------------------------- Redbox submode end ----------------------------
#endif

    //------------------------- STP aggregation submode begin -----------------
    VTSS_ICFG_STP_AGGR_BEGIN,
#if defined(VTSS_SW_OPTION_MSTP)
    VTSS_ICFG_MSTP_AGGR_CONF,
#endif /* VTSS_SW_OPTION_MSTP */
    VTSS_ICFG_STP_AGGR_END,
    //------------------------- STP aggregation submode end -------------------

#ifdef VTSS_SW_OPTION_RMON
    VTSS_ICFG_GLOBAL_RMON,
#endif

#if defined(VTSS_SW_OPTION_JSON_RPC_NOTIFICATION)
    VTSS_ICFG_JSON_NOTI_LISTEN,
#endif

#if defined(VTSS_SW_OPTION_ALARM)
    VTSS_ICFG_ALARM_GLOBAL_CONF,
#endif /* VTSS_SW_OPTION_ALARM */

    //------------------------- DHCP pool submode begin -----------------------
#ifdef VTSS_SW_OPTION_DHCP_SERVER
    VTSS_ICFG_DHCP_POOL_BEGIN,
    VTSS_ICFG_DHCP_POOL_DHCP_SERVER,
    VTSS_ICFG_DHCP_POOL_END,
#endif
    //------------------------- DHCP pool submode end -------------------------

#if defined(VTSS_SW_OPTION_FRR_ROUTER)
    VTSS_ICFG_ROUTER_GLOBAL_CONF,

    //------------------------- Router key-chain submode begin ----------------------
    VTSS_ICFG_ROUTER_KEYCHAIN_BEGIN,
    VTSS_ICFG_ROUTER_KEYCHAIN_CONF,
    VTSS_ICFG_ROUTER_KEYCHAIN_END,
    //------------------------- Router key-chain submode end ------------------------
#endif

#if defined(VTSS_SW_OPTION_FRR_OSPF)
    //------------------------- OSPF router submode begin ----------------------
    VTSS_ICFG_OSPF_ROUTER_BEGIN,
    VTSS_ICFG_OSPF_ROUTER_CONF,
    VTSS_ICFG_OSPF_ROUTER_END,
    //------------------------- OSPF router submode end ------------------------
#endif

#if defined(VTSS_SW_OPTION_FRR_OSPF6)
    //------------------------- OSPF6 router submode begin ----------------------
    VTSS_ICFG_OSPF6_ROUTER_BEGIN,
    VTSS_ICFG_OSPF6_ROUTER_CONF,
    VTSS_ICFG_OSPF6_ROUTER_END,
    //------------------------- OSPF6 router submode end ------------------------
#endif

#if defined(VTSS_SW_OPTION_FRR_RIP)
    //------------------------- RIP router submode begin ----------------------
    VTSS_ICFG_RIP_ROUTER_BEGIN,
    VTSS_ICFG_RIP_ROUTER_CONF,
    VTSS_ICFG_RIP_ROUTER_END,
    //------------------------- RIP router submode end ------------------------
#endif /* VTSS_SW_OPTION_FRR_RIP */

#if defined(VTSS_SW_OPTION_TSN_PSFP)
    //------------------------- PSFP flow meter submode begin ----------------
    VTSS_ICFG_TSN_PSFP_FLOW_METER_BEGIN,
    VTSS_ICFG_TSN_PSFP_FLOW_METER_CONF,
    VTSS_ICFG_TSN_PSFP_FLOW_METER_END,
    //------------------------- PSFP flow meter submode end ----------------
    //------------------------- PSFP stream gate submode begin ----------------
    VTSS_ICFG_TSN_PSFP_GATE_BEGIN,
    VTSS_ICFG_TSN_PSFP_GATE_CONF,
    VTSS_ICFG_TSN_PSFP_GATE_END,
    //------------------------- PSFP stream gate submode end ----------------
    //------------------------- PSFP stream filter submode begin ----------------
    VTSS_ICFG_TSN_PSFP_FILTER_BEGIN,
    VTSS_ICFG_TSN_PSFP_FILTER_CONF,
    VTSS_ICFG_TSN_PSFP_FILTER_END,
    //------------------------- PSFP stream filter submode end ----------------
    //------------------------- FRER submode begin ----------------
    VTSS_ICFG_TSN_FRER_BEGIN,
    VTSS_ICFG_TSN_FRER_CONF,
    VTSS_ICFG_TSN_FRER_END,
    //------------------------- FRER submode end ----------------
#endif

    //------------------------- Line submode begin ----------------------------
    VTSS_ICFG_LINE_BEGIN,
#ifdef VTSS_SW_OPTION_ICLI
    VTSS_ICFG_LINE_ICLI,
#endif
    VTSS_ICFG_LINE_END,
    //------------------------- Line submode end ------------------------------

#ifdef VTSS_SW_OPTION_CPUPORT
    VTSS_ICFG_CPUPORT_GLOBAL_CONF,
#endif

    VTSS_ICFG_LAST
} vtss_icfg_ordering_t;

// VTSS_ENUM_INC(vtss_icfg_ordering_t)



/** \section Query Result API.
 *
 * \details These data structures and functions are used during synthesis of
 * configuration.
 *
 * The #vtss_icfg_query_result_t result structure is made up of a linked list
 * of #vtss_icfg_query_result_buf_t blocks of output. A new block is allocated
 * when the current (pointed to by #tail) runs out of capacity. NOTE that
 * a block may not be filled completely; observe #used. This also holds for
 * non-tail blocks, and is caused by the way printf is implemented.
 */

/** \brief One data block; linked list. text[] is always zero-terminated. */
typedef struct _vtss_icfg_query_result_buf_t {
    BOOL                                 free_text;  /* TRUE = text must be free'd at end-of-use */
    u32                                  used;    /* Number of chars used; index of next free char */
    u32                                  size;    /* Number of chars allocated for #text[] */
    struct _vtss_icfg_query_result_buf_t *next;   /* NULL == this is tail */
    char                                 *text; /* Text here; size is variable */
} vtss_icfg_query_result_buf_t;

/** \brief The query result data structure. Linked list.
 */
typedef struct {
    vtss_icfg_query_result_buf_t *head;   /* First buf filled in */
    vtss_icfg_query_result_buf_t *tail;   /* Current buf being filled in */
} vtss_icfg_query_result_t;

/** \brief Initialize a query result data structure.
 *
 * \details Only valid on stack's primary switch.
 *
 * \param initial_size [IN]     Size of first block in bytes. Zero == default
 * \param res          [IN/OUT] The result data structure
 *
 * \return VTSS_RC_OK on success; VTSS_RC_ERROR on memory allocation problems.
 */
mesa_rc vtss_icfg_init_query_result(u32 initial_size,
                                    vtss_icfg_query_result_t *res);

/** \brief Free all memory allocated by a query result data structure.
 * The structure is invalid after the call and must be re-initialized before
 * any further use.
 * \details Only valid on stack's primary switch.
 * \param res [IN/OUT] The result data structure.
 */
void vtss_icfg_free_query_result(vtss_icfg_query_result_t *res);

/** \brief Overlay a single text buffer with a vtss_icfg_query_result_t struct.
 * This is used to host "foreign" read-only data that won't be freed by
 * vtss_icfg_free_query_result(). res must be uninitialized at time of call.
 * \details Only valid on stack's primary switch.
 * \param res [IN/OUT] The result data structure.
 * \return VTSS_RC_OK on success; VTSS_RC_ERROR on memory allocation problems.
 */
mesa_rc vtss_icfg_overlay_query_result(char *buf, u32 length, vtss_icfg_query_result_t *res);

/** \brief printf into a result data structure.
 * \details Only valid on stack's primary switch.
 * \param res    [IN/OUT] The result data structure.
 * \param format [IN]     printf-style format string.
 * \return VTSS_RC_OK on success; VTSS_RC_ERROR on memory allocation problems.
 */
mesa_rc vtss_icfg_printf(vtss_icfg_query_result_t *res, const char *format, ...) __attribute__ ((format (printf, 2, 3)));

/** \section Query Request API.
 *
 * \details A module wanting to synthesize configuration must create one or
 * more callback functions which are then invoked by the ICFG core. The callback
 * function is provided with parameters that identify which ICLI mode that's
 * being processed at the moment plus mode-specific instance parameters.
 * Also, a result buffer structure is passed for filling in.
 *
 * For items in global config, the callback is only invoked once. For sub-modes
 * (e.g. interfaces or VLANs) the callback is invoked once per interface or
 * VLAN instance.
 */
typedef struct {
    icli_cmd_mode_t      cmd_mode;          /* ICLI command mode */
    vtss_icfg_ordering_t order;             /* Order */
    BOOL                 all_defaults;      /* TRUE == generate commands and parameters for default settings too. FALSE == only non-default */
    union {
        icli_switch_port_range_t port;      /* Not used for ranges, only single ports (port.port_cnt is always 1) */
        icli_unsigned_range_t    vlan_list;
        u32                      vlan;
        u32                      line;
        char                     string[64];
        u32                      llag_no;
        u32                      generic_u32;
#if defined(VTSS_SW_OPTION_QOS)
        u32                      map_id;    /* Map ID used in both ingress and egress map submode */
#endif /* VTSS_SW_OPTION_QOS */
    } instance_id;                          /* Instance identification */
} vtss_icfg_query_request_t;

/** \brief The struct used in vtss_icfg_conf_print function
 */

typedef struct {
    /**
     * Set to TRUE if the configuration value is the same as the default value.
     * FALSE otherwise.
     * Must be considered before every single call to vtss_icfg_conf_print().
     */
    BOOL is_default;

    /**
     * Set to FALSE to ignore all parameters for no commands.
     * This is ONLY used when req->all_defaults is TRUE and #is_default is TRUE
     * and #force_no_keyword is TRUE.
     * The "no" keyword is normally only used when the variable arguments is resulting
     * in an empty string, which means that it's a boolean that has a no-form to disable.
     * However, with #force_no_keyword, it's possible to change this behavior, so that
     * a no-form is used when #is_default is TRUE and req->all_defaults is TRUE.
     * In this case, the #print_no_arguments controls whether to ignore the resulting
     * variable argument string whether or not it's empty.
     *
     * Default after call to vtss_icfg_conf_print_init() is TRUE.
     */
    BOOL print_no_arguments;

    /**
     * If set to FALSE the default value is shown as
     * "no command". If set to TRUE the default value is printed as the real value
     *
     * Default after call to vtss_icfg_conf_print_init() is FALSE.
     */
    BOOL show_default_values;

    /**
     * A few ICLI commands MUST have the "no" keyword in front when printing all-defaults,
     * because without that keyword, it would enable the feature.
     * See also #print_no_arguments above.
     *
     * Default after call to vtss_icfg_conf_print_init() is FALSE.
     */
    BOOL force_no_keyword;

    /**
     * This is the ICFG request stored with call to vtss_icfg_conf_print_init().
     */
    const vtss_icfg_query_request_t *req;

    /**
     * This is the ICFG result stored with call to vtss_icfg_conf_print_init().
     */
    vtss_icfg_query_result_t *result;
} vtss_icfg_conf_print_t;

// See icfg_api.c
void vtss_icfg_conf_print_init(vtss_icfg_conf_print_t *conf_print, const vtss_icfg_query_request_t *req, vtss_icfg_query_result_t *result);

// See icfg_api.c
mesa_rc vtss_icfg_conf_print(vtss_icfg_conf_print_t *conf_print, const char *cmd_string, const char *format, ...) __attribute__((__format__(printf, 3, 4)));

/** \brief Callback signature.
 * \param req    [IN]     Request data.
 * \param result [IN/OUT] Result data. Treat as opaque.
 * \return Return value. VTSS_RC_ERROR on memory/parameter errors.
 */
typedef mesa_rc (*vtss_icfg_query_func_t)(const vtss_icfg_query_request_t *req,
                                          vtss_icfg_query_result_t *result);

/** \brief Query all modules and return the result.
 *
 * \details Only valid on stack's primary switch.
 *
 * Note: User must call #vtss_icfg_query_result_free(result) when done with the
 * results.
 *
 * \param all_defaults [IN]     TRUE: Callbacks should include all default
 *                              values
 * \param result       [IN/OUT] Result data. NOTE: #vtss_icfg_init_query_result
 *                              will be called by this function, so don't do it
 *                              in advance or memory will leak.
 */
mesa_rc vtss_icfg_query_all(BOOL                     all_defaults,
                            vtss_icfg_query_result_t *result);

/** \brief Query all modules for specific feature and return the result.
 *
 * \details Only valid on stack's primary switch.
 *
 * Note: User must call #vtss_icfg_query_result_free(result) when done with the
 * results.
 *
 * \param all_defaults [IN]     TRUE: Callbacks should include all default
 *                              values
 * \param feature_name [IN]     Name of feature
 * \param result       [IN/OUT] Result data. NOTE: #vtss_icfg_init_query_result
 *                              will be called by this function, so don't do it
 *                              in advance or memory will leak.
 */
mesa_rc vtss_icfg_query_feature(BOOL                     all_defaults,
                                const char *const        feature_name,
                                vtss_icfg_query_result_t *result);

/** \brief Query all modules for something specific and return the result.
 *
 * \details Only valid on stack's primary switch.
 *
 * Note: User must call #vtss_icfg_init_query_result(..., result) prior to
 * calling this function.
 *
 * Note: User must call #vtss_icfg_query_result_free(result) when done with the
 * results.
 *
 * \param req    [IN/OUT] Request. Note: req.order is ignored and overwritten.
 * \param result [IN/OUT] Result data. NOTE: #vtss_icfg_init_query_result will
 * be called by this function, so don't do it in advance or memory will leak.
 */
mesa_rc vtss_icfg_query_specific(vtss_icfg_query_request_t *req,
                                 vtss_icfg_query_result_t  *result);



/** \section Query Registration API.
 */


/** \brief Register callback at a particular position in the order.
 *
 * \details Valid on all switches in a stack.
 *
 * \param global_order [IN]   Where in the ordering to insert the #query_cb
 * \param feature_name [IN]   End-user-visible feature name, or NULL.
 *                            IMPORTANT: String must be static and const.
 * \param query_cb     [IN]   Callback.
 *
 * \return Result code. VTSS_RC_ERROR if insert failed (already used, bad
 * index).
 */
mesa_rc vtss_icfg_query_register(vtss_icfg_ordering_t   global_order,
                                 const char *const      feature_name,
                                 vtss_icfg_query_func_t query_cb);



/** \section Utilities.
 */

/** \brief Save running-config to startup-config
 *  \return NULL if save was OK, pointer to constant string error message
 *          otherwise
 */
const char *vtss_icfg_running_config_save(void);


/** \brief Commit set of lines to ICLI.
 *
 * \param session_id        [IN] ICLI session ID of open session, or
 *                               ICLI_SESSION_ID_NONE if temp. must be alloc'd
 * \param source_name       [IN] Source file name
 * \param syntax_check_only [IN] TRUE  == syntax check only, don't exec cmds;
 *                               FALSE == exec cmds
 * \param use_output_buffer [IN] TRUE  == command output/errors are stored in
 *                               an internal output buffer that can later be
 *                               accessed with icfg_output_buffer_get().
 *                               FALSE == output to session_id, or console if
 *                               ICLI_SESSION_ID_NONE
 * \param buffer            [IN] Buffer with lines to execute/syntax check
 * \return                       TRUE  == commit succeeded without errors
 *                               FALSE == errors occured during commit
 */
BOOL vtss_icfg_commit(u32                            session_id,
                      const char                     *source_name,
                      BOOL                           syntax_check_only,
                      BOOL                           use_output_buffer,
                      const vtss_icfg_query_result_t *buffer);

/** \brief Return list of feature words.
 *
 * \param cnt     [IN]  Number of pointers in list. Up to cnt-1 strings can be
 *                      returned.
 * \param list    [OUT] List of pointers to words. List is NULL-terminated.
 */
void vtss_icfg_feature_list_get(const u32 cnt, const char *list[]);



/** \section Initialization.
 *
 * ICFG slots into the initfun sequence in two locations:
 *
 * 1. As the first module. This is for INIT_CMD_CONF_DEF in order to stop the
 *    the ICFG loading thread such that the other modules can safely load
 *    their defaults.
 * 2. As the last module. The other relevant init commands are usually best run
 *    after the other modules have had a chance to act.
 */

/** \brief Early init function.
 *
 * \param data [IN] The initialization struct.
 */
mesa_rc vtss_icfg_early_init(vtss_init_data_t *data);

/** \brief Late init function.
 *
 * \param data [IN] The initialization struct.
 */
mesa_rc vtss_icfg_late_init(vtss_init_data_t *data);

#ifdef __cplusplus
}
#endif

/*lint -save -e19 */
VTSS_ENUM_INC(vtss_icfg_ordering_t);
/*lint -restore */

#endif /* __ICFG_API_H__ */
