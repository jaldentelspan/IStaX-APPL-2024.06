/*

 Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted but only in
 connection with products utilizing the Microsemi switch and PHY products.
 Permission is also granted for you to integrate into other products, disclose,
 transmit and distribute the software only in an absolute machine readable
 format (e.g. HEX file) and only in or with products utilizing the Microsemi
 switch and PHY products.  The source code of the software may not be
 disclosed, transmitted or distributed without the prior written permission of
 Microsemi.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software.  Microsemi retains all
 ownership, copyright, trade secret and proprietary rights in the software and
 its source code, including all modifications thereto.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
 WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
 ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
 WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
 NON-INFRINGEMENT.

*/
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined(VTSS_SW_OPTION_IP)
#include <resolv.h> // for res_init()
#include "ip_api.h"
#endif /* defined(VTSS_SW_OPTION_IP) */
#include "misc_api.h"

#include "vtss_dns.h"
#include "vtss_dns_oswrapper.h"

#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_IP_DNS

/* DNS functions */
typedef struct {
    mesa_ip_addr_t              adr;
    int                         idx;
    int                         err;
} active_dns_srv_t;

typedef struct {
    active_dns_srv_t            dns_server_setting[DNS_MAX_SRV_CNT];
    active_dns_srv_t            *current_dns_server;
    char                        default_domainname[DNS_MAX_NAME_LEN + 1];
} vtss_dns_lib_db_t;

static vtss_dns_lib_db_t        DNS_LIB_setting;
const char                      *DNS_LIB_filename = "/etc/resolv.conf";
static u32                      DNS_LIB_tick;

static mesa_rc DNS_LIB_resolv_conf(void)
{
    int                 fd;
    char                adrBuf[40], buf[96 + 8 + DNS_MAX_NAME_LEN + 1 + DNS_MAX_SRV_CNT * (56 + 1)];
    u8                  idx;
    active_dns_srv_t    *ns;

    T_D("START");

    if ((fd = open(DNS_LIB_filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) < 0) {
        T_D("Open/Create %s failed: [%s]\n", DNS_LIB_filename, strerror(errno));
        return VTSS_RC_ERROR;
    }

    memset(buf, 0x0, sizeof(buf));
    strcat(buf, "# MSCC NOTICE:\n");
    strcat(buf, "#            DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n");

    DNS_LIB_setting.current_dns_server = NULL;
    for (idx = 0; idx < DNS_MAX_SRV_CNT; ++idx) {
        ns = &DNS_LIB_setting.dns_server_setting[idx];
        if (ns->adr.type == MESA_IP_TYPE_NONE) {
            continue;
        }

        if (!DNS_LIB_setting.current_dns_server) {
            DNS_LIB_setting.current_dns_server = ns;
        }

        memset(adrBuf, 0x0, sizeof(adrBuf));

        strcat(buf, "nameserver ");
        if (ns->adr.type == MESA_IP_TYPE_IPV4) {
            strncat(buf, misc_ipv4_txt(ns->adr.addr.ipv4, adrBuf), strlen(adrBuf));
        }
        if (ns->adr.type == MESA_IP_TYPE_IPV6) {
            strncat(buf, misc_ipv6_txt(&ns->adr.addr.ipv6, adrBuf), strlen(adrBuf));
        }
        strcat(buf, "\n");
        T_D("Setup name server: %s", adrBuf);
    }
    if (strlen(DNS_LIB_setting.default_domainname) > 0) {
        strcat(buf, "domain ");
        strncat(buf, DNS_LIB_setting.default_domainname, strlen(DNS_LIB_setting.default_domainname));
        strcat(buf, "\n");
        T_D("Setup default domainname: %s", DNS_LIB_setting.default_domainname);
    }

    if (write(fd, buf, strlen(buf)) < 0) {
        T_D("Write/Update %s (len:%zd) failed: [%s]\n", DNS_LIB_filename, strlen(buf), strerror(errno));
    }

    if (close(fd) < 0) {
        T_D("Close %s failed: [%s]\n", DNS_LIB_filename, strerror(errno));
        return VTSS_RC_ERROR;
    }

    /* BZ#23061 - The return value of getaddrinfo()/gethostbyname won't be
     * updated due to glibc will cache the "/etc/resolv.conf" when getaddrinfo()
     * is called on the first take. The getaddrinfo() will always return an
     * error code(-3): "Name lookup failure"" even if a vaild name server is set
     * in "/etc/resolv.conf".
     * For example:
     *  1. No name server is set.
     *  2. Call getaddrinfo() --> return an error code (-3): "Name lookup failure"
     *  3. Add a vaild name server in "/etc/resolv.conf"
     *  4. Call getaddrinfo() --> return an error code (-3)
     *
     * Solution:
     * Need to call res_init() again when "/etc/resolv.conf" is updated.
     * Get more details from web site: https://github.com/saltstack/salt/issues/21397
     */
    (void)res_init();

    T_D("DONE");

    return VTSS_RC_OK;
}

void vtss_dns_lib_initialize(void)
{
    DNS_LIB_tick = 0;
    memset(&DNS_LIB_setting, 0x0, sizeof(vtss_dns_lib_db_t));

    if (DNS_LIB_resolv_conf() != VTSS_RC_OK) {
        T_I("Failed to update %s", DNS_LIB_filename);
    }
}

mesa_rc vtss_dns_lib_tick_cache(unsigned long tick)
{
#if 0 /* TODO: How to retrieve active DNS server in Linux? */
    FILE    *output;
    char    *ptr, result[128];
    BOOL    done;

#define DNS_LIB_TICK_PERIOD     0x7

    /* we do refresh active DNS server (as the meaning of 'cache') in Linux platforms */
    if ((++DNS_LIB_tick % DNS_LIB_TICK_PERIOD) != 0) {
        T_N("NEXT-TIME");
        return VTSS_RC_OK;
    }

    T_N("START(%lu)", tick);

    if ((output = popen("nslookup localhost", "r")) == NULL) {
        T_D("ERROR");
        return VTSS_RC_ERROR;
    }

    ptr = NULL;
    while (fgets(result, sizeof(result), output) != NULL) {
        if (strncmp(result, "Server:", 7) == 0) {
            result[strlen(result) - 1] = 0x0;
            ptr = rindex(result, ' ');
            ptr++;
            T_N("%s -> (%d):%s", result, strlen(ptr), ptr);
            break;
        }
    }

    pclose(output);

    done = FALSE;
    if (ptr != NULL && strcmp(ptr, "0.0.0.0") != 0) {
        char                adrBuf[40];
        u8                  idx;
        active_dns_srv_t    *ns;

        for (idx = 0; idx < DNS_MAX_SRV_CNT; ++idx) {
            ns = &DNS_LIB_setting.dns_server_setting[idx];
            if (ns->adr.type == MESA_IP_TYPE_NONE) {
                continue;
            }

            if (ns->adr.type == MESA_IP_TYPE_IPV4) {
                if (strcmp(ptr, misc_ipv4_txt(ns->adr.addr.ipv4, adrBuf)) == 0) {
                    done = TRUE;
                }
            }
            if (ns->adr.type == MESA_IP_TYPE_IPV6) {
                if (strcmp(ptr, misc_ipv6_txt(&ns->adr.addr.ipv6, adrBuf)) == 0) {
                    done = TRUE;
                }
            }

            if (done) {
                T_N("Update current DNS server: %s", ptr);
                DNS_LIB_setting.current_dns_server = ns;
                break;
            }
        }
    } else {
        done = TRUE;
        T_N("Reset current DNS server");
        DNS_LIB_setting.current_dns_server = NULL;
    }

    T_N("%sDONE(%u:%s)", done ? "" : "!", DNS_LIB_tick, ptr ? ptr : "NULL");
#endif /* TODO */
    return VTSS_RC_OK;
}

void vtss_dns_lib_query_name_get(unsigned char *dns_header_ptr, unsigned char *current_ptr, unsigned char *name)
{
    /*
        Linux platforms don't provide this utility and we don't need to do this for parsing DNS questions.
        Instead, vtss_dns_frame_parse_question_section() should be used.
    */
}

int vtss_dns_lib_build_qname(unsigned char *ptr, const char *hostname)
{
    int length;

    if (!ptr || !hostname) {
        return -1;
    }

    length = 0;
    if (strlen(hostname) > 0) {
        u8          position = 0, offset = 0;
        const char  *ns = hostname;

        T_D("Build for %s", hostname);

        while (*ns != 0x0) {
            length++;
            if (*ns == '.') {
                ptr[position] = offset;
                position = length;
                offset = 0;
            } else {
                offset++;
                ptr[position + offset] = *ns;
            }
            ns++;
        }
        ptr[position] = offset;
        length++;

        T_D_HEX(ptr, length);

        if (ptr[length - 1] == '.') {
            ptr[length - 1] = 0x0;
        } else {
            ptr[length] = 0x0;
            length++;
        }

        T_D("Length: %d", length);
    }

    return length;
}

mesa_rc vtss_dns_lib_current_server_get(mesa_ip_addr_t *const srv, u8 *const idx, i32 *const ecnt)
{
    char                adrBuf[40];
    active_dns_srv_t    *active_srv;

    if (!srv || !idx || !ecnt) {
        return VTSS_RC_ERROR;
    }

    memset(srv, 0x0, sizeof(mesa_ip_addr_t));
    active_srv = DNS_LIB_setting.current_dns_server;
    if (active_srv) {
        *srv = active_srv->adr;
        *idx = active_srv->idx;
        *ecnt = active_srv->err;
    } else {
        srv->type = MESA_IP_TYPE_NONE;
        *idx = DNS_DEF_SRV_IDX;
        *ecnt = 0;
    }

    T_N("Type:%u/Addr:%s/IDX:%u/ERR:%d", srv->type,
        srv->type == MESA_IP_TYPE_IPV6 ? misc_ipv6_txt(&srv->addr.ipv6, adrBuf) : misc_ipv4_txt(srv->addr.ipv4, adrBuf),
        *idx, *ecnt);
    return VTSS_RC_OK;
}

mesa_rc vtss_dns_lib_current_server_set(mesa_vid_t vidx, const mesa_ip_addr_t *const srv, u8 idx)
{
    u8                  chk;
    mesa_ip_addr_t      adr;
    active_dns_srv_t    *ety;
    char                adrBuf[40];

    if (idx > DNS_MAX_SRV_CNT) {
        return VTSS_RC_ERROR;
    }

    memset(&adr, 0x0, sizeof(mesa_ip_addr_t));
    if (!srv) {
        adr.type = MESA_IP_TYPE_NONE;
    } else {
        if (srv->type == MESA_IP_TYPE_IPV4) {
            memcpy(&adr, srv, sizeof(mesa_ip_addr_t));
        } else if (srv->type == MESA_IP_TYPE_IPV6) {
            memcpy(&adr, srv, sizeof(mesa_ip_addr_t));

            /* linklocal address needs scope ID */
            if (srv->addr.ipv6.addr[0] == 0xfe && (srv->addr.ipv6.addr[1] >> 6) == 0x2) {
                mesa_rc                       ifrc;
                vtss_appl_ip_if_status_link_t link_status;
                vtss_appl_ip_if_status_t      ipv6_status;
                vtss_ifindex_t                ifindex;

                (void)vtss_ifindex_from_vlan(vidx, &ifindex);
                if ((ifrc = vtss_appl_ip_if_status_link_get(ifindex, &link_status)) == VTSS_RC_OK &&
                    (ifrc = vtss_appl_ip_if_status_get(ifindex, VTSS_APPL_IP_IF_STATUS_TYPE_IPV6, 1, nullptr, &ipv6_status)) == VTSS_RC_OK) {
                    uint32_t ifidx = link_status.os_ifindex;
                    adr.addr.ipv6.addr[2] = (u8)((ifidx >> 8) & 0xFF);
                    adr.addr.ipv6.addr[3] = (u8)(ifidx & 0xFF);
                } else {
                    T_D("%s", error_txt(ifrc));
                }
            }
        } else {
            adr.type = MESA_IP_TYPE_NONE;
        }
    }

    T_N("IDX:%u / VID:%u / ADR:%s->%d", idx, vidx, srv ? misc_ipv6_txt(&srv->addr.ipv6, adrBuf) : "NULL", adr.type);

    for (chk = 0; chk < DNS_MAX_SRV_CNT; ++chk) {
        if (idx < DNS_MAX_SRV_CNT && chk != idx) {
            continue;
        }

        T_D("Update IDX-%u with %s", chk, adr.type == MESA_IP_TYPE_IPV6 ? misc_ipv6_txt(&adr.addr.ipv6, adrBuf) : misc_ipv4_txt(adr.addr.ipv4, adrBuf));
        ety = &DNS_LIB_setting.dns_server_setting[chk];
        ety->adr = adr;
        ety->idx = chk;
        ety->err = 0;
    }

    return DNS_LIB_resolv_conf();
}

mesa_rc vtss_dns_lib_current_server_rst(u8 idx)
{
    /* we don't need to reset anything in Linux platforms */
    return VTSS_RC_OK;
}

mesa_rc vtss_dns_lib_default_domainname_get(char *const ns)
{
    char current_name[DNS_MAX_NAME_LEN + 1];

    if (!ns) {
        return VTSS_RC_ERROR;
    }

    T_D("ENTER");
    memset(current_name, 0x0, sizeof(current_name));
    if (getdomainname(current_name, sizeof(current_name)) < 0) {
        T_D("ERROR");
        return VTSS_RC_ERROR;
    }

    if (strlen(current_name) > 0) {
        strncpy(ns, current_name, strlen(current_name));
        ns[strlen(current_name)] = 0;
    } else {
        ns[0] = 0;
    }
    T_D("GET Default-DomainName: %s->%s/" VPRIz, current_name, ns, strlen(ns));

    return VTSS_RC_OK;
}

mesa_rc vtss_dns_lib_default_domainname_set(const char *const ns)
{
    char    name_buf[DNS_MAX_NAME_LEN + 1];
    size_t  name_len;

    memset(name_buf, 0x0, sizeof(name_buf));
    if (!ns) {
        name_len = 0;
    } else {
        name_len = strlen(ns);
        if (name_len > 0 && name_len <= DNS_MAX_NAME_LEN) {
            strncpy(name_buf, ns, name_len);
        }
    }

    T_D("SET Default-DomainName: %s/" VPRIz, name_buf, name_len);

    memset(DNS_LIB_setting.default_domainname, 0x0, sizeof(DNS_LIB_setting.default_domainname));
    if (setdomainname(name_buf, name_len) >= 0) {
        if (name_len > 0 && name_len <= DNS_MAX_NAME_LEN) {
            strncpy(DNS_LIB_setting.default_domainname, name_buf, strlen(name_buf));
        }

        return DNS_LIB_resolv_conf();
    }

    T_D("Failed in setdomainname: [%s]\n", strerror(errno));

    return VTSS_RC_ERROR;
}
