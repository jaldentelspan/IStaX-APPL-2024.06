# Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.
#
# Unpublished rights reserved under the copyright laws of the United States of
# America, other countries and international treaties. Permission to use, copy,
# store and modify, the software and its source code is granted but only in
# connection with products utilizing the Microsemi switch and PHY products.
# Permission is also granted for you to integrate into other products, disclose,
# transmit and distribute the software only in an absolute machine readable
# format (e.g. HEX file) and only in or with products utilizing the Microsemi
# switch and PHY products.  The source code of the software may not be
# disclosed, transmitted or distributed without the prior written permission of
# Microsemi.
#
# This copyright notice must appear in any copy, modification, disclosure,
# transmission or distribution of the software.  Microsemi retains all
# ownership, copyright, trade secret and proprietary rights in the software and
# its source code, including all modifications thereto.
#
# THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
# WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
# ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
# NON-INFRINGEMENT.

MODULE_IF_FLAG =

INCLUDE_BEGIN
#include "icli_api.h"
#include "icli_porting_util.h"
#include "icfg_api.h"         /* For vtss_icfg_XXX()     */
#include "ipmc_lib_utils.hxx" /* For ipmc_lib_util_XXX() */
#include "misc_api.h"         /* For uport2iport()       */
#include "mgmt_api.h"         /* For MGMT_PORT_BUF_SIZE  */
#include "msg_api.h"          /* For msg_switch_exists() */
#include "standalone_api.h"   /* For topo_usid2isid()    */
#include <functional>         /* For std::function<>     */
#include <vtss/appl/mvr.h>
#include "ipmc_lib_trace.hxx"
INCLUDE_END

FUNCTION_BEGIN

// Need to include MVR's trace here, because ICLI defines its own that I don't
// want to use.
#undef VTSS_TRACE_MODULE_ID
#include "mvr_trace.h"

// Simple way of ICLI printing to both avoid session_id and to void the return
// value of icli_session_self_printf()
#define MVR_ICLI_PRINTF(...) (void)icli_session_self_printf(__VA_ARGS__)

#ifdef VTSS_SW_OPTION_ICFG
/******************************************************************************/
// MVR_ICFG_cmd_prefix_get()
// Many commands are on the form:
//   "mvr {vlan <vlan_id> | name <kword1-16>} bla-bla"
// If the MVR VLAN has a name, we use that when we print, otherwise we use the
// VLAN ID.
// This function fills a buffer with the correct prefix.
/******************************************************************************/
static const char *MVR_ICFG_cmd_prefix_get(char *buf, mesa_vid_t vid, const char *vlan_name)
{
    if (vlan_name[0] == '\0') {
        sprintf(buf, "vlan %u", vid);
    } else {
        sprintf(buf, "name %s", vlan_name);
    }

    return buf;
}
#endif /* VTSS_SW_OPTION_ICFG */

#ifdef VTSS_SW_OPTION_ICFG
/******************************************************************************/
// MVR_ICFG_global_conf_print()
/******************************************************************************/
static mesa_rc MVR_ICFG_global_conf_print(const vtss_icfg_query_request_t *req, vtss_icfg_query_result_t *result)
{
    vtss_appl_ipmc_lib_key_t         key = {};
    vtss_appl_ipmc_lib_global_conf_t global_conf, global_default_conf;

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same global config.
    VTSS_RC(vtss_appl_ipmc_lib_global_conf_get        (key, &global_conf));
    VTSS_RC(vtss_appl_ipmc_lib_global_conf_default_get(key, &global_default_conf));

    // Commands in ICLI_CMD_MODE_GLOBAL_CONFIG mode:
    //  [no] mvr
    if (req->all_defaults || global_conf.admin_active != global_default_conf.admin_active) {
        VTSS_RC(vtss_icfg_printf(result, "%smvr\n", global_conf.admin_active ? "" : "no "));
    }

    return VTSS_RC_OK;
}
#endif /* VTSS_SW_OPTION_ICFG */

#ifdef VTSS_SW_OPTION_ICFG
/******************************************************************************/
// MVR_ICFG_port_conf_print()
/******************************************************************************/
static mesa_rc MVR_ICFG_port_conf_print(const vtss_icfg_query_request_t *req, vtss_icfg_query_result_t *result)
{
    vtss_appl_ipmc_lib_key_t            key = {};
    vtss_appl_ipmc_lib_vlan_key_t       vlan_key = {};
    vtss_appl_ipmc_lib_port_conf_t      port_conf, port_conf_default;
    vtss_appl_ipmc_lib_vlan_port_conf_t vlan_port_conf, vlan_port_conf_default;
    vtss_appl_ipmc_lib_vlan_conf_t      vlan_conf;
    vtss_icfg_conf_print_t              conf_print;
    mesa_port_no_t                      port_no;
    char                                vlan_or_name_buf[sizeof(vlan_conf.name) + 10], cmd_buf[sizeof(vlan_or_name_buf) + 50];

    // Commands in ICLI_CMD_MODE_INTERFACE_PORT_LIST mode:
    //  [no] mvr immediate-leave
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} type [{source | receiver}]

    vtss_icfg_conf_print_init(&conf_print, req, result);
    conf_print.print_no_arguments = false;
    conf_print.force_no_keyword   = true;

    port_no = uport2iport(req->instance_id.port.begin_uport);
    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same port config.

    VTSS_RC(vtss_appl_ipmc_lib_port_conf_get(             key, port_no, &port_conf));
    VTSS_RC(vtss_appl_ipmc_lib_port_conf_default_get(     key,          &port_conf_default));
    VTSS_RC(vtss_appl_ipmc_lib_vlan_port_conf_default_get(key,          &vlan_port_conf_default));

    // [no] immediate_leave
    // We want to use the no-form here
    conf_print.is_default = port_conf.fast_leave == port_conf_default.fast_leave;
    VTSS_RC(vtss_icfg_conf_print(&conf_print, "mvr immediate-leave", "%s", ""));

    // [no] mvr {vlan <vlan_list> | name <kword1-16>} type [{source | receiver}]
    vlan_key.is_mvr  = true;
    vlan_key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same VLAN config.
    while (vtss_appl_ipmc_lib_vlan_itr(&vlan_key, &vlan_key, true /* stay in this vlan_key */) == VTSS_RC_OK) {
        // Get the role
        VTSS_RC(vtss_appl_ipmc_lib_vlan_port_conf_get(vlan_key, port_no, &vlan_port_conf));

        // We need the VLAN conf only to see if we need the name-version or the
        // VLAN version.
        VTSS_RC(vtss_appl_ipmc_lib_vlan_conf_get(vlan_key, &vlan_conf));

        // The command either has a VLAN ID or a name. Get the correct prefix
        // for it.
        sprintf(cmd_buf, "mvr %s type", MVR_ICFG_cmd_prefix_get(vlan_or_name_buf, vlan_key.vid, vlan_conf.name));
        conf_print.is_default = vlan_port_conf.role == vlan_port_conf_default.role;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%s", ipmc_lib_util_port_role_to_str(vlan_port_conf.role)));
    }

    return VTSS_RC_OK;
}
#endif /* VTSS_SW_OPTION_ICFG */

#ifdef VTSS_SW_OPTION_ICFG
/******************************************************************************/
// MVR_ICFG_vlan_conf_print()
/******************************************************************************/
static mesa_rc MVR_ICFG_vlan_conf_print(const vtss_icfg_query_request_t *req, vtss_icfg_query_result_t *result)
{
    vtss_appl_ipmc_lib_vlan_key_t  vlan_key = {};
    vtss_appl_ipmc_lib_vlan_conf_t vlan_conf, vlan_conf_default;
    vtss_icfg_conf_print_t         conf_print;
    bool                           has_name;
    char                           vlan_or_name_buf[sizeof(vlan_conf.name) + 10], cmd_buf[sizeof(vlan_or_name_buf) + 50], ipv4_buf[20];
    mesa_rc                        rc;

    // Commands in ICLI_CMD_MODE_GLOBAL_CONFIG mode:
    //       mvr  vlan <vlan_list>  [name <kword1-16>]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} igmp-address [<ipv4_ucast>]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} mode [{dynamic | compatible}]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} frame priority [<0-7>]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} frame tagged
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} last-member-query-interval [<0-31744>]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} channel [<word16>]
    //  [no] mvr {vlan <vlan_list> | name <kword1-16>} election // Put last to be able to run-time check qi vs. qri (not used on MVR though)

    vtss_icfg_conf_print_init(&conf_print, req, result);
    conf_print.print_no_arguments = false;
    conf_print.force_no_keyword   = true;

    vlan_key.is_mvr  = true;
    vlan_key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same port config.
    VTSS_RC(vtss_appl_ipmc_lib_vlan_conf_default_get(static_cast<vtss_appl_ipmc_lib_key_t>(vlan_key), &vlan_conf_default));

    while (vtss_appl_ipmc_lib_vlan_itr(&vlan_key, &vlan_key, true /* stay in this vlan_key */) == VTSS_RC_OK) {
        if ((rc = vtss_appl_ipmc_lib_vlan_conf_get(vlan_key, &vlan_conf)) != VTSS_RC_OK) {
            // Someone deleted it while we iterated?
            T_IG(MVR_TRACE_GRP_ICLI, "vtss_appl_ipmc_lib_vlan_conf_get(%s) failed: %s", vlan_key, error_txt(rc));
            continue;
        }

        has_name = vlan_conf.name[0] != '\0';

        // mvr vlan <vlan_list> [name <kword1-16>]
        conf_print.is_default = false;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, "mvr vlan", "%u%s%s", vlan_key.vid, has_name ? " name " : "", vlan_conf.name));

        // All subsequent commands either have a VLAN ID or a name. Get the
        // correct prefix for the commands.
        (void)MVR_ICFG_cmd_prefix_get(vlan_or_name_buf, vlan_key.vid, vlan_conf.name);

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} igmp-address [<ipv4_ucast>]
        sprintf(cmd_buf, "mvr %s igmp-address", vlan_or_name_buf);
        conf_print.is_default = vlan_conf.querier_address == vlan_conf_default.querier_address;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%s", vlan_conf.querier_address.print(ipv4_buf)));

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} mode [{dynamic | compatible}]
        // Don't use the no-form when printing.
        conf_print.force_no_keyword = false;
        sprintf(cmd_buf, "mvr %s mode", vlan_or_name_buf);
        conf_print.is_default = vlan_conf.compatible_mode == vlan_conf_default.compatible_mode;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%s", ipmc_lib_util_compatible_mode_to_str(vlan_conf.compatible_mode)));

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} frame priority [<0-7>]
        // Don't use the no-form when printing.
        conf_print.force_no_keyword = false;
        sprintf(cmd_buf, "mvr %s frame priority", vlan_or_name_buf);
        conf_print.is_default = vlan_conf.pcp == vlan_conf_default.pcp;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%u", vlan_conf.pcp));

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} frame tagged
        // Default of this is true. Unfortunately, vtss_icfg_conf_print()
        // doesn't support true default booleans...
        if (req->all_defaults || vlan_conf.tx_tagged != vlan_conf_default.tx_tagged) {
            sprintf(cmd_buf, "mvr %s frame tagged", vlan_or_name_buf);
            VTSS_RC(vtss_icfg_printf(result, "%s%s\n", vlan_conf.tx_tagged ? "" : "no ", cmd_buf));
        }

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} last-member-query-interval [<0-31744>]
        // Don't use the no-form when printing.
        conf_print.force_no_keyword = false;
        sprintf(cmd_buf, "mvr %s last-member-query-interval", vlan_or_name_buf);
        conf_print.is_default = vlan_conf.lmqi == vlan_conf_default.lmqi;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%u", vlan_conf.lmqi));

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} channel [<word16>]
        conf_print.force_no_keyword = true;
        sprintf(cmd_buf, "mvr %s channel", vlan_or_name_buf);
        conf_print.is_default = strcmp(vlan_conf.channel_profile.name, vlan_conf_default.channel_profile.name) == 0;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%s", vlan_conf.channel_profile.name));

        // [no] mvr {vlan <vlan_list> | name <kword1-16>} election
        sprintf(cmd_buf, "mvr %s election", vlan_or_name_buf);
        conf_print.is_default = vlan_conf.querier_enable == vlan_conf_default.querier_enable;
        VTSS_RC(vtss_icfg_conf_print(&conf_print, cmd_buf, "%s", ""));
    }

    return VTSS_RC_OK;
}
#endif /* VTSS_SW_OPTION_ICFG */

#ifdef VTSS_SW_OPTION_ICFG
/******************************************************************************/
// mvr_icfg_init()
/******************************************************************************/
mesa_rc mvr_icfg_init(void)
{
    VTSS_RC(vtss_icfg_query_register(VTSS_ICFG_IPMC_MVR_GLOBAL, "mvr", MVR_ICFG_global_conf_print));
    VTSS_RC(vtss_icfg_query_register(VTSS_ICFG_IPMC_MVR_INTF,   "mvr", MVR_ICFG_vlan_conf_print));
    VTSS_RC(vtss_icfg_query_register(VTSS_ICFG_IPMC_MVR_PORT,   "mvr", MVR_ICFG_port_conf_print));

    return VTSS_RC_OK;
}
#endif /* VTSS_SW_OPTION_ICFG */

/*******************************************************************************/
// MVR_ICLI_vlan_name_to_vid()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_name_to_vid(const char *name, mesa_vid_t &vid)
{
    mesa_rc rc;

    if ((rc = vtss_appl_ipmc_lib_vlan_name_to_vid(name, &vid)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to get MVR VLAN ID from %s: %s\n", name, error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_global_admin_active_set()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_global_admin_active_set(bool active)
{
    vtss_appl_ipmc_lib_key_t         key;
    vtss_appl_ipmc_lib_global_conf_t global_conf;
    mesa_rc                          rc;

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since the global conf is identical for IGMP and MLD
    if ((rc = vtss_appl_ipmc_lib_global_conf_get(key, &global_conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to get global MVR configuration: %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }

    global_conf.admin_active = active;

    if ((rc = vtss_appl_mvr_global_conf_set(&global_conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to set global MVR configuration: %s\n", error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_vlan_conf_get()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_conf_get(mesa_vid_t vid, vtss_appl_ipmc_lib_vlan_conf_t &vlan_conf)
{
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;
    mesa_rc                       rc;

    vlan_key.is_mvr  = true;
    vlan_key.is_ipv4 = true; // Doesn't matter, since the conf is identical for IGMP and MLD (except for querier address).
    vlan_key.vid     = vid;

    if ((rc = vtss_appl_ipmc_lib_vlan_conf_get(vlan_key, &vlan_conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to obtain current MVR VLAN configuration for VLAN ID %u: %s\n", vid, error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_vlan_conf_set()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_conf_set(mesa_vid_t vid, vtss_appl_ipmc_lib_vlan_conf_t &conf)
{
    mesa_rc rc;

    if ((rc = vtss_appl_mvr_vlan_conf_set(vid, &conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to set MVR VLAN configuration for VLAN ID %u: %s\n", vid, error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_vlan_conf_get_by_name()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_conf_get_by_name(const char *name, vtss_appl_ipmc_lib_vlan_conf_t &conf, mesa_vid_t &vid)
{
    ICLI_RC(MVR_ICLI_vlan_name_to_vid(name, vid));
    return MVR_ICLI_vlan_conf_get(vid, conf);
}

/*******************************************************************************/
// MVR_ICLI_vlan_port_conf_get()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_port_conf_get(mesa_vid_t vid, mesa_port_no_t port_no, vtss_appl_ipmc_lib_vlan_port_conf_t &conf)
{
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;
    char                          if_str[40];
    mesa_rc                       rc;

    vlan_key.is_mvr  = true;
    vlan_key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same config.
    vlan_key.vid     = vid;

    (void)icli_port_info_txt_short(VTSS_USID_START, iport2uport(port_no), if_str);

    if ((rc = vtss_appl_ipmc_lib_vlan_port_conf_get(vlan_key, port_no, &conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to obtain port configuration for port %s on MVR VLAN ID %u: %s\n", if_str, vid, error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_vlan_port_conf_set()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_port_conf_set(mesa_vid_t vid, mesa_port_no_t port_no, vtss_appl_ipmc_lib_vlan_port_conf_t &conf)
{
    char    if_str[40];
    mesa_rc rc;

    (void)icli_port_info_txt_short(VTSS_USID_START, iport2uport(port_no), if_str);

    if ((rc = vtss_appl_mvr_vlan_port_conf_set(vid, port_no, &conf)) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to set port configuration for port %s on MVR VLAN ID %u: %s\n", if_str, vid, error_txt(rc));
        return ICLI_RC_ERROR;
    }

    return ICLI_RC_OK;
}

/*******************************************************************************/
// MVR_ICLI_vlan_port_conf_get_by_name()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_port_conf_get_by_name(const char *name, mesa_port_no_t port_no, vtss_appl_ipmc_lib_vlan_port_conf_t &conf, mesa_vid_t &vid)
{
    ICLI_RC(MVR_ICLI_vlan_name_to_vid(name, vid));
    return MVR_ICLI_vlan_port_conf_get(vid, port_no, conf);
}

/*******************************************************************************/
// MVR_ICLI_vlan_conf_get_set()
/*******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_conf_get_set(bool use_defaults, mesa_vid_t vid, bool election, bool mode, bool prio, bool adr4, bool tagged, bool lmqi, uint32_t val)
{
    vtss_appl_ipmc_lib_key_t       key;
    vtss_appl_ipmc_lib_ip_t        qa;
    vtss_appl_ipmc_lib_vlan_conf_t vlan_conf, vlan_conf_default;
    mesa_rc                        rc;

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same config.

    if (use_defaults) {
        if ((rc = vtss_appl_ipmc_lib_vlan_conf_default_get(key, &vlan_conf_default)) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% Unable to get MVR VLAN default configuration: %s\n", error_txt(rc));
            return ICLI_RC_ERROR;
        }
    } else {
        // Not used, but to satisfy the compiler and lint tools.
        vtss_clear(vlan_conf_default);
    }

    qa.is_ipv4 = true;
    qa.ipv4    = val;

    ICLI_RC(MVR_ICLI_vlan_conf_get(vid, vlan_conf));

    if (election) {
        vlan_conf.querier_enable  = use_defaults ? vlan_conf_default.querier_enable  : !!val;
    } else if (mode) {
        vlan_conf.compatible_mode = use_defaults ? vlan_conf_default.compatible_mode : !!val;
    } else if (prio) {
        vlan_conf.pcp             = use_defaults ? vlan_conf_default.pcp             : val;
    } else if (adr4) {
        vlan_conf.querier_address = use_defaults ? vlan_conf_default.querier_address : qa;
    } else if (tagged) {
        vlan_conf.tx_tagged       = use_defaults ? vlan_conf_default.tx_tagged       : !!val;
    } else if (lmqi) {
        vlan_conf.lmqi            = use_defaults ? vlan_conf_default.lmqi            : val;
    } else {
        MVR_ICLI_PRINTF("%% No values were set\n");
        return ICLI_RC_ERROR;
    }

    return MVR_ICLI_vlan_conf_set(vid, vlan_conf);
}

/******************************************************************************/
// MVR_ICLI_vlan_conf_all_set()
/******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_conf_all_set(bool use_defaults, icli_unsigned_range_t *vlan_list, const char *name, bool election, bool mode, bool prio, bool adr4, bool tagged, bool lmqi, uint32_t val)
{
    uint32_t   idx;
    mesa_vid_t vid;

    if (vlan_list) {
        for (idx = 0; idx < vlan_list->cnt; idx++) {
            for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
                ICLI_RC(MVR_ICLI_vlan_conf_get_set(use_defaults, vid, election, mode, prio, adr4, tagged, lmqi, val));
            }
        }
    } else {
        ICLI_RC(MVR_ICLI_vlan_name_to_vid(name, vid));
        ICLI_RC(MVR_ICLI_vlan_conf_get_set(use_defaults, vid, election, mode, prio, adr4, tagged, lmqi, val));
    }

    return ICLI_RC_OK;
}

/******************************************************************************/
// MVR_ICLI_vlan_channel_profile_set()
/******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_channel_profile_set(bool use_defaults, icli_unsigned_range_t *vlan_list, const char *name, const char *channel_profile)
{
    vtss_appl_ipmc_lib_key_t       key;
    vtss_appl_ipmc_lib_vlan_conf_t vlan_conf, vlan_conf_default;
    uint32_t                       idx;
    mesa_vid_t                     vid;
    mesa_rc                        rc;

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same config.

    if (use_defaults) {
        if ((rc = vtss_appl_ipmc_lib_vlan_conf_default_get(key, &vlan_conf_default)) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% Unable to get MVR VLAN default configuration: %s\n", error_txt(rc));
            return ICLI_RC_ERROR;
        }
    } else {
        // Not used, but to satisfy the compiler and lint tools.
        vtss_clear(vlan_conf_default);
    }

    if (vlan_list) {
        for (idx = 0; idx < vlan_list->cnt; idx++) {
            for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
                if (MVR_ICLI_vlan_conf_get(vid, vlan_conf) != ICLI_RC_OK) {
                    continue;
                }

                strncpy(vlan_conf.channel_profile.name, use_defaults ? vlan_conf_default.channel_profile.name : channel_profile, sizeof(vlan_conf.channel_profile.name));
                ICLI_RC(MVR_ICLI_vlan_conf_set(vid, vlan_conf));
            }
        }
    } else {
        ICLI_RC(MVR_ICLI_vlan_conf_get_by_name(name, vlan_conf, vid));
        strncpy(vlan_conf.channel_profile.name, use_defaults ? vlan_conf_default.channel_profile.name : channel_profile, sizeof(vlan_conf.channel_profile.name));
        ICLI_RC(MVR_ICLI_vlan_conf_set(vid, vlan_conf));
    }

    return ICLI_RC_OK;
}

/******************************************************************************/
// MVR_ICLI_immediate_leave_set()
/******************************************************************************/
static icli_rc_t MVR_ICLI_immediate_leave_set(icli_stack_port_range_t *port_list, bool immediate_leave)
{
    vtss_appl_ipmc_lib_key_t       key;
    vtss_appl_ipmc_lib_port_conf_t port_conf;
    port_iter_t                    pit;
    char                           if_str[40];

    if (icli_port_iter_init(&pit, VTSS_ISID_START, PORT_ITER_FLAGS_NORMAL) != VTSS_RC_OK) {
        MVR_ICLI_PRINTF("%% Unable to initialize port iterator\n");
        return ICLI_RC_ERROR;
    }

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same port config.

    while (icli_port_iter_getnext(&pit, port_list)) {
        if (vtss_appl_ipmc_lib_port_conf_get(key, pit.iport, &port_conf) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% %s: Unable to get configuration for interface\n", icli_port_info_txt_short(VTSS_USID_START, pit.uport, if_str));
            continue;
        }

        port_conf.fast_leave = immediate_leave;

        if (vtss_appl_mvr_port_conf_set(pit.iport, &port_conf) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% %s: Unable to set configuration for interface\n", icli_port_info_txt_short(VTSS_USID_START, pit.uport, if_str));
            continue;
        }
    }

    return ICLI_RC_OK;
}

/******************************************************************************/
// MVR_ICLI_vlan_port_role_conf_set()
/******************************************************************************/
static icli_rc_t MVR_ICLI_vlan_port_role_conf_set(bool use_defaults, icli_stack_port_range_t *port_list, icli_unsigned_range_t *vlan_list, const char *name, vtss_appl_ipmc_lib_port_role_t role)
{
    vtss_appl_ipmc_lib_key_t            key;
    vtss_appl_ipmc_lib_vlan_port_conf_t vlan_port_conf, vlan_port_conf_default;
    uint32_t                            idx, mdx, rdx;
    mesa_port_no_t                      port_no;
    mesa_vid_t                          vid;
    mesa_rc                             rc;

    key.is_mvr  = true;
    key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same port config.

    if (use_defaults) {
        if ((rc = vtss_appl_ipmc_lib_vlan_port_conf_default_get(key, &vlan_port_conf_default)) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% Unable to get default MVR VLAN port configuration\n");
            return ICLI_RC_ERROR;
        }
    } else {
        // Not used, but to satisfy the compiler and lint tools.
        vtss_clear(vlan_port_conf_default);
    }

    for (rdx = 0; rdx < port_list->cnt; rdx++) {
        for (idx = 0; idx < port_list->switch_range[rdx].port_cnt; idx++) {
            port_no = uport2iport(port_list->switch_range[rdx].begin_uport + idx);

            if (vlan_list) {
                for (mdx = 0; mdx < vlan_list->cnt; mdx++) {
                    for (vid = vlan_list->range[mdx].min; vid <= vlan_list->range[mdx].max; vid++) {
                        if (MVR_ICLI_vlan_port_conf_get(vid, port_no, vlan_port_conf) != ICLI_RC_OK) {
                            continue;
                        }

                        vlan_port_conf.role = use_defaults ? vlan_port_conf_default.role : role;

                        (void)MVR_ICLI_vlan_port_conf_set(vid, port_no, vlan_port_conf);
                    }
                }
            } else {
                if (MVR_ICLI_vlan_port_conf_get_by_name(name, port_no, vlan_port_conf, vid) != ICLI_RC_OK) {
                    continue;
                }

                vlan_port_conf.role = use_defaults ? vlan_port_conf_default.role : role;

                (void)MVR_ICLI_vlan_port_conf_set(vid, port_no, vlan_port_conf);
            }
        }
    }

    return ICLI_RC_OK;
}

/******************************************************************************/
// mvr_icli_vlan_itr_t
/******************************************************************************/
typedef struct {
    // Input set by caller
    bool need_global_conf;
    bool need_conf;
    bool need_conf_default;
    bool need_status;
    bool need_statistics;

    // If both name and vlan_list are nullptr, it iterates across all defined
    // MVR VLANs with vtss_appl_ipmc_lib_vlan_itr().
    // Otherwise, if vlan_list is not nullptr, it iterates across all VLANs in
    // vlan_list.
    // Otherwise (name is not nullptr), it iterates only across the VLAN defined
    // by this name.
    icli_unsigned_range_t *vlan_list;
    const char             *vlan_name;
    mesa_vid_t             name_vid; // The VLAN ID corresponding to name.

    // Administered internally and may be used by caller
    bool                          has_more_than_one_vlan;
    uint32_t                      vlan_cnt; // Counts the number of times MVR_ICLI_vlan_itr() has returned true. Is 1 the first time.
    vtss_appl_ipmc_lib_vlan_key_t vlan_key; // Don't use vlan_key.is_ipv4.

    // The configuration is identical for IGMP and MLD...
    vtss_appl_ipmc_lib_global_conf_t global_conf;
    vtss_appl_ipmc_lib_vlan_conf_t   conf;
    vtss_appl_ipmc_lib_vlan_conf_t   conf_default;

    // ...but the status differs
    struct {
        const char                           *proto_txt; // "IGMP" or "MLD"
        vtss_appl_ipmc_lib_vlan_status_t     status;
        vtss_appl_ipmc_lib_vlan_statistics_t statistics;
    } data[2]; // [0] == IGMP, [1] = MLD

    // Private data
    // User should use \p first to figure out whether this is the first VLAN
    // in the range or not.
    bool     not_first;
    uint32_t idx;
} mvr_icli_vlan_itr_t;

/******************************************************************************/
// MVR_ICLI_itr_get_next()
/******************************************************************************/
static bool MVR_ICLI_vlan_itr_get_next(mvr_icli_vlan_itr_t &itr)
{
    if (itr.vlan_list) {
        // Use the supplied VLAN list
        if (itr.idx >= itr.vlan_list->cnt) {
            // No more ranges.
            return false;
        }

        if (itr.vlan_key.vid < itr.vlan_list->range[itr.idx].min) {
            itr.vlan_key.vid = itr.vlan_list->range[itr.idx].min;
        } else if (itr.vlan_key.vid >= itr.vlan_list->range[itr.idx].max) {
            if (++itr.idx >= itr.vlan_list->cnt) {
                return false;
            }

            itr.vlan_key.vid = itr.vlan_list->range[itr.idx].min;
        } else {
            itr.vlan_key.vid++;
        }
    } else if (itr.vlan_name) {
        if (itr.vlan_cnt) {
            // name_vid already used.
            return false;
        }

        itr.vlan_key.vid = itr.name_vid;
    } else {
        // Use the defined VLANs to find the next
        if (vtss_appl_ipmc_lib_vlan_itr(&itr.vlan_key, &itr.vlan_key, true /* don't mix IPMC/MVR and IGMP/MLD */) != VTSS_RC_OK) {
            // No more defined VLANs.
            return false;
        }
    }

    T_IG(MVR_TRACE_GRP_ICLI, "Next vid = %u", itr.vlan_key.vid);

    return true;
}

/******************************************************************************/
// MVR_ICLI_print_vlan_error()
/******************************************************************************/
static mesa_rc MVR_ICLI_print_vlan_error(mvr_icli_vlan_itr_t &itr, const char *txt, int idx, mesa_rc rc)
{
    if (rc == VTSS_RC_OK) {
        return rc;
    }

    if (itr.has_more_than_one_vlan) {
        if (idx != -1) {
            if (txt && txt[0] != '\0') {
                icli_session_self_printf("%% %s on VLAN interface %u: %s: %s\n", itr.data[idx].proto_txt, itr.vlan_key.vid, txt, error_txt(rc));
            } else {
                icli_session_self_printf("%% %s on VLAN interface %u: %s\n",     itr.data[idx].proto_txt, itr.vlan_key.vid, error_txt(rc));
            }
        } else {
            if (txt && txt[0] != '\0') {
                icli_session_self_printf("%% VLAN interface %u: %s: %s\n", itr.vlan_key.vid, txt, error_txt(rc));
            } else {
                icli_session_self_printf("%% VLAN interface %u: %s\n",     itr.vlan_key.vid, error_txt(rc));
            }
        }
    } else {
        if (txt && txt[0] != '\0') {
            icli_session_self_printf("%% %s: %s\n", txt, error_txt(rc));
        } else {
            icli_session_self_printf("%% %s\n", error_txt(rc));
        }
    }

    return rc;
}

/******************************************************************************/
// MVR_ICLI_vlan_itr()
/******************************************************************************/
static bool MVR_ICLI_vlan_itr(mvr_icli_vlan_itr_t &itr)
{
    int     i;
    bool    err;
    mesa_rc rc;

    if (!itr.not_first) {
        itr.vlan_key.is_mvr   = true;
        itr.vlan_key.is_ipv4  = true;
        itr.vlan_key.vid      = 0;
        itr.idx               = 0;
        itr.not_first         = true;
        itr.vlan_cnt          = 0;
        itr.data[0].proto_txt = "IGMP";
        itr.data[1].proto_txt = "MLD";

        if (itr.vlan_list) {
            itr.has_more_than_one_vlan = itr.vlan_list->cnt > 1 || itr.vlan_list->range[0].min < itr.vlan_list->range[0].max;
        } else if (itr.vlan_name) {
            itr.has_more_than_one_vlan = false;
            if (MVR_ICLI_vlan_name_to_vid(itr.vlan_name, itr.name_vid) != ICLI_RC_OK) {
                // Error already printed
                return false;
            }
        } else {
            // Here, we don't know if more than one VLAN interface exists, but
            // let's assume there are.
            itr.has_more_than_one_vlan = true;
        }

        if (itr.need_global_conf) {
            if ((rc = vtss_appl_ipmc_lib_global_conf_get(static_cast<vtss_appl_ipmc_lib_key_t>(itr.vlan_key), &itr.global_conf)) != VTSS_RC_OK) {
                MVR_ICLI_PRINTF("%% Unable to get global MVR configuration: %s", error_txt(rc));
                return false;
            }
        }

        if (itr.need_conf_default) {
            if ((rc = vtss_appl_ipmc_lib_vlan_conf_default_get(static_cast<vtss_appl_ipmc_lib_key_t>(itr.vlan_key), &itr.conf_default)) != VTSS_RC_OK) {
                MVR_ICLI_PRINTF("%% Unable to get default MVR VLAN configuration: %s", error_txt(rc));
                return false;
            }
        }
    }

    while (MVR_ICLI_vlan_itr_get_next(itr)) {
        if (itr.need_conf) {
            if ((rc = vtss_appl_ipmc_lib_vlan_conf_get(itr.vlan_key, &itr.conf)) != VTSS_RC_OK) {
                (void)MVR_ICLI_print_vlan_error(itr, "Unable to get MVR VLAN configuration", -1, rc);
                continue;
            }
        }

        // Status and statistics are not shared amongst IGMP and MLD.
        err = false;
        for (i = 0; i < ARRSZ(itr.data); i++) {
            itr.vlan_key.is_ipv4 = i == 0;

            if (itr.need_status) {
                if ((rc = vtss_appl_ipmc_lib_vlan_status_get(itr.vlan_key, &itr.data[i].status)) != VTSS_RC_OK) {
                    (void)MVR_ICLI_print_vlan_error(itr, "Unable to get VLAN status", i, rc);
                    err = true;
                    break;
                }
            }

            if (itr.need_statistics) {
                if ((rc = vtss_appl_ipmc_lib_vlan_statistics_get(itr.vlan_key, &itr.data[i].statistics)) != VTSS_RC_OK) {
                    (void)MVR_ICLI_print_vlan_error(itr, "Unable to get VLAN statistics", i, rc);
                    err = true;
                    break;
                }
            }
        }

        if (err) {
            continue;
        }

        itr.vlan_cnt++;
        return true;
    }

    return false;
}

/******************************************************************************/
// MVR_ICLI_privilege_level_check()
/******************************************************************************/
static BOOL MVR_ICLI_privilege_level_check(uint32_t session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    icli_privilege_t current_priv;

    if (ask != ICLI_ASK_PRESENT) {
        return false;
    }

    runtime->present = ICLI_PRIVILEGE_GET(&current_priv) == ICLI_RC_OK && current_priv >= ICLI_PRIVILEGE_15;
    return true;
}

/******************************************************************************/
// MVR_ICLI_stati_summarize()
/******************************************************************************/
static uint32_t MVR_ICLI_stati_summarize(vtss_appl_ipmc_lib_igmp_vlan_statistics_t &s, bool queries)
{
    uint32_t result;

    if (queries) {
        result = s.v1_query + s.v2_g_query + s.v2_gs_query + s.v3_g_query + s.v3_gs_query + s.v3_gss_query;
    } else {
        result = s.v1_report + s.v2_report + s.v2_leave + s.v3_report;
    }

    return result;
}

/******************************************************************************/
// MVR_ICLI_stati_summarize()
/******************************************************************************/
static uint32_t MVR_ICLI_stati_summarize(vtss_appl_ipmc_lib_mld_vlan_statistics_t &s, bool queries)
{
    uint32_t result;

    if (queries) {
        result = s.v1_g_query + s.v1_gs_query + s.v2_g_query + s.v2_gs_query + s.v2_gss_query;
    } else {
        result = s.v1_report + s.v1_done + s.v2_report;
    }

    return result;
}

/******************************************************************************/
// MVR_ICLI_stati_line()
/******************************************************************************/
static void MVR_ICLI_stati_line(const char *name, int name_width, uint32_t *rx_util, uint32_t *rx_igno, uint32_t *tx)
{
     MVR_ICLI_PRINTF("%-*s", name_width, name);

     if (rx_util) {
         MVR_ICLI_PRINTF(" %12u", *rx_util);
     } else {
         MVR_ICLI_PRINTF("%13s", "");
     }

     if (rx_igno) {
         MVR_ICLI_PRINTF(" %10u", *rx_igno);
     } else {
         MVR_ICLI_PRINTF("%11s", "");
     }

     if (tx) {
         MVR_ICLI_PRINTF(" %10u\n", *tx);
     } else {
         MVR_ICLI_PRINTF("\n");
     }
}

/******************************************************************************/
// MVR_ICLI_vlan_statistics_do_show()
/******************************************************************************/
static void MVR_ICLI_vlan_statistics_do_show(mvr_icli_vlan_itr_t &itr, bool wants_details)
{
    uint32_t  rx_q, tx_q, rx_r, tx_r;
    const int width = 51;
    int       i;

#define MVR_ICLI_IGMP_STATI_LINE(_n_, _c_) MVR_ICLI_stati_line(_n_, width, &itr.data[0].statistics.rx.igmp.utilized._c_, &itr.data[0].statistics.rx.igmp.ignored._c_, &itr.data[0].statistics.tx.igmp._c_)
#define MVR_ICLI_MLD_STATI_LINE( _n_, _c_) MVR_ICLI_stati_line(_n_, width, &itr.data[1].statistics.rx.mld.utilized._c_,  &itr.data[1].statistics.rx.mld.ignored._c_,  &itr.data[1].statistics.tx.mld._c_)

    if (wants_details) {
        MVR_ICLI_PRINTF("VLAN %u Statistics:\n", itr.vlan_key.vid);

        MVR_ICLI_PRINTF("Counter                                             Rx Processed Rx Ignored Tx\n");
        MVR_ICLI_PRINTF("--------------------------------------------------- ------------ ---------- ----------\n");

        MVR_ICLI_IGMP_STATI_LINE("IGMPv1 Joins",                             v1_report);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv1 Queries",                           v1_query);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv2 Joins",                             v2_report);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv2 Leaves",                            v2_leave);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv2 General Queries",                   v2_g_query);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv2 Group-Specific Queries",            v2_gs_query);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv3 Reports",                           v3_report);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv3 General Queries",                   v3_g_query);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv3 Group-Specific Queries",            v3_gs_query);
        MVR_ICLI_IGMP_STATI_LINE("IGMPv3 Group-and-Source-Specific Queries", v3_gss_query);
        MVR_ICLI_stati_line(     "IGMP Error Packets", width, nullptr, &itr.data[0].statistics.rx_errors, nullptr);

        MVR_ICLI_MLD_STATI_LINE("MLDv1 Reports",                                       v1_report);
        MVR_ICLI_MLD_STATI_LINE("MLDv1 Dones",                                         v1_done);
        MVR_ICLI_MLD_STATI_LINE("MLDv1 General Queries",                               v1_g_query);
        MVR_ICLI_MLD_STATI_LINE("MLDv1 Multicast-Address-Specific Queries",            v1_gs_query);
        MVR_ICLI_MLD_STATI_LINE("MLDv2 Reports",                                       v2_report);
        MVR_ICLI_MLD_STATI_LINE("MLDv2 General Queries",                               v2_g_query);
        MVR_ICLI_MLD_STATI_LINE("MLDv2 Multicast-Address-Specific Queries",            v2_gs_query);
        MVR_ICLI_MLD_STATI_LINE("MLDv2 Multicast-Address-and-Source-Specific Queries", v2_gss_query);
        MVR_ICLI_stati_line(    "MLD Error Packets", width, nullptr, &itr.data[1].statistics.rx_errors, nullptr);
        MVR_ICLI_PRINTF("\n");
    } else {
        if (itr.vlan_cnt == 1) {
            // First iteration
            MVR_ICLI_PRINTF("VLAN Protocol Rx Queries Tx Queries Rx Reports Tx Reports Rx Errors\n");
            MVR_ICLI_PRINTF("---- -------- ---------- ---------- ---------- ---------- ----------\n");
        }

        for (i = 0; i < ARRSZ(itr.data); i++) {
            if (i == 0) {
                rx_q = MVR_ICLI_stati_summarize(itr.data[0].statistics.rx.igmp.utilized, true) +  MVR_ICLI_stati_summarize(itr.data[0].statistics.rx.igmp.ignored, true);
                tx_q = MVR_ICLI_stati_summarize(itr.data[0].statistics.tx.igmp, true);
                rx_r = MVR_ICLI_stati_summarize(itr.data[0].statistics.rx.igmp.utilized, false) + MVR_ICLI_stati_summarize(itr.data[0].statistics.rx.igmp.ignored, false);
                tx_r = MVR_ICLI_stati_summarize(itr.data[0].statistics.tx.igmp, false);
            } else {
                rx_q = MVR_ICLI_stati_summarize(itr.data[1].statistics.rx.mld.utilized, true) +  MVR_ICLI_stati_summarize(itr.data[1].statistics.rx.mld.ignored, true);
                tx_q = MVR_ICLI_stati_summarize(itr.data[1].statistics.tx.mld, true);
                rx_r = MVR_ICLI_stati_summarize(itr.data[1].statistics.rx.mld.utilized, false) + MVR_ICLI_stati_summarize(itr.data[1].statistics.rx.mld.ignored, false);
                tx_r = MVR_ICLI_stati_summarize(itr.data[1].statistics.tx.mld, false);
            }

            MVR_ICLI_PRINTF("%4u %-8s %10u %10u %10u %10u %10u\n", itr.vlan_key.vid, itr.data[i].proto_txt, rx_q, tx_q, rx_r, tx_r, itr.data[i].statistics.rx_errors);
        }
    }

}

/******************************************************************************/
// MVR_ICLI_vlan_statistics_show()
/******************************************************************************/
static void MVR_ICLI_vlan_statistics_show(icli_unsigned_range_t *vlan_list, const char *name, bool wants_details)
{
    mvr_icli_vlan_itr_t itr = {};

    itr.vlan_list       = vlan_list;
    itr.vlan_name       = name;
    itr.need_statistics = true;

    while (MVR_ICLI_vlan_itr(itr)) {
        MVR_ICLI_vlan_statistics_do_show(itr, wants_details);
    }

    if (!wants_details) {
        MVR_ICLI_PRINTF("\n");
    }
}

/******************************************************************************/
// MVR_ICLI_port_filter_out()
// Returns false if port_range is nullptr (indicating the user hasn't specified
// any particular ports to view) or if port_no is set in port_list.
// Returns true to not show port_no.
/******************************************************************************/
static bool MVR_ICLI_port_filter_out(icli_stack_port_range_t *port_range, mesa_port_no_t &port_no)
{
    uint32_t       range_idx, port_cnt, port_idx;
    mesa_port_no_t start_port_no;

    if (!port_range) {
        // Display this entry
        return false;
    }
    for (range_idx = 0; range_idx < port_range->cnt; range_idx++) {
        port_cnt      = port_range->switch_range[range_idx].port_cnt;
        start_port_no = port_range->switch_range[range_idx].begin_iport;
        for (port_idx = 0; port_idx < port_cnt; port_idx++) {
            if (port_no == start_port_no + port_idx) {
                // Display this entry
                return false;
            }
        }
    }

    // Don't display this entry
    return true;
}

/******************************************************************************/
// MVR_ICLI_src_show()
/******************************************************************************/
static void MVR_ICLI_src_show(icli_unsigned_range_t *vlan_list, const char *vlan_name, icli_stack_port_range_t *port_list, bool wants_details)
{
    mvr_icli_vlan_itr_t             itr = {};
    vtss_appl_ipmc_lib_vlan_key_t   vlan_key;
    vtss_appl_ipmc_lib_src_status_t src_status;
    mesa_vid_t                      prev_vid;
    vtss_appl_ipmc_lib_ip_t         grp, src = {}, prev_grp;
    mesa_port_no_t                  port_no = MESA_PORT_NO_NONE, prev_port_no;
    uint32_t                        grp_cnt = 0, src_cnt = 0;
    bool                            is_asm, differs_from_prev;
    char                            vid_buf[10], grp_buf[40], if_str[40], src_buf[40], grp_timeout_buf[20], src_timeout_buf[20];
    int                             i;
    mesa_rc                         rc;

    itr.vlan_list = vlan_list;
    itr.vlan_name = vlan_name;

    if (wants_details) {
        MVR_ICLI_PRINTF("VLAN Group Address                           Interface  Source Address                          Filter Mode Fwd Grp Timeout Src Timeout In H/W\n");
        MVR_ICLI_PRINTF("---- --------------------------------------- ---------- --------------------------------------- ----------- --- ----------- ----------- ------\n");
    } else {
        MVR_ICLI_PRINTF("VLAN Group Address                           Interface  Source Address                          Filter Mode Fwd\n");
        MVR_ICLI_PRINTF("---- --------------------------------------- ---------- --------------------------------------- ----------- ---\n");
    }

    while (MVR_ICLI_vlan_itr(itr)) {
        for (i = 0; i < ARRSZ(itr.data); i++) {
            vtss_clear(grp);
            vlan_key.vid     = itr.vlan_key.vid;
            vlan_key.is_mvr  = true;
            vlan_key.is_ipv4 = i == 0;
            grp.is_ipv4      = i == 0;

            // Whenever we start on a new VLAN or protocol, make sure to show
            // the entire line by setting prev_vid to something illegal.
            prev_vid     = 0;
            prev_grp     = grp;
            prev_port_no = port_no;

            while (vtss_appl_ipmc_lib_src_itr(&vlan_key, &vlan_key, &grp, &grp, &port_no, &port_no, &src, &src, true /* Don't mix IPMC/MVR and IPv4 and IPv6 */) == VTSS_RC_OK) {
                if ((rc = vtss_appl_ipmc_lib_src_status_get(vlan_key, &grp, port_no, &src, &src_status)) != VTSS_RC_OK) {
                    T_IG(MVR_TRACE_GRP_ICLI, "vtss_appl_ipmc_lib_src_status_get(%s, %s, %u, %s) failed: %s", vlan_key, grp, port_no, src, error_txt(rc));
                    continue;
                }

                if (vlan_key.vid != itr.vlan_key.vid) {
                    // We got into the next VLAN ID compared to what
                    // MVR_vlan_itr() wants right now.
                    break;
                }

                if (MVR_ICLI_port_filter_out(port_list, port_no)) {
                    continue;
                }

                is_asm = src.is_all_ones();

                if (is_asm) {
                    grp_cnt++;
                } else {
                    src_cnt++;
                }

                // We only show part of the line if the new line's VLAN, Group,
                // and port number doesn't differ from the previous line's.
                differs_from_prev = prev_vid != vlan_key.vid || prev_grp.is_ipv4 != grp.is_ipv4 || prev_grp != grp || prev_port_no != port_no;

                if (is_asm) {
                    // This is the ASM entry
                    if (differs_from_prev) {
                        // No previous sources on this <vid, grp, port>.
                        sprintf(src_buf, "Any");
                    } else {
                        // Catch remaining
                        sprintf(src_buf, "Other");
                    }
                }

                if (differs_from_prev) {
                    // Print vid, grp, port
                    sprintf(vid_buf, "%4u", vlan_key.vid);
                    (void)grp.print(grp_buf);
                    (void)icli_port_info_txt_short(VTSS_USID_START, iport2uport(port_no), if_str);
                } else {
                    // Don't re-print vid, grp, port
                    vid_buf[0] = '\0';
                    grp_buf[0] = '\0';
                    if_str[0]  = '\0';
                }

                MVR_ICLI_PRINTF("%4s %-39s %-10s %-39s %-11s %-3s%s", vid_buf, grp_buf, if_str, is_asm ? src_buf : src.print(src_buf), ipmc_lib_util_filter_mode_to_str(src_status.filter_mode), src_status.forwarding ? "Yes" : "No", wants_details ? "" : "\n");

                if (wants_details) {
                    if (is_asm && src_status.filter_mode == VTSS_APPL_IPMC_LIB_FILTER_MODE_EXCLUDE) {
                        // Group timeout is only used by the ASM entry and when filter
                        // mode is EXCLUDE
                        sprintf(grp_timeout_buf, "%11u", src_status.grp_timeout);
                    } else {
                        strcpy(grp_timeout_buf, "-");
                    }

                    if (!is_asm && src_status.forwarding) {
                        // Source timers are counting if the entry is forwarding,
                        // independent of the filter mode.
                        sprintf(src_timeout_buf, "%11u", src_status.src_timeout);
                    } else {
                        strcpy(src_timeout_buf, "-");
                    }

                    MVR_ICLI_PRINTF(" %11s %11s %s\n", grp_timeout_buf, src_timeout_buf, src_status.hw_location != VTSS_APPL_IPMC_LIB_HW_LOCATION_NONE ? "Yes" : "No");
                }

                prev_vid     = vlan_key.vid;
                prev_grp     = grp;
                prev_port_no = port_no;
            }
        }
    }

    if (!grp_cnt && !src_cnt) {
        if (vlan_list || port_list) {
           MVR_ICLI_PRINTF("<None that matched the filter criteria>");
        } else {
           MVR_ICLI_PRINTF("<None>");
        }
    } else {
        if (vlan_list || port_list) {
            MVR_ICLI_PRINTF("Total displayed group count: %u (%u source%s)", grp_cnt, src_cnt, src_cnt == 1 ? "" : "s");
        } else {
            MVR_ICLI_PRINTF("Total group count: %u (%u source%s)", grp_cnt, src_cnt, src_cnt == 1 ? "" : "s");
        }
    }

    MVR_ICLI_PRINTF("\n\n");
}

/******************************************************************************/
// MVR_ICLI_oper_state_to_str()
/******************************************************************************/
static const char *MVR_ICLI_oper_state_to_str(mvr_icli_vlan_itr_t &itr, int i, bool oper_warnings)
{
    if (!itr.global_conf.admin_active) {
        return "Globally disabled";
    } else if (!itr.conf.admin_active) {
        return "Admin disabled";
    } else if (itr.data[i].status.oper_state == VTSS_APPL_IPMC_LIB_VLAN_OPER_STATE_INACTIVE) {
        if (oper_warnings) {
            return "Inactive (warnings)";
        } else {
            return "Inactive";
        }
    } else if (oper_warnings) {
        return "Active (warnings)";
    } else {
        return "Active";
    }
}

/******************************************************************************/
// MVR_ICLI_vlan_status_do_show()
/******************************************************************************/
static void MVR_ICLI_vlan_status_do_show(mvr_icli_vlan_itr_t &itr, bool wants_details)
{
    char                                    querier_state_buf[20], ip_buf[40];
    char                                    querier_uptime_buf[40], next_query_buf[40], other_querier_expiry_time_buf[40];
    char                                    ovqpo_buf[40], ovqpg_buf[40], ovhpo_buf[40], ovhpg_buf[40], buf[100], oper_warning_buf[100];
    vtss_appl_ipmc_lib_vlan_oper_warnings_t one_warning, mask;
    int                                     i, w;
    const int                               width = 31;

    for (i = 0; i < ARRSZ(itr.data); i++) {
        if (itr.data[i].status.oper_state == VTSS_APPL_IPMC_LIB_VLAN_OPER_STATE_ACTIVE) {
            if (itr.conf.querier_enable) {
                sprintf(querier_state_buf, "%s", ipmc_lib_util_querier_state_to_str(itr.data[i].status.querier_state));
            } else {
                strcpy(querier_state_buf, "Disabled");
            }

            if (itr.data[i].status.active_querier_address.is_zero()) {
                strcpy(ip_buf, "-");
            } else {
                (void)itr.data[i].status.active_querier_address.print(ip_buf);
            }
        } else {
            strcpy(querier_state_buf, "-");
            strcpy(ip_buf,            "-");
        }

        if (wants_details) {
            if (i == 0 && itr.vlan_cnt != 1) {
                // Not first print-out
                MVR_ICLI_PRINTF("-----------------------------------------------------\n\n");
            }

            if (i == 0) {
                // Only print these once.
                MVR_ICLI_PRINTF("%-*s %u\n", width + 2, "VLAN:", itr.vlan_key.vid);
                MVR_ICLI_PRINTF("%-*s %s\n", width + 2, "Name:", itr.conf.name);
            }

            MVR_ICLI_PRINTF("%s:\n", itr.data[i].proto_txt);

            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Operational state:", MVR_ICLI_oper_state_to_str(itr, i, false));

            // One line per operational warning.
            strcpy(buf, "Operational warnings:");
            if (itr.data[i].status.oper_warnings) {
                // Loop through all flags with a mask of running ones, so that we
                // don't need to worry about someone adding new flags.
                for (w = 0; w < 8 * sizeof(itr.data[i].status.oper_warnings); w++) {
                    mask = (vtss_appl_ipmc_lib_vlan_oper_warnings_t)VTSS_BIT(w);
                    one_warning = itr.data[i].status.oper_warnings & mask;

                    if (one_warning) {
                        MVR_ICLI_PRINTF("  %-*s %s\n", width, buf, ipmc_lib_util_vlan_oper_warnings_to_txt(oper_warning_buf, sizeof(oper_warning_buf), one_warning));
                        buf[0] = '\0';
                    }
                }
            } else {
                MVR_ICLI_PRINTF("  %-*s None\n", width, buf);
            }

            if (itr.data[i].status.oper_state != VTSS_APPL_IPMC_LIB_VLAN_OPER_STATE_ACTIVE) {
                if (i) {
                    MVR_ICLI_PRINTF("\n");
                }

                continue;
            }

            switch (itr.data[i].status.querier_state) {
            case VTSS_APPL_IPMC_LIB_QUERIER_STATE_INIT:
                sprintf(next_query_buf,               "%u second%s", itr.data[i].status.query_interval_left, itr.data[i].status.query_interval_left == 1 ? "" : "s");
                strcpy(querier_uptime_buf,            "-");
                strcpy(other_querier_expiry_time_buf, "-");
                break;

            case VTSS_APPL_IPMC_LIB_QUERIER_STATE_ACTIVE:
                sprintf(next_query_buf,               "%u second%s", itr.data[i].status.query_interval_left, itr.data[i].status.query_interval_left == 1 ? "" : "s");
                sprintf(querier_uptime_buf,           "%u second%s", itr.data[i].status.querier_uptime,      itr.data[i].status.querier_uptime      == 1 ? "" : "s");
                strcpy(other_querier_expiry_time_buf, "-");
                break;

            case VTSS_APPL_IPMC_LIB_QUERIER_STATE_IDLE:
            default:
                strcpy(next_query_buf,                 "-");
                strcpy(querier_uptime_buf,             "-");
                sprintf(other_querier_expiry_time_buf, "%u second%s", itr.data[i].status.other_querier_expiry_time, itr.data[i].status.other_querier_expiry_time == 1 ? "" : "s");
                break;
            }

            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Querier state:",             querier_state_buf);
            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Active querier:",            ip_buf);
            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Querier uptime:",            querier_uptime_buf);
            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Next query:",                next_query_buf);
            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Other querier expiry time:", other_querier_expiry_time_buf);

            if (itr.conf.compatibility == VTSS_APPL_IPMC_LIB_COMPATIBILITY_AUTO && itr.data[i].status.older_version_querier_present_timeout_old) {
                sprintf(ovqpo_buf, "%u second%s", itr.data[i].status.older_version_querier_present_timeout_old, itr.data[i].status.older_version_querier_present_timeout_old == 1 ? "" : "s");
            } else {
                strcpy(ovqpo_buf, "-");
            }

            if (itr.conf.compatibility == VTSS_APPL_IPMC_LIB_COMPATIBILITY_AUTO && itr.data[i].status.older_version_querier_present_timeout_gen) {
                sprintf(ovqpg_buf, "%u second%s", itr.data[i].status.older_version_querier_present_timeout_gen, itr.data[i].status.older_version_querier_present_timeout_gen == 1 ? "" : "s");
            } else {
                strcpy(ovqpg_buf, "-");
            }

            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Querier compatibility:", ipmc_lib_util_compatibility_to_str(itr.data[i].status.querier_compat, i == 0, true));

            if (i == 0) {
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "IGMPv1 querier present timeout:", ovqpo_buf);
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "IGMPv2 querier present timeout:", ovqpg_buf);
            } else {
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "MLDv1 querier present timeout:",  ovqpg_buf);
            }

            if (itr.conf.compatibility == VTSS_APPL_IPMC_LIB_COMPATIBILITY_AUTO && itr.data[i].status.older_version_host_present_timeout_old) {
                sprintf(ovhpo_buf, "%u second%s", itr.data[i].status.older_version_host_present_timeout_old, itr.data[i].status.older_version_host_present_timeout_old == 1 ? "" : "s");
            } else {
                strcpy(ovhpo_buf, "-");
            }

            if (itr.conf.compatibility == VTSS_APPL_IPMC_LIB_COMPATIBILITY_AUTO && itr.data[i].status.older_version_host_present_timeout_gen) {
                sprintf(ovhpg_buf, "%u second%s", itr.data[i].status.older_version_host_present_timeout_gen, itr.data[i].status.older_version_host_present_timeout_gen == 1 ? "" : "s");
            } else {
                strcpy(ovhpg_buf, "-");
            }

            MVR_ICLI_PRINTF("  %-*s %s\n", width, "Host compatibility:", ipmc_lib_util_compatibility_to_str(itr.data[i].status.host_compat, i == 0, true));

            if (i == 0) {
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "IGMPv1 host present timeout:", ovhpo_buf);
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "IGMPv2 host present timeout:", ovhpg_buf);
            } else {
                MVR_ICLI_PRINTF("  %-*s %s\n", width, "MLDv1 host present timeout:",  ovhpg_buf);
            }

            MVR_ICLI_PRINTF("  %-*s %u\n", width, "Number of registered groups:", itr.data[i].status.grp_cnt);

            if (i) {
                MVR_ICLI_PRINTF("\n");
            }
        } else {
            if (i == 0 && itr.vlan_cnt == 1) {
                // First iteration
                MVR_ICLI_PRINTF("VLAN Protocol Operational State   Querier State Active Querier                          Next Query/Expiry Time\n");
                MVR_ICLI_PRINTF("---- -------- ------------------- ------------- --------------------------------------- ----------------------\n");
            }

            if (itr.data[i].status.oper_state == VTSS_APPL_IPMC_LIB_VLAN_OPER_STATE_ACTIVE && !itr.data[i].status.active_querier_address.is_zero()) {
                if (itr.data[i].status.querier_state == VTSS_APPL_IPMC_LIB_QUERIER_STATE_IDLE) {
                    sprintf(next_query_buf, "%u", itr.data[i].status.other_querier_expiry_time);
                } else if (itr.data[i].status.query_interval_left) {
                    sprintf(next_query_buf, "%u", itr.data[i].status.query_interval_left);
                } else {
                    strcpy(next_query_buf, "-");
                }
            } else {
                strcpy(next_query_buf, "-");
            }

            MVR_ICLI_PRINTF("%4u %-8s %-19s %-13s %-39s %22s\n", itr.vlan_key.vid, itr.data[i].proto_txt, MVR_ICLI_oper_state_to_str(itr, i, itr.data[i].status.oper_warnings != VTSS_APPL_IPMC_LIB_VLAN_OPER_WARNING_NONE), querier_state_buf, ip_buf, next_query_buf);
        }
    }
}

/******************************************************************************/
// MVR_ICLI_vlan_status_show()
/******************************************************************************/
static void MVR_ICLI_vlan_status_show(icli_unsigned_range_t *vlan_list, const char *vlan_name, bool wants_details)
{
    mvr_icli_vlan_itr_t itr = {};

    itr.vlan_list        = vlan_list;
    itr.vlan_name        = vlan_name;
    itr.need_global_conf = true;
    itr.need_conf        = true;
    itr.need_status      = true;

    while (MVR_ICLI_vlan_itr(itr)) {
        MVR_ICLI_vlan_status_do_show(itr, wants_details);
    }

    if (!wants_details) {
        MVR_ICLI_PRINTF("\n");
    }
}

FUNCTION_END

HELP_MVR                = Multicast VLAN Registration
HELP_MVR_VLAN_LIST      = MVR multicast VLAN list
HELP_MVR_VLAN_NAME      = MVR multicast VLAN name
HELP_MVR_QUERIER_ELECT  = Act as an IGMP Querier and join Querier-Election
HELP_MVR_QUERIER_ADR    = MVR address configuration used as Source IP in IGMP messages
HELP_MVR_FRAME_PRIORITY = Controls the transmitted frames' priority (PCP value)
HELP_MVR_FRAME_TAGGING  = Controls whether the transmitted frames are tagged or not
HELP_MVR_CHANNEL        = MVR channel configuration
HELP_MVR_PORT_ROLE      = MVR port role configuration
HELP_MVR_MODE           = MVR mode of operation
HELP_MVR_STATISTICS     = Running MVR protocol counters

!==============================================================================

CMD_BEGIN
COMMAND = mvr

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_enable

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =

HELP = ##HELP_MVR

CODE_BEGIN
    ICLI_RC(MVR_ICLI_global_admin_active_set(true));
CODE_END

NO_FORM_CODE_BEGIN
    ICLI_RC(MVR_ICLI_global_admin_active_set(false));
NO_FORM_CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
COMMAND = mvr vlan <vlan_list> [name <kword1-16>]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_add
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR = has_name
CMD_VAR = vlan_name

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME

VARIABLE_BEGIN
    vtss_appl_ipmc_lib_vlan_key_t  vlan_key;
    vtss_appl_ipmc_lib_vlan_conf_t vlan_conf;
    int                            idx, cnt;
    mesa_vid_t                     vid;
    mesa_rc                        rc;
VARIABLE_END

CODE_BEGIN
    cnt = 0;
    for (idx = 0; has_name && idx < vlan_list->cnt; idx++) {
        for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
            if (++cnt > 1) {
                MVR_ICLI_PRINTF("%% Only one MVR VLAN can be added at a time when also applying a name for it\n");
                return ICLI_RC_ERROR;
            }
        }
    }

    vlan_key.is_mvr  = true;
    vlan_key.is_ipv4 = true; // Doesn't matter, since both IGMP and MLD share the same VLAN config (with exception of querier address)

    for (idx = 0; idx < vlan_list->cnt; idx++) {
        for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
            vlan_key.vid = vid;
            if (vtss_appl_ipmc_lib_vlan_conf_get(vlan_key, &vlan_conf) == VTSS_RC_OK) {
                // Entry already exists.
                // Check if name has changed.
                if (has_name) {
                    if (strcmp(vlan_conf.name, vlan_name) == 0) {
                        // Nope. Next.
                        continue;
                    }
                } else {
                    if (vlan_conf.name[0] == '\0') {
                        // New name should be empty and configured name is
                        // already empty. Nothing to do.
                        continue;
                    }
                }
            } else {
                // Entry doesn't exist.
                // Get a default configuration.
                (void)vtss_appl_ipmc_lib_vlan_conf_default_get(static_cast<vtss_appl_ipmc_lib_key_t>(vlan_key), &vlan_conf);
            }

            if (has_name) {
                // If we get here, we must change an existing entry or add a new.
                strncpy(vlan_conf.name, vlan_name, sizeof(vlan_conf.name));
            } else {
                vlan_conf.name[0] = '\0';
            }

            if ((rc = vtss_appl_mvr_vlan_conf_set(vid, &vlan_conf)) != VTSS_RC_OK) {
                MVR_ICLI_PRINTF("%% Unable to add MVR VLAN configuration for VLAN %u: %s\n", vid, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr vlan <vlan_list>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_del
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST

VARIABLE_BEGIN
    uint32_t   idx;
    mesa_vid_t vid;
    mesa_rc    rc;
VARIABLE_END

CODE_BEGIN
    if (!vlan_list) {
        return ICLI_RC_OK;
    }

    for (idx = 0; idx < vlan_list->cnt; idx++) {
        for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
            if ((rc = vtss_appl_mvr_vlan_conf_del(vid)) != VTSS_RC_OK) {
                MVR_ICLI_PRINTF("%% Unable to delete MVR VLAN ID %u: %s", vid, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

!==============================================================================
! Unfortunately, we cannot make commands like this:
!   COMMAND = mvr {vlan <vlan_list> | name <kword1-16>} {election | igmp-address <ipv4_ucast>}
! because that will - at runtime - cause ICLI to fail building its parsing tree
! with the following error:
! E icli 14:59:55 24/vtss_icli_parsing_build#1407: Error: Duplicate word "vlan".
! The conflict commands are "mvr vlan <vlan_list> [ name <kword1-16> ]" and
! "mvr { vlan <vlan_list> | name <kword1-16> } { election | igmp-address <ipv4_ucast> }".
! *** Please refer to AN1047, Appendix B.1
!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> {election | igmp-address <ipv4_ucast>}

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_election_querier_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR = has_election
CMD_VAR =
CMD_VAR = ipv4_ucast

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_QUERIER_ELECT
HELP = ##HELP_MVR_QUERIER_ADR
HELP = A valid IPv4 unicast address

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, vlan_list, nullptr, has_election, false, false, !has_election, false, false, has_election ? 1 : ipv4_ucast));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> {election | igmp-address <ipv4_ucast>}

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_election_querier_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR = has_election
CMD_VAR =
CMD_VAR = ipv4_ucast

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_QUERIER_ELECT
HELP = ##HELP_MVR_QUERIER_ADR
HELP = A valid IPv4 unicast address

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, nullptr, vlan_name, has_election, false, false, !has_election, false, false, has_election ? 1 : ipv4_ucast));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr vlan <vlan_list> {election | igmp-address}

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_election_querier_set_no_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR = has_election
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_QUERIER_ELECT
HELP = ##HELP_MVR_QUERIER_ADR

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, vlan_list, nullptr, has_election, false, false, !has_election, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr name <kword1-16> {election | igmp-address}

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_election_querier_set_no_by_name

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR = has_election
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_QUERIER_ELECT
HELP = ##HELP_MVR_QUERIER_ADR

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, nullptr, vlan_name, has_election, false, false, !has_election, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> mode {dynamic | compatible}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_mode_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR =
CMD_VAR = has_compatible

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_MODE
HELP = Dynamic MVR operation mode
HELP = Compatible MVR operation mode

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, vlan_list, nullptr, false, true, false, false, false, false, has_compatible));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> mode {dynamic | compatible}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_mode_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR =
CMD_VAR = has_compatible

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_MODE
HELP = Dynamic MVR operation mode
HELP = Compatible MVR operation mode

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, nullptr, vlan_name, false, true, false, false, false, false, has_compatible));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr vlan <vlan_list> mode

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_mode_set_no_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_MODE

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, vlan_list, nullptr, false, true, false, false, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr name <kword1-16> mode

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_mode_set_no_by_name

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_MODE

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, nullptr, vlan_name, false, true, false, false, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> frame priority <0-7>

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_frame_priority_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR =
CMD_VAR = priority

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_FRAME_PRIORITY
HELP = ##ICLI_HELP_INTF_PRI
HELP = CoS priority ranges from 0 to 7

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, vlan_list, nullptr, false, false, true, false, false, false, priority));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> frame priority <0-7>

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_frame_priority_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR =
CMD_VAR = priority

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_FRAME_PRIORITY
HELP = ##ICLI_HELP_INTF_PRI
HELP = CoS priority ranges from 0 to 7

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, nullptr, vlan_name, false, false, true, false, false, false, priority));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr vlan <vlan_list> frame priority

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_frame_priority_set_no_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_FRAME_PRIORITY
HELP = ##ICLI_HELP_INTF_PRI

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, vlan_list, nullptr, false, false, true, false, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr name <kword1-16> frame priority

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_frame_priority_set_no_by_name

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_FRAME_PRIORITY
HELP = ##ICLI_HELP_INTF_PRI

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, nullptr, vlan_name, false, false, true, false, false, false, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> frame tagged

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_frame_tagged_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR =

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_FRAME_TAGGING
HELP = Tagged IGMP/MLD frames will be sent

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, vlan_list, nullptr, false, false, false, false, true, false, 1));
CODE_END

NO_FORM_CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false,  vlan_list, nullptr, false, false, false, false, true, false, 0));
NO_FORM_CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> frame tagged

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_frame_tagged_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR =

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_FRAME_TAGGING
HELP = Tagged IGMP/MLD frames will be sent

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, nullptr, vlan_name, false, false, false, false, true, false, 1));
CODE_END

NO_FORM_CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true,  nullptr, vlan_name, false, false, false, false, true, false, 0));
NO_FORM_CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> last-member-query-interval <0-31744>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_llqi_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR = lmqi

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_INTF_LMQI
HELP = 0 - 31744 measured in tenths of seconds

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, vlan_list, nullptr, false, false, false, false, false, true, lmqi));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> last-member-query-interval <0-31744>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_llqi_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR = lmqi

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##ICLI_HELP_INTF_LMQI
HELP = 0 - 31744 measured in tenths of seconds

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(false, nullptr, vlan_name, false, false, false, false, false, true, lmqi));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr vlan <vlan_list> last-member-query-interval

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_llqi_set_no_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_INTF_LMQI

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, vlan_list, nullptr, false, false, false, false, false, true, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr name <kword1-16> last-member-query-interval

DOC_CMD_DESC
DOC_CMD_DEFAULT
DOC_CMD_USAGE
DOC_CMD_EXAMPLE

FUNC_NAME = MVR_ICLI_vlan_llqi_set_no_by_name

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##ICLI_HELP_INTF_LMQI

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_conf_all_set(true, nullptr, vlan_name, false, false, false, false, false, true, 0));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr vlan <vlan_list> channel <word16>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_channel_set_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR = channel_profile

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_CHANNEL
HELP = ##ICLI_HELP_PROFILE_NAME

VARIABLE_BEGIN
    uint32_t   idx, cnt;
    mesa_vid_t vid;
VARIABLE_END

CODE_BEGIN
    if (vlan_list) {
        cnt = 0;
        for (idx = 0; idx < vlan_list->cnt; idx++) {
            for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
                if (++cnt > 1) {
                    MVR_ICLI_PRINTF("%% Only one MVR VLAN can have it's channel profile changed at a time, since they must differ amongst MVR VLANs.\n");
                    return ICLI_RC_ERROR;
                }
            }
        }
    }

    ICLI_RC(MVR_ICLI_vlan_channel_profile_set(false, vlan_list, nullptr, channel_profile));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr name <kword1-16> channel <word16>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_channel_set_by_name

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR = channel_profile

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_CHANNEL
HELP = ##ICLI_HELP_PROFILE_NAME

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_channel_profile_set(false, nullptr, vlan_name, channel_profile));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =

COMMAND = no mvr vlan <vlan_list> channel

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_channel_set_no_by_vlan

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##HELP_MVR_CHANNEL

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_channel_profile_set(true, vlan_list, nullptr, nullptr));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =

COMMAND = no mvr name <kword1-16> channel

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_vlan_channel_set_no_by_name

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_CHANNEL

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_channel_profile_set(true, nullptr, vlan_name, nullptr));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr immediate-leave

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_immediate_leave_set

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = port_list

RUNTIME = icli_is_switchport_runtime

CMD_VAR =
CMD_VAR =

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_IMD_LEAVE

CODE_BEGIN
    ICLI_RC(MVR_ICLI_immediate_leave_set(port_list, true));
CODE_END

NO_FORM_CODE_BEGIN
    ICLI_RC(MVR_ICLI_immediate_leave_set(port_list, false));
NO_FORM_CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = mvr {vlan <vlan_list> | name <kword1-16>} type {source | receiver}

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_port_role_set

PRIVILEGE = ICLI_PRIVILEGE_15

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = port_list

RUNTIME = icli_is_switchport_runtime

CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =
CMD_VAR = has_source
CMD_VAR =

HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_PORT_ROLE
HELP = MVR source port
HELP = MVR receiver port

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_port_role_conf_set(false, port_list, vlan_list, vlan_name, has_source ? VTSS_APPL_IPMC_LIB_PORT_ROLE_SOURCE : VTSS_APPL_IPMC_LIB_PORT_ROLE_RECEIVER));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = no mvr {vlan <vlan_list> | name <kword1-16>} type

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = MVR_ICLI_port_role_set_no

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = port_list

RUNTIME =
RUNTIME = icli_is_switchport_runtime

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_PORT_ROLE

CODE_BEGIN
    ICLI_RC(MVR_ICLI_vlan_port_role_conf_set(true, port_list, vlan_list, vlan_name, VTSS_APPL_IPMC_LIB_PORT_ROLE_NONE));
CODE_END
CMD_END

!==============================================================================

CMD_BEGIN
IF_FLAG =
COMMAND = show mvr [vlan <vlan_list> | name <kword1-16>] [statistics | {group-database [interface <port_type_list>]}] [details]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_0
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = MVR_ICLI_privilege_level_check

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = vlan_list
CMD_VAR =
CMD_VAR = vlan_name
CMD_VAR = wants_statistics
CMD_VAR = wants_group_database
CMD_VAR =
CMD_VAR = port_list
CMD_VAR = wants_details

HELP = ##ICLI_HELP_SHOW
HELP = ##HELP_MVR
HELP = Search by VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = Search by MVR name
HELP = ##HELP_MVR_VLAN_NAME
HELP = Multicast group database from MVR
HELP = Search by port
HELP = ##ICLI_HELP_PORT_TYPE_LIST
HELP = Include source filter multicast information from MVR
HELP = Include detailed information/statistics of MVR group database

CODE_BEGIN
    if (wants_statistics) {
        MVR_ICLI_vlan_statistics_show(vlan_list, vlan_name, wants_details);
    } else if (wants_group_database) {
        MVR_ICLI_src_show(vlan_list, vlan_name, port_list, wants_details);
    } else {
        MVR_ICLI_vlan_status_show(vlan_list, vlan_name, wants_details);
    }
CODE_END
CMD_END

!==============================================================================
CMD_BEGIN
IF_FLAG =
COMMAND = clear mvr [vlan <vlan_list> | name <kword1-16>] statistics

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME = icli_ipmc_mvr_clear_statistics

PRIVILEGE = ICLI_PRIVILEGE_10

CMD_MODE = ICLI_CMD_MODE_EXEC

CMD_VAR =
CMD_VAR =
CMD_VAR = has_vlan
CMD_VAR = vlan_list
CMD_VAR = has_name
CMD_VAR = mvr_name
CMD_VAR =

HELP = ##ICLI_HELP_CLEAR
HELP = ##HELP_MVR
HELP = ##ICLI_HELP_MVR_VLAN
HELP = ##HELP_MVR_VLAN_LIST
HELP = ##ICLI_HELP_MVR_NAME
HELP = ##HELP_MVR_VLAN_NAME
HELP = ##HELP_MVR_STATISTICS

VARIABLE_BEGIN
    vtss_appl_ipmc_lib_vlan_key_t vlan_key;
    uint32_t                      idx;
    mesa_vid_t                    vid;
    mesa_rc                       rc;
VARIABLE_END

CODE_BEGIN
    if (has_vlan && vlan_list) {
        for (idx = 0; idx < vlan_list->cnt; idx++) {
            for (vid = vlan_list->range[idx].min; vid <= vlan_list->range[idx].max; vid++) {
                if ((rc = vtss_appl_mvr_vlan_statistics_clear(vid)) != VTSS_RC_OK) {
                    MVR_ICLI_PRINTF("%% Unable to clear statistics for MVR VLAN %u: %s\n", vid, error_txt(rc));
                }
            }
        }
    } else if (has_name && mvr_name && strlen(mvr_name)) {
        ICLI_RC(MVR_ICLI_vlan_name_to_vid(mvr_name, vid));

        if ((rc = vtss_appl_mvr_vlan_statistics_clear(vid)) != VTSS_RC_OK) {
            MVR_ICLI_PRINTF("%% Unable to clear counters for MVR VLAN %u: %s\n", vid, error_txt(rc));
            return ICLI_RC_ERROR;
        }
    } else {
        vlan_key.is_mvr  = true;
        vlan_key.is_ipv4 = true;  // Doesn't matter, since both IGMP and MLD VLAN statistics are cleared.
        vlan_key.vid     = 0;
        while (vtss_appl_ipmc_lib_vlan_itr(&vlan_key, &vlan_key, true /* stay in this key */) == VTSS_RC_OK) {
            if ((rc = vtss_appl_mvr_vlan_statistics_clear(vlan_key.vid)) != VTSS_RC_OK) {
                MVR_ICLI_PRINTF("%% Unable to clear statistics for MVR VLAN %u: %s\n", vlan_key.vid, error_txt(rc));
            }
        }
    }
CODE_END
CMD_END

