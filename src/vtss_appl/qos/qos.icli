# Copyright (c) 2006-2023 Microsemi Corporation "Microsemi". All Rights Reserved.
#
# Unpublished rights reserved under the copyright laws of the United States of
# America, other countries and international treaties. Permission to use, copy,
# store and modify, the software and its source code is granted but only in
# connection with products utilizing the Microsemi switch and PHY products.
# Permission is also granted for you to integrate into other products, disclose,
# transmit and distribute the software only in an absolute machine readable
# format (e.g. HEX file) and only in or with products utilizing the Microsemi
# switch and PHY products.  The source code of the software may not be
# disclosed, transmitted or distributed without the prior written permission of
# Microsemi.
#
# This copyright notice must appear in any copy, modification, disclosure,
# transmission or distribution of the software.  Microsemi retains all
# ownership, copyright, trade secret and proprietary rights in the software and
# its source code, including all modifications thereto.
#
# THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
# WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
# ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
# NON-INFRINGEMENT.

MODULE_IF_FLAG = defined(VTSS_SW_OPTION_QOS)

INCLUDE_BEGIN
#include "qos_api.h"
#include "qos_icfg.h"
#include "topo_api.h"
#include "mgmt_api.h"
#include "misc_api.h"
#include "icli_porting_util.h"
#include "port_api.h"
#include "port_iter.hxx"
#ifdef __cplusplus
#include "enum_macros.hxx"
VTSS_ENUM_INC(vtss_appl_qos_qcl_user_t);
#endif /* #ifdef __cplusplus */

/*lint --e{438, 550} */

#define CAPA vtss_appl_qos_capabilities
INCLUDE_END

FUNCTION_BEGIN
#define PRINTF                   (void)icli_session_self_printf
#if defined(VTSS_SW_OPTION_QOS)

i32 icli_session_printf(
    IN  u32         session_id,
    IN  const char  *format,
    IN  ...
) __attribute__ ((format (__printf__, 2, 3)));


#undef IC_RC
#define IC_RC(expr) do {                              \
    mesa_rc _rc_ = (expr);                            \
    if (_rc_ != VTSS_RC_OK) {                            \
        ICLI_PRINTF("%% QOS: %s!\n", error_txt(_rc_));\
        return _rc_;                                  \
    }                                                 \
} while (0)

static BOOL QOS_ICLI_runtime_range(icli_runtime_ask_t ask, icli_runtime_t *runtime, const char *help, u32 min, u32 max)
{
    if (ask == ICLI_ASK_HELP) {
        if (help) {
            icli_sprintf(runtime->help, "%s", help);
            return TRUE;
        }
    } else if (ask == ICLI_ASK_RANGE) {
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.ur.cnt = 1;
        runtime->range.u.ur.range[0].min = min;
        runtime->range.u.ur.range[0].max = max;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_frame_based_queue_shaper(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_queue_shapers_frame_dlb;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_port_storm_pol(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_port_storm_policers;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_cosid_classification(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_cosid_classification;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_port(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = (CAPA->has_qce_address_mode || CAPA->has_qce_key_type);
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_egress_shapers_dlb(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return icli_present_cap(ask, runtime, MESA_CAP_QOS_EGRESS_SHAPERS_DLB);
}

static BOOL QOS_ICLI_runtime_wred(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_wred_v1 || CAPA->has_wred_v2 || CAPA->has_wred_v3;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_wred_grp(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = (CAPA->wred_group_max > 1);
        return TRUE;
    }
    return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->wred_group_min, CAPA->wred_group_max);
}

static BOOL QOS_ICLI_runtime_wred_queue(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL, 0, VTSS_APPL_QOS_PORT_WEIGHTED_QUEUE_MAX);
}

static BOOL QOS_ICLI_runtime_wred_dpl(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = (CAPA->wred_dpl_max > 1);
        return TRUE;
    }
    return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->wred_dpl_min, CAPA->wred_dpl_max);
}

static BOOL QOS_ICLI_runtime_dmac_dip(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce_address_mode;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_key_type(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce_key_type;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_maps(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = FALSE;
#if defined(VTSS_SW_OPTION_QOS_ADV)
        runtime->present = TRUE;
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_ingress_map(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_ingress_map;
        return TRUE;
    }
    if (CAPA->has_ingress_map) {
        return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->ingress_map_id_min, CAPA->ingress_map_id_max);
    } else {
        return FALSE;
    }
}

static BOOL QOS_ICLI_runtime_egress_map(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_egress_map;
        return TRUE;
    }
    if (CAPA->has_egress_map) {
        return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->egress_map_id_min, CAPA->egress_map_id_max);
    } else {
        return FALSE;
    }
}

static BOOL QOS_ICLI_runtime_qos_dscp_classification(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_dscp_dpl_class;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qos_dscp_remark(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = FALSE;
#if defined(VTSS_SW_OPTION_QOS_ADV)
        runtime->present = TRUE;
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_excess_bandwidth(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_queue_shapers_eb;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_credit_based_shaper(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_queue_shapers_crb;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_shaper_rate_type(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_shapers_rt;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_port_policer_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->port_policer_bit_rate_max, CAPA->port_policer_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_port_shaper_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->port_shaper_bit_rate_max, CAPA->port_shaper_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_queue_shaper_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->queue_shaper_bit_rate_max, CAPA->queue_shaper_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_flowcontrol(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    vtss_appl_port_capabilities_t cap;

    if (ask == ICLI_ASK_PRESENT) {
        (void)vtss_appl_port_capabilities_get(&cap);
        runtime->present = (cap.aggr_caps & MEBA_PORT_CAP_FLOW_CTRL) != 0;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_global_storm_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    char buf[266], *p = buf;

    p += sprintf(p, "Policer rate (default fps). Internally rounded up to the nearest value supported by the storm policer. ");
    if (CAPA->global_storm_bit_rate_min) {
        sprintf(p, "Supported rates are divisible by %u fps or %u kbps.", CAPA->global_storm_frame_rate_min, CAPA->global_storm_bit_rate_min);
    } else {
        sprintf(p, "Supported rates are 1, 2, 4, 8, 16, 32, 64, 128, 256 and 512 fps for rates <= 512 fps "
                   "and 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 and 1024 kfps for rates > 512 fps.");
    }
    return QOS_ICLI_runtime_range(ask,
                                  runtime,
                                  buf,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->global_storm_bit_rate_max, CAPA->global_storm_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_global_storm_has_bitrate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = (CAPA->global_storm_bit_rate_max ? TRUE : FALSE);
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_port_storm_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    char buf[256];

    sprintf(buf, "Policer rate (default kbps). Internally rounded up to the nearest value supported by the storm policer. "
                 "Supported rates are divisible by %u fps or %u kbps.", CAPA->port_storm_frame_rate_min, CAPA->port_storm_bit_rate_min);
    return QOS_ICLI_runtime_range(ask,
                                  runtime,
                                  buf,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->port_storm_bit_rate_max, CAPA->port_storm_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_scheduler_dwrr_cnt(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = fast_cap(MESA_CAP_QOS_SCHEDULER_CNT_DWRR);
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_scheduler_not_dwrr_cnt(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = (fast_cap(MESA_CAP_QOS_SCHEDULER_CNT_DWRR) ? FALSE : TRUE);
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_ct(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_queue_cut_through;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_id(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return (ask == ICLI_ASK_PRESENT) ? QOS_ICLI_runtime_qce(session_id, ask, runtime) :
            QOS_ICLI_runtime_range(ask, runtime, NULL, VTSS_APPL_QOS_QCE_ID_START, VTSS_APPL_QOS_QCE_ID_END);
}

static BOOL QOS_ICLI_runtime_qce_id_range(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->qce_id_min, CAPA->qce_id_max);
}

#if defined(VTSS_APPL_QOS_QCL_INCLUDE)
static BOOL QOS_ICLI_runtime_vr(icli_runtime_ask_t ask, icli_runtime_t *runtime, const char *help, u32 min, u32 max, BOOL odd_range)
{
    if (ask == ICLI_ASK_VCAP_VR) {
        runtime->vcap_vr.min = min;
        runtime->vcap_vr.max = max;
        runtime->vcap_vr.b_odd_range = odd_range;
        return TRUE;
    }
    return QOS_ICLI_runtime_range(ask, runtime, help, min, max);
}

static BOOL QOS_ICLI_runtime_qce_smac48(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = TRUE;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_smac24(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = FALSE;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_smac(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    switch (ask) {
    case ICLI_ASK_HELP:
        if (CAPA->has_qce_address_mode && !CAPA->has_qce_dmac) {
            icli_sprintf(runtime->help, "Setup matched SMAC. If 'qos qce addr destination' is set, this parameter specifies the DMAC");
        } else {
            icli_sprintf(runtime->help, "Setup matched SMAC");
        }
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_dmac(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce_dmac;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_sip(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    switch (ask) {
    case ICLI_ASK_HELP:
        if (CAPA->has_qce_address_mode && !CAPA->has_qce_dip) {
            icli_sprintf(runtime->help, "Setup matched source IP address. If 'qos qce addr destination' is set, this parameter specifies the destination IP");
        } else {
            icli_sprintf(runtime->help, "Setup matched source IP address");
        }
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_dip(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce_dip;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_inner_tag(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_qce_inner_tag;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_qce_ot_vid(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_vr(ask, runtime, NULL, 0, 4095, 1);
}

static BOOL QOS_ICLI_runtime_qce_it_vid(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return (ask == ICLI_ASK_PRESENT) ? QOS_ICLI_runtime_qce_inner_tag(session_id, ask, runtime) :
            QOS_ICLI_runtime_vr(ask, runtime, NULL, 0, 4095, 0);
}

static BOOL QOS_ICLI_runtime_qce_dscp(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_vr(ask, runtime, NULL, 0, 63, 1);
}

static BOOL QOS_ICLI_runtime_qce_sport(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_vr(ask, runtime, NULL, 0, 0xffff, 1);
}

static BOOL QOS_ICLI_runtime_qce_dport(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_vr(ask, runtime, NULL, 0, 0xffff, 1);
}

static BOOL QOS_ICLI_runtime_policy(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL, 0, fast_cap(MESA_CAP_ACL_POLICY_CNT) - 1);
}

static void QOS_ICLI_show_qce_conf(u32 session_id, vtss_appl_qos_qcl_user_t user, vtss_appl_qos_qce_intern_conf_t *conf)
{
    mesa_qce_t          *const q = &conf->qce;
    mesa_qce_key_t      *const k = &q->key;
    mesa_qce_action_t   *const a = &q->action;
    mesa_vcap_bit_t     s_tag;
    char                name[128];
    char                buf[128];
    const char          *txt;
    u8                  pcp_mask;

    sprintf(name, "%s qce %u%s", vtss_appl_qos_qcl_user2txt(user, FALSE), q->id, conf->conflict ? " (conflict)" : "");
    icli_header(session_id, name, FALSE);
    ICLI_PRINTF(" port: %s\n", icli_iport_list_txt(k->port_list, buf));

    ICLI_PRINTF(" key parameters:\n");

    txt = NULL;
    if ((k->mac.dmac_bc != MESA_VCAP_BIT_ANY) || (k->mac.dmac_mc != MESA_VCAP_BIT_ANY)) {
        txt = (k->mac.dmac_bc == MESA_VCAP_BIT_1 ? "broadcast" :
               k->mac.dmac_mc == MESA_VCAP_BIT_1 ? "multicast" :
               k->mac.dmac_mc == MESA_VCAP_BIT_0 ? "unicast" :
               NULL);
    }
    if (CAPA->has_qce_dmac && txt == NULL) {
        if (k->mac.dmac.mask[0] || k->mac.dmac.mask[1] || k->mac.dmac.mask[2] ||
            k->mac.dmac.mask[3] || k->mac.dmac.mask[4] || k->mac.dmac.mask[5]) {
            txt = misc_mac_txt(k->mac.dmac.value, buf);
        }
    }
    ICLI_PRINTF("  dmac: %s\n", txt ? txt : "any");

    if (!k->mac.smac.mask[0] && !k->mac.smac.mask[1] && !k->mac.smac.mask[2] &&
        !k->mac.smac.mask[3] && !k->mac.smac.mask[4] && !k->mac.smac.mask[5]) {
        ICLI_PRINTF("  smac: any\n");
    } else {
        ICLI_PRINTF("  smac: %s\n", misc_mac_txt(k->mac.smac.value, buf));
    }

    ICLI_PRINTF("  tag:\n");
    s_tag = (CAPA->has_qce_inner_tag ? k->tag.s_tag : MESA_VCAP_BIT_ANY);
    ICLI_PRINTF("   type: %s\n", vtss_appl_qos_qcl_tag_type2txt(k->tag.tagged, s_tag, FALSE));

    ICLI_PRINTF("   vid: %s\n", vtss_appl_qos_qcl_range2txt(&k->tag.vid, buf, FALSE));

    pcp_mask = k->tag.pcp.mask & 7;
    if (pcp_mask == 0) {
        ICLI_PRINTF("   pcp: any\n");
    } else if (pcp_mask == 7) {
        ICLI_PRINTF("   pcp: %u\n", k->tag.pcp.value);
    } else {
        ICLI_PRINTF("   pcp: %u-%u\n", k->tag.pcp.value, k->tag.pcp.value + ((pcp_mask == 6) ? 1 : 3));
    }

    if (k->tag.dei == MESA_VCAP_BIT_ANY) {
        ICLI_PRINTF("   dei: any\n");
    } else {
        ICLI_PRINTF("   dei: %u\n", (k->tag.dei == MESA_VCAP_BIT_0) ? 0 : 1);
    }

    if (CAPA->has_qce_inner_tag) {
        ICLI_PRINTF("  inner tag:\n");
        ICLI_PRINTF("   type: %s\n", vtss_appl_qos_qcl_tag_type2txt(k->inner_tag.tagged, k->inner_tag.s_tag, FALSE));

        ICLI_PRINTF("   vid: %s\n", vtss_appl_qos_qcl_range2txt(&k->inner_tag.vid, buf, FALSE));

        pcp_mask = k->inner_tag.pcp.mask & 7;
        if (pcp_mask == 0) {
            ICLI_PRINTF("   pcp: any\n");
        } else if (pcp_mask == 7) {
            ICLI_PRINTF("   pcp: %u\n", k->inner_tag.pcp.value);
        } else {
            ICLI_PRINTF("   pcp: %u-%u\n", k->inner_tag.pcp.value, k->inner_tag.pcp.value + ((pcp_mask == 6) ? 1 : 3));
        }

        if (k->inner_tag.dei == MESA_VCAP_BIT_ANY) {
            ICLI_PRINTF("   dei: any\n");
        } else {
            ICLI_PRINTF("   dei: %u\n", (k->inner_tag.dei == MESA_VCAP_BIT_0) ? 0 : 1);
        }
    }

    switch (k->type) {
    case MESA_QCE_TYPE_ANY:
        ICLI_PRINTF("  frametype: any\n");
        break;
    case MESA_QCE_TYPE_ETYPE: {
        mesa_qce_frame_etype_t *etype = &k->frame.etype;
        if (etype->etype.mask[0] || etype->etype.mask[1]) {
            sprintf(buf, "0x%x", (etype->etype.value[0] << 8) | etype->etype.value[1]);
        } else {
            sprintf(buf, "any");
        }
        ICLI_PRINTF("  frametype: etype %s\n", buf);
        break;
    }
    case MESA_QCE_TYPE_LLC: {
        mesa_qce_frame_llc_t *llc = &k->frame.llc;
        ICLI_PRINTF("  frametype: llc\n");
        if (llc->data.mask[0]) {
            ICLI_PRINTF("   dsap: 0x%x\n", llc->data.value[0]);
        } else {
            ICLI_PRINTF("   dsap: any\n");
        }
        if (llc->data.mask[1]) {
            ICLI_PRINTF("   ssap: 0x%x\n", llc->data.value[1]);
        } else {
            ICLI_PRINTF("   ssap: any\n");
        }
        if (llc->data.mask[2]) {
            ICLI_PRINTF("   control: 0x%x\n", llc->data.value[2]);
        } else {
            ICLI_PRINTF("   control: any\n");
        }
        break;
    }
    case MESA_QCE_TYPE_SNAP: {
        mesa_qce_frame_snap_t *snap = &k->frame.snap;
        if (snap->data.mask[3] || snap->data.mask[4]) {
            sprintf(buf, "0x%x", (snap->data.value[3] << 8) | snap->data.value[4]);
        } else {
            sprintf(buf, "any");
        }
        ICLI_PRINTF("  frametype: snap %s\n", buf);
        break;
    }
    case MESA_QCE_TYPE_IPV4: {
        mesa_qce_frame_ipv4_t *i4 = &k->frame.ipv4;
        ICLI_PRINTF("  frametype: ipv4\n");
        ICLI_PRINTF("   proto: %s\n", vtss_appl_qos_qcl_proto2txt(&i4->proto, buf));
        ICLI_PRINTF("   sip: %s\n", vtss_appl_qos_qcl_ipv42txt(&i4->sip, buf, FALSE));
        if (CAPA->has_qce_dip) {
            ICLI_PRINTF("   dip: %s\n", vtss_appl_qos_qcl_ipv42txt(&i4->dip, buf, FALSE));
        }
        ICLI_PRINTF("   dscp: %s\n", vtss_appl_qos_qcl_range2txt(&i4->dscp, buf, FALSE));
        ICLI_PRINTF("   frag: %s\n", (i4->fragment == MESA_VCAP_BIT_ANY ? "any" : (i4->fragment == MESA_VCAP_BIT_0 ? "no" : "yes")));
        if (i4->proto.mask && (i4->proto.value == 6 || i4->proto.value == 17)) {
            ICLI_PRINTF("   sport: %s\n", vtss_appl_qos_qcl_range2txt(&i4->sport, buf, FALSE));
            ICLI_PRINTF("   dport: %s\n", vtss_appl_qos_qcl_range2txt(&i4->dport, buf, FALSE));
        }
        break;
    }
    case MESA_QCE_TYPE_IPV6: {
        mesa_qce_frame_ipv6_t *i6 = &k->frame.ipv6;
        ICLI_PRINTF("  frametype: ipv6\n");
        ICLI_PRINTF("   proto: %s\n", vtss_appl_qos_qcl_proto2txt(&i6->proto, buf));
        ICLI_PRINTF("   sip: %s\n", vtss_appl_qos_qcl_ipv62txt(&i6->sip, buf, FALSE));
        if (CAPA->has_qce_dip) {
            ICLI_PRINTF("   dip: %s\n", vtss_appl_qos_qcl_ipv62txt(&i6->dip, buf, FALSE));
        }
        ICLI_PRINTF("   dscp: %s\n", vtss_appl_qos_qcl_range2txt(&i6->dscp, buf, FALSE));
        if (i6->proto.mask && (i6->proto.value == 6 || i6->proto.value == 17)) {
            ICLI_PRINTF("   sport: %s\n", vtss_appl_qos_qcl_range2txt(&i6->sport, buf, FALSE));
            ICLI_PRINTF("   dport: %s\n", vtss_appl_qos_qcl_range2txt(&i6->dport, buf, FALSE));
        }
        break;
    }
    default:
        ICLI_PRINTF("  frametype: ?\n");
        break;
    }

    ICLI_PRINTF(" action parameters:\n");
    if (a->prio_enable) {
        ICLI_PRINTF("  cos: %u\n", a->prio);
    } else {
        ICLI_PRINTF("  cos: default\n");
    }
    if (a->dp_enable) {
        ICLI_PRINTF("  dpl: %u\n", a->dp);
    } else {
        ICLI_PRINTF("  dpl: default\n");
    }
    if (a->dscp_enable) {
        ICLI_PRINTF("  dscp: %s\n", vtss_appl_qos_dscp2str(a->dscp));
    } else {
        ICLI_PRINTF("  dscp: default\n");
    }
    if (a->pcp_dei_enable) {
        ICLI_PRINTF("  tag: pcp %u, dei %u\n", a->pcp, a->dei);
    } else {
        ICLI_PRINTF("  tag: default\n");
    }
    if (a->policy_no_enable) {
        ICLI_PRINTF("  policy: %u\n", a->policy_no);
    } else {
        ICLI_PRINTF("  policy: default\n");
    }
    if (CAPA->has_ingress_map) {
        if (a->map_id_enable) {
            ICLI_PRINTF("  ingress-map: %u\n", a->map_id);
        } else {
            ICLI_PRINTF("  ingress-map: default\n");
        }
    }
}
#endif /* defined(VTSS_APPL_QOS_QCL_INCLUDE) */

#if defined(VTSS_SW_OPTION_QOS_ADV)
static BOOL QOS_ICLI_runtime_dpl(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL, CAPA->dpl_min, CAPA->dpl_max);
}

static BOOL QOS_ICLI_runtime_queue_policer_rate(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    return QOS_ICLI_runtime_range(ask, runtime, NULL,
                                  1,
                                  vtss_appl_qos_rate_max(CAPA->queue_policer_bit_rate_max, CAPA->queue_policer_frame_rate_max));
}

static BOOL QOS_ICLI_runtime_dscp_remark_dp_aware(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    if (ask == ICLI_ASK_PRESENT) {
        runtime->present = CAPA->has_dscp_dpl_remark;
        return TRUE;
    }
    return FALSE;
}

static BOOL QOS_ICLI_runtime_dscp_remark_remap(u32 session_id, icli_runtime_ask_t ask, icli_runtime_t *runtime)
{
    switch (ask) {
    case ICLI_ASK_HELP:
        icli_sprintf(runtime->help, "Rewrite DSCP field using classified DSCP %sremapped through global dscp-egress-translation map",
                     CAPA->has_dscp_dpl_remark ? "and DPL=0 " : "");
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static void QOS_ICLI_show_ingress_map_values(u32 session_id, const char *name, vtss_appl_qos_ingress_map_values_t *v)
{
    ICLI_PRINTF(" %-11s: class %1u cos %1u dei %1u dpl %1u dscp %2u pcp %1u\n",
                name, v->cosid, v->cos, v->dei, v->dpl, v->dscp, v->pcp);
}

static void QOS_ICLI_show_ingress_map(u32 session_id, mesa_qos_ingress_map_id_t id, BOOL full)
{
    vtss_appl_qos_imap_entry_t e;
    if ((vtss_appl_qos_imap_entry_get(id, &e) != VTSS_RC_OK) || !e.used) {
        ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
    } else {
        ICLI_PRINTF("ingress map: %u, key: %s, action:", id, vtss_appl_qos_ingress_map_key2txt(e.conf.key, FALSE));
        if (e.conf.action.cos) {
            ICLI_PRINTF(" cos");
        }
        if (e.conf.action.dpl) {
            ICLI_PRINTF(" dpl");
        }
        if (e.conf.action.pcp) {
            ICLI_PRINTF(" pcp");
        }
        if (e.conf.action.dei) {
            ICLI_PRINTF(" dei");
        }
        if (e.conf.action.dscp) {
            ICLI_PRINTF(" dscp");
        }
        if (e.conf.action.cosid) {
            ICLI_PRINTF(" class");
        }
        ICLI_PRINTF("\n");
        if (full) {
            int i, j;
            char name[16];
            for (i = 0; i < VTSS_PCPS; i++) {
                for (j = 0; j < VTSS_DEIS; j++) {
                    snprintf(name, sizeof(name), "pcp %u dei %u", i, j);
                    QOS_ICLI_show_ingress_map_values(session_id, name, &e.pcp_dei[i][j]);
                }
            }
            for (i = 0; i < 64; i++) {
                snprintf(name, sizeof(name), "dscp %u", i);
                QOS_ICLI_show_ingress_map_values(session_id, name, &e.dscp[i]);
            }
        }
    }
}

static void QOS_ICLI_show_egress_map_values(u32 session_id, const char *name, vtss_appl_qos_egress_map_values_t *v)
{
    ICLI_PRINTF(" %-13s: dei %1u dscp %2u pcp %1u\n",
                name, v->dei, v->dscp, v->pcp);
}

static void QOS_ICLI_show_egress_map(u32 session_id, mesa_qos_egress_map_id_t id, BOOL full)
{
    vtss_appl_qos_emap_entry_t e;
    if ((vtss_appl_qos_emap_entry_get(id, &e) != VTSS_RC_OK) || !e.used) {
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);
    } else {
        ICLI_PRINTF("egress map: %u, key: %s, action:", id, vtss_appl_qos_egress_map_key2txt(e.conf.key, FALSE));
        if (e.conf.action.pcp) {
            ICLI_PRINTF(" pcp");
        }
        if (e.conf.action.dei) {
            ICLI_PRINTF(" dei");
        }
        if (e.conf.action.dscp) {
            ICLI_PRINTF(" dscp");
        }
        ICLI_PRINTF("\n");
        if (full) {
            int i, j;
            char name[24];
            u32 dpl_cnt = fast_cap(MESA_CAP_QOS_DPL_CNT);
            for (i = 0; i < VTSS_COSIDS; i++) {
                for (j = 0; j < dpl_cnt; j++) {
                    snprintf(name, sizeof(name), "class %u dpl %u", i, j);
                    QOS_ICLI_show_egress_map_values(session_id, name, &e.cosid_dpl[i][j]);
                }
            }
            for (i = 0; i < 64; i++) {
                snprintf(name, sizeof(name), "dscp %u", i);
                for (j = 0; j < dpl_cnt; j++) {
                    snprintf(name, sizeof(name), "dscp %u dpl %u", i, j);
                    QOS_ICLI_show_egress_map_values(session_id, name, &e.dscp_dpl[i][j]);
                }
            }
        }
    }
}

#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */

#endif  /* defined(VTSS_SW_OPTION_QOS) */
FUNCTION_END

EXPORT_BEGIN
EXPORT_END

HELP_QOS                        = Quality of Service
HELP_QOS_INTERFACE              = Interface
HELP_QOS_INTERFACE_LIST         = Interface selector
HELP_QOS_WRED                   = Weighted Random Early Discard
HELP_QOS_MAPS                   = QoS Maps/Tables
HELP_QOS_STORM                  = Storm policer
HELP_QOS_QCE                    = QoS Control Entry
HELP_QOS_QCE_ID                 = QCE ID
HELP_QOS_MAP                    = Global QoS Map/Table
HELP_QOS_MAP_ID                 = Map ID
HELP_QOS_MAP_INGRESS            = Map for ingress configuration
HELP_QOS_MAP_EGRESS             = Map for egress configuration
HELP_QOS_HAS_SHAPER_RATE_TYPE   = Setup shaping rate type
HELP_QOS_HAS_SHAPER_LINE_RATE   = Line rate shaping
HELP_QOS_HAS_SHAPER_DATA_RATE   = Data rate shaping

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = show qos [\
            { interface [ <port_type_list> ] } |\
            wred |\
            { maps [ dscp-cos ] [ dscp-ingress-translation ] [ dscp-classify ] [ cos-dscp ] [ dscp-egress-translation ] [ { ingress [ <0-255> ] } ] [ { egress [ <0-511> ] } ] } |\
            storm |\
            { qce [ <1-256> ] }\
          ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

! show
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS
BYWORD  =

! interface
CMD_VAR = has_interface
RUNTIME =
HELP    = ##HELP_QOS_INTERFACE
BYWORD  = interface : Option

! <port_type_list>
CMD_VAR = port
RUNTIME =
HELP    = ##HELP_QOS_INTERFACE_LIST
BYWORD  = <Port : port_type_list>

! wred
CMD_VAR = has_wred
RUNTIME = QOS_ICLI_runtime_wred
HELP    = ##HELP_QOS_WRED
BYWORD  = wred : Option

! maps
CMD_VAR = has_maps
RUNTIME = QOS_ICLI_runtime_maps
HELP    = ##HELP_QOS_MAPS
BYWORD  = maps : Option

! dscp-cos
CMD_VAR = has_dscp_cos
RUNTIME = QOS_ICLI_runtime_qos_dscp_classification
HELP    = Map for DSCP to COS
BYWORD  = dscp-cos : Option

! dscp-ingress-translation
CMD_VAR = has_dscp_ingress_translation
RUNTIME = QOS_ICLI_runtime_qos_dscp_remark
HELP    = Map for DSCP ingress translation
BYWORD  = dscp-ingress-translation : Option

! dscp-classify
CMD_VAR = has_dscp_classify
RUNTIME = QOS_ICLI_runtime_qos_dscp_remark
HELP    = Map for DSCP classify enable
BYWORD  = dscp-classify : Option

! cos-dscp
CMD_VAR = has_cos_dscp
RUNTIME = QOS_ICLI_runtime_qos_dscp_remark
HELP    = Map for COS to DSCP
BYWORD  = cos-dscp : Option

! dscp-egress-translation
CMD_VAR = has_dscp_egress_translation
RUNTIME = QOS_ICLI_runtime_qos_dscp_remark
HELP    = Map for DSCP egress translation
BYWORD  = dscp-egress-translation : Option

! ingress
CMD_VAR = has_ingress
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = ##HELP_QOS_MAP_INGRESS
BYWORD  = ingress : Option

! <0-255>
CMD_VAR = ing_id
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  = <IngId : 0-255>

! egress
CMD_VAR = has_egress
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    = ##HELP_QOS_MAP_EGRESS
BYWORD  = egress : Option

! <0-511>
CMD_VAR = egr_id
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  = <EgrId : 0-511>

! storm
CMD_VAR = has_storm
RUNTIME =
HELP    = ##HELP_QOS_STORM
BYWORD  = storm : Option

! qce
CMD_VAR = has_qce
RUNTIME = QOS_ICLI_runtime_qce
HELP    = ##HELP_QOS_QCE
BYWORD  = qce : Option

! <1-256>
CMD_VAR = qce
RUNTIME = QOS_ICLI_runtime_qce_id
HELP    = ##HELP_QOS_QCE_ID
BYWORD  = <Qce : 1-256>

VARIABLE_BEGIN
    ing_id = MESA_QOS_MAP_ID_NONE;
    egr_id = MESA_QOS_MAP_ID_NONE;
VARIABLE_END

CODE_BEGIN
    if ((has_interface | has_wred | has_maps | has_storm | has_qce) == FALSE) {
        has_interface = has_wred = has_maps = has_storm = has_qce = TRUE;
    }

    if (has_interface) {
        switch_iter_t               sit;
        port_iter_t                 pit;
        char                        buf[128];
        vtss_appl_qos_port_conf_t   c;
        vtss_appl_qos_port_status_t s;

        (void)icli_switch_iter_init(&sit);
        while (icli_switch_iter_getnext(&sit, port)) {
            (void)icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
            while (icli_port_iter_getnext(&pit, port)) {
                IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
                IC_RC(vtss_appl_qos_port_status_get(sit.isid, pit.iport, &s));
                ICLI_PRINTF("interface %s\n", icli_port_info_txt(sit.usid, pit.uport, buf));
                if (c.port.default_cos == s.default_cos) {
                    ICLI_PRINTF(" qos cos %u\n", c.port.default_cos);
                } else {
                    ICLI_PRINTF(" qos cos %u (%u)\n", c.port.default_cos, s.default_cos);
                }
                ICLI_PRINTF(" qos pcp %u\n", c.port.default_pcp);

                ICLI_PRINTF(" qos dpl %u\n", c.port.default_dpl);
                ICLI_PRINTF(" qos dei %u\n", c.port.default_dei);

                if (CAPA->has_cosid_classification) {
                    ICLI_PRINTF(" qos class %u\n", c.port.default_cosid);
                }

#if defined(VTSS_SW_OPTION_QOS_ADV)
                ICLI_PRINTF(" qos trust tag %s\n", icli_bool_txt(c.port.trust_tag));
                {
                    int pcp, dei;
                    for (pcp = 0; pcp < VTSS_PCP_ARRAY_SIZE; pcp++) {
                        for (dei = 0; dei < VTSS_DEI_ARRAY_SIZE; dei++) {
                            ICLI_PRINTF(" qos map tag-cos pcp %d dei %d cos %u dpl %u\n",
                                        pcp, dei, c.tag_cos_map[pcp][dei].cos, c.tag_cos_map[pcp][dei].dpl);
                        }
                    }
                }
                ICLI_PRINTF(" qos trust dscp %s\n", icli_bool_txt(c.port.trust_dscp));
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */

                {
                    BOOL fc = c.port_policer.flow_control;

                    if (fc) {
                        ICLI_PRINTF(" qos policer mode: %s, rate: %s, flowcontrol %s\n",
                                    icli_bool_txt(c.port_policer.enable),
                                    vtss_appl_qos_rate2txt(c.port_policer.cir, c.port_policer.frame_rate, buf),
                                    icli_bool_txt(TRUE));
                    } else {
                        ICLI_PRINTF(" qos policer mode: %s, rate: %s\n",
                                    icli_bool_txt(c.port_policer.enable),
                                    vtss_appl_qos_rate2txt(c.port_policer.cir, c.port_policer.frame_rate, buf));
                    }
                }

#if defined(VTSS_SW_OPTION_QOS_ADV)
                {
                    int i;
                    for (i = 0; i < VTSS_APPL_QOS_PORT_QUEUE_CNT; i++) {
                        ICLI_PRINTF(" qos queue-policer queue %d mode: %s, rate: %s\n",
                                    i,
                                    icli_bool_txt(c.queue_policer[i].enable),
                                    vtss_appl_qos_rate2txt(c.queue_policer[i].cir, FALSE, buf));
                    }
                }
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */

                ICLI_PRINTF(" qos port shaper: %s, rate: %s",
                            icli_bool_txt(c.port_shaper.enable),
                            vtss_appl_qos_rate2txt(c.port_shaper.cir, FALSE, buf));
                if (CAPA->has_shapers_rt) {
                    ICLI_PRINTF(", mode: %s",
                                vtss_appl_qos_shaper_mode2txt(c.port_shaper.mode, buf));
                }
                ICLI_PRINTF("\n");
                {
                    int i;
                    for (i = 0; i < VTSS_APPL_QOS_PORT_QUEUE_CNT; i++) {
                        ICLI_PRINTF(" qos queue-shaper queue %d: %s, rate: %s",
                                    i,
                                    icli_bool_txt(c.queue_shaper[i].enable),
                                    vtss_appl_qos_rate2txt(c.queue_shaper[i].cir, c.queue_shaper[i].mode == VTSS_APPL_QOS_SHAPER_MODE_FRAME, buf));
                        if (CAPA->has_shapers_rt) {
                            ICLI_PRINTF(", mode: %s",
                                        vtss_appl_qos_shaper_mode2txt(c.queue_shaper[i].mode, buf));
                        }
                        if (CAPA->has_queue_shapers_eb) {
                            ICLI_PRINTF(", excess: %s", icli_bool_txt(c.queue_shaper[i].excess));
                        }
                        if (CAPA->has_queue_shapers_crb) {
                            ICLI_PRINTF(", credit: %s", icli_bool_txt(c.queue_shaper[i].credit));
                        }
                        ICLI_PRINTF("\n");
                    }
                }

                {
                    int i;
                    ICLI_PRINTF(" qos wrr mode: %s", icli_bool_txt(c.port.dwrr_cnt != 0));
                    if (c.port.dwrr_cnt) {
                        ICLI_PRINTF(", weight:");
                        for (i = 0; i < c.port.dwrr_cnt; i++) {
                            ICLI_PRINTF(" q%d:%u(%u%%)", i, c.scheduler[i].weight, s.scheduler[i].weight);
                        }
                    }
                    ICLI_PRINTF("\n");
                }
                if (CAPA->has_queue_cut_through) {
                    int i;
                    for (i = 0; i < VTSS_APPL_QOS_PORT_QUEUE_CNT; i++) {
                        ICLI_PRINTF(" qos cut-through queue %d: %s\n",
                                    i,
                                    icli_bool_txt(c.scheduler[i].cut_through));
                    }
                }

                switch (c.port.tag_remark_mode) {
                case VTSS_APPL_QOS_TAG_REMARK_MODE_CLASSIFIED:
                    ICLI_PRINTF(" qos tag-remark classified\n");
                    break;
                case VTSS_APPL_QOS_TAG_REMARK_MODE_DEFAULT:
                    ICLI_PRINTF(" qos tag-remark default pcp %u dei %u\n", c.port.tag_default_pcp, c.port.tag_default_dei);
                    break;
                case VTSS_APPL_QOS_TAG_REMARK_MODE_MAPPED:
                    ICLI_PRINTF(" qos tag-remark mapped\n");
                    break;
                default:
                    break;
                }

                {
                    int cos, dpl;
                    for (cos = 0; cos < VTSS_APPL_QOS_PORT_PRIO_CNT; cos++) {
                        for (dpl = 0; dpl < 2; dpl++) {
                            ICLI_PRINTF(" qos map cos-tag cos %d dpl %d pcp %u dei %u\n", cos, dpl, c.cos_tag_map[cos][dpl].pcp, c.cos_tag_map[cos][dpl].dei);
                        }
                    }
                }

#if defined(VTSS_SW_OPTION_QOS_ADV)
                ICLI_PRINTF(" qos dscp-translate %s\n", icli_bool_txt(c.port.dscp_translate));

                switch (c.port.dscp_imode) {
                case VTSS_APPL_QOS_DSCP_MODE_NONE:
                    ICLI_PRINTF(" qos dscp-classify disabled\n");
                    break;
                case VTSS_APPL_QOS_DSCP_MODE_ZERO:
                    ICLI_PRINTF(" qos dscp-classify zero\n");
                    break;
                case VTSS_APPL_QOS_DSCP_MODE_SEL:
                    ICLI_PRINTF(" qos dscp-classify selected\n");
                    break;
                case VTSS_APPL_QOS_DSCP_MODE_ALL:
                    ICLI_PRINTF(" qos dscp-classify any\n");
                    break;
                default:
                    break;
                }

                switch (c.port.dscp_emode) {
                case VTSS_APPL_QOS_DSCP_EMODE_DISABLE:
                    ICLI_PRINTF(" qos dscp-remark disabled\n");
                    break;
                case VTSS_APPL_QOS_DSCP_EMODE_REMARK:
                    ICLI_PRINTF(" qos dscp-remark rewrite\n");
                    break;
                case VTSS_APPL_QOS_DSCP_EMODE_REMAP:
                    ICLI_PRINTF(" qos dscp-remark remap\n");
                    break;
                case VTSS_APPL_QOS_DSCP_EMODE_REMAP_DPA:
                    ICLI_PRINTF(" qos dscp-remark remap-dp\n");
                    break;
                default:
                    break;
                }
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */

                if (CAPA->has_port_storm_policers) {
                    ICLI_PRINTF(" qos storm unicast mode: %s, rate: %s\n",
                                icli_bool_txt(c.uc_policer.enable),
                                vtss_appl_qos_rate2txt(c.uc_policer.cir, c.uc_policer.frame_rate, buf));

                    ICLI_PRINTF(" qos storm broadcast mode: %s, rate: %s\n",
                                icli_bool_txt(c.bc_policer.enable),
                                vtss_appl_qos_rate2txt(c.bc_policer.cir, c.bc_policer.frame_rate, buf));

                    ICLI_PRINTF(" qos storm unknown mode: %s, rate: %s\n",
                                icli_bool_txt(c.un_policer.enable),
                                vtss_appl_qos_rate2txt(c.un_policer.cir, c.un_policer.frame_rate, buf));
                }

                if (CAPA->has_qce_address_mode) {
                    ICLI_PRINTF(" qos qce addr %s\n", c.port.dmac_dip ? "destination" : "source");
                }
                if (CAPA->has_qce_key_type) {
                    ICLI_PRINTF(" qos qce key %s\n", vtss_appl_qos_qcl_key_type2txt(c.port.key_type, FALSE));
                }
                if (CAPA->wred_group_max > 1) {
                    ICLI_PRINTF(" qos wred-group %u\n", c.port.wred_group);
                }
                if (CAPA->has_ingress_map) {
                    if (c.port.ingress_map != MESA_QOS_MAP_ID_NONE) {
                        ICLI_PRINTF(" qos ingress-map %u\n", c.port.ingress_map);
                    } else {
                        ICLI_PRINTF(" qos ingress-map disabled\n");
                    }
                }
                if (CAPA->has_egress_map) {
                    if (c.port.egress_map != MESA_QOS_MAP_ID_NONE) {
                        ICLI_PRINTF(" qos egress-map %u\n", c.port.egress_map);
                    } else {
                        ICLI_PRINTF(" qos egress-map disabled\n");
                    }
                }
            }
        }
        ICLI_PRINTF("\n");
    }

    if (has_wred && CAPA->has_wred2_or_wred3) {
        vtss_appl_qos_conf_t c;
        int                  queue;

        IC_RC(vtss_appl_qos_conf_get(&c));

        ICLI_PRINTF("qos wred:\n");
        ICLI_PRINTF("=========\n");

        {
            int group, dpl;
            vtss_appl_qos_wred_t *wred;
            u32 grp_cnt = CAPA->wred_group_max;
            u32 dpl_cnt = CAPA->wred_dpl_max;

            if (grp_cnt > 1) {
                ICLI_PRINTF("Group  ");
            }
            ICLI_PRINTF("Queue  ");
            if (dpl_cnt > 1) {
                ICLI_PRINTF("Dpl  ");
            }
            ICLI_PRINTF("Mode      Min Fl  Max Dp or Fl\n");
            if (grp_cnt > 1) {
                ICLI_PRINTF("-----  ");
            }
            ICLI_PRINTF("-----  ");
            if (dpl_cnt > 1) {
                ICLI_PRINTF("---  ");
            }
            ICLI_PRINTF("--------  ------  ----------------------\n");

            for (group = 0; group < grp_cnt; group++) {
                for (queue = 0; queue < VTSS_APPL_QOS_PORT_WEIGHTED_QUEUE_CNT; queue++) {
                    for (dpl = 0; dpl < dpl_cnt; dpl++) {
                        wred = &c.wred[queue][dpl][group];
                        if (grp_cnt > 1) {
                            ICLI_PRINTF("%5d  ", group + 1);
                        }
                        ICLI_PRINTF("%5d  ", queue);
                        if (dpl_cnt > 1) {
                            ICLI_PRINTF("%3d  ", dpl + 1);
                        }
                        ICLI_PRINTF("%-8s  %3u %%   %3u %% %-s\n",
                                    icli_bool_txt(wred->enable),
                                    wred->min,
                                    wred->max,
                                    wred->max_unit == VTSS_APPL_QOS_WRED_MAX_DP ? "Drop Probability" : "Fill Level");
                    }
                }
            }
        }
        ICLI_PRINTF("\n");
    }

#if defined(VTSS_SW_OPTION_QOS_ADV)
    if (has_maps) {
        vtss_appl_qos_conf_t c;
        int                  i;

        if ((has_dscp_cos | has_dscp_ingress_translation | has_dscp_classify | has_cos_dscp | has_dscp_egress_translation | has_ingress | has_egress) == FALSE) {
            has_dscp_cos = CAPA->has_dscp_dpl_class;
            has_dscp_ingress_translation = has_dscp_classify = has_cos_dscp = has_dscp_egress_translation = TRUE;
            has_ingress = CAPA->has_ingress_map;
            has_egress = CAPA->has_egress_map;
        }

        IC_RC(vtss_appl_qos_conf_get(&c));

        if (has_dscp_cos) {
            ICLI_PRINTF("qos map dscp-cos:\n");
            ICLI_PRINTF("=================\n");

            ICLI_PRINTF("DSCP       Trust     Cos  Dpl\n");
            ICLI_PRINTF("---------  --------  ---  ---\n");

            for (i = 0; i < 64; i++) {
                ICLI_PRINTF("%-9s  %-8s  %-3u  %-3d\n", vtss_appl_qos_dscp2str(i), icli_bool_txt(c.dscp_map[i].trust), c.dscp_map[i].cos, c.dscp_map[i].dpl);
            }
            ICLI_PRINTF("\n");
        }

        if (has_dscp_ingress_translation) {
            ICLI_PRINTF("qos map dscp-ingress-translation:\n");
            ICLI_PRINTF("=================================\n");

            ICLI_PRINTF("DSCP       Translated DSCP\n");
            ICLI_PRINTF("---------  ---------------\n");

            for (i = 0; i < 64; i++) {
                ICLI_PRINTF("%-9s  %-9s\n", vtss_appl_qos_dscp2str(i), vtss_appl_qos_dscp2str(c.dscp_map[i].dscp));
            }
            ICLI_PRINTF("\n");
        }

        if (has_dscp_classify) {
            ICLI_PRINTF("qos map dscp-classify:\n");
            ICLI_PRINTF("======================\n");

            ICLI_PRINTF("DSCP       Classify\n");
            ICLI_PRINTF("---------  --------\n");

            for (i = 0; i < 64; i++) {
                ICLI_PRINTF("%-9s  %-8s\n", vtss_appl_qos_dscp2str(i), icli_bool_txt(c.dscp_map[i].remark));
            }
            ICLI_PRINTF("\n");
        }

        if (has_cos_dscp) {
            u32 dp_cnt = fast_cap(MESA_CAP_QOS_DPL_CNT);

            ICLI_PRINTF("qos map cos-dscp:\n");
            ICLI_PRINTF("=================\n");

            ICLI_PRINTF("Cos  ");
            for (i = 0; i < dp_cnt; i++) {
                ICLI_PRINTF("DSCP DP%u   ", i);
            }
            ICLI_PRINTF("\n");
            ICLI_PRINTF("---  ");
            for (i = 0; i < dp_cnt; i++) {
                ICLI_PRINTF("---------  ");
            }
            ICLI_PRINTF("\n");

            for (i = 0; i < VTSS_PRIO_ARRAY_SIZE; i++) {
                ICLI_PRINTF("%-3d  %-9s  %-9s  %-9s  %-9s\n", i,
                            vtss_appl_qos_dscp2str(c.cos_dscp_map[i].dscp),
                            vtss_appl_qos_dscp2str(c.cos_dscp_map[i].dscp_dp1),
                            dp_cnt < 4 ? "" : vtss_appl_qos_dscp2str(c.cos_dscp_map[i].dscp_dp2),
                            dp_cnt < 4 ? "" : vtss_appl_qos_dscp2str(c.cos_dscp_map[i].dscp_dp3));
            }
            ICLI_PRINTF("\n");
        }

        if (has_dscp_egress_translation) {
            ICLI_PRINTF("qos map dscp-egress-translation:\n");
            ICLI_PRINTF("================================\n");

            if (CAPA->has_dscp_dpl_remark) {
                ICLI_PRINTF("DSCP       Remap DP0  Remap DP1\n");
                ICLI_PRINTF("---------  ---------  ---------\n");
                for (i = 0; i < 64; i++) {
                    ICLI_PRINTF("%-9s  %-9s  %-9s\n",
                                vtss_appl_qos_dscp2str(i),
                                vtss_appl_qos_dscp2str(c.dscp_map[i].dscp_remap),
                                vtss_appl_qos_dscp2str(c.dscp_map[i].dscp_remap_dp1));
                }
            } else {
                ICLI_PRINTF("DSCP       Remap\n");
                ICLI_PRINTF("---------  ---------\n");
                for (i = 0; i < 64; i++) {
                    ICLI_PRINTF("%-9s  %-9s\n",
                                vtss_appl_qos_dscp2str(i),
                                vtss_appl_qos_dscp2str(c.dscp_map[i].dscp_remap));
                }
            }
            ICLI_PRINTF("\n");
        }

        if (has_ingress) {
            if (ing_id != MESA_QOS_MAP_ID_NONE) {
                QOS_ICLI_show_ingress_map(session_id, ing_id, TRUE);
            } else {
                mesa_qos_ingress_map_id_t id;
                int                       count = 0;
                while (vtss_appl_qos_ingress_map_conf_itr(count ? &id : NULL, &id) == VTSS_RC_OK) {
                    count++;
                    QOS_ICLI_show_ingress_map(session_id, id, FALSE);
                }
                if (count == 0) {
                    ICLI_PRINTF("%% QOS: no ingress maps found!\n");
                }
            }
        }

        if (has_egress) {
            if (egr_id != MESA_QOS_MAP_ID_NONE) {
                QOS_ICLI_show_egress_map(session_id, egr_id, TRUE);
            } else {
                mesa_qos_egress_map_id_t id;
                int                      count = 0;
                while (vtss_appl_qos_egress_map_conf_itr(count ? &id : NULL, &id) == VTSS_RC_OK) {
                    count++;
                    QOS_ICLI_show_egress_map(session_id, id, FALSE);
                }
                if (count == 0) {
                    ICLI_PRINTF("%% QOS: no egress maps found!\n");
                }
            }
        }

    }
#else
    // Avoid warnings
    has_dscp_cos                 = has_dscp_cos;
    has_dscp_ingress_translation = has_dscp_ingress_translation;
    has_dscp_classify            = has_dscp_classify;
    has_cos_dscp                 = has_cos_dscp;
    has_dscp_egress_translation  = has_dscp_egress_translation;
    has_ingress                  = has_ingress;
    ing_id                       = ing_id;
    has_egress                   = has_egress;
    egr_id                       = egr_id;
#endif /* defined(VTSS_SW_OPTION_QOS_ADV) */

    if (has_storm) {
        vtss_appl_qos_conf_t c;
        vtss_appl_qos_status_t s;
        char                 buf[32];

        IC_RC(vtss_appl_qos_conf_get(&c));
        IC_RC(vtss_appl_qos_status_get(&s));

        ICLI_PRINTF("qos storm:\n");
        ICLI_PRINTF("==========\n");
        ICLI_PRINTF("Unicast  : %8s %12s\n", icli_bool_txt(c.uc_policer.enable), vtss_appl_qos_rate2txt(c.uc_policer.rate, c.uc_policer.frame_rate, buf));
        ICLI_PRINTF("Multicast: %8s %12s\n", icli_bool_txt(c.mc_policer.enable), vtss_appl_qos_rate2txt(c.mc_policer.rate, c.mc_policer.frame_rate, buf));
        ICLI_PRINTF("Broadcast: %8s %12s\n", icli_bool_txt(c.bc_policer.enable), vtss_appl_qos_rate2txt(c.bc_policer.rate, c.bc_policer.frame_rate, buf));
        ICLI_PRINTF("Storm detected: %s\n", s.storm_active ? "TRUE" : "FALSE");
    }

#if defined(VTSS_APPL_QOS_QCL_INCLUDE)
    if (has_qce) {
        vtss_appl_qos_qce_intern_conf_t conf;
        vtss_appl_qos_qcl_user_t        user;
        switch_iter_t                   sit;

        if (qce) {
            if (vtss_appl_qos_qce_intern_get(VTSS_ISID_GLOBAL, VTSS_APPL_QOS_QCL_USER_STATIC, qce, &conf, FALSE) == VTSS_RC_OK) {
                QOS_ICLI_show_qce_conf(session_id, VTSS_APPL_QOS_QCL_USER_STATIC, &conf);
            } else {
                ICLI_PRINTF("%% QOS: qce %u not found\n", qce);
            }
        } else {
            int count = 0;
            int conflicts = 0;
            (void)icli_switch_iter_init(&sit);
            while (icli_switch_iter_getnext(&sit, NULL)) {
                for (user = VTSS_APPL_QOS_QCL_USER_STATIC; user < VTSS_APPL_QOS_QCL_USER_CNT; user++) {
                    qce = VTSS_APPL_QOS_QCE_ID_NONE;
                    while (vtss_appl_qos_qce_intern_get(sit.isid, user, qce, &conf, TRUE) == VTSS_RC_OK) {
                        count++;
                        qce = conf.qce.id;
                        if (conf.conflict) {
                            conflicts++;
                        }
                        QOS_ICLI_show_qce_conf(session_id, user, &conf);
                    }
                }
            }
            if (count == 0) {
                ICLI_PRINTF("\n%% QOS: no qce entries found!\n");
            } else if (conflicts) {
                ICLI_PRINTF("\n%% QOS: conflicts found!\n");
            }
        }
    }
#endif /* defined(VTSS_APPL_QOS_QCL_INCLUDE) */
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map dscp-cos { <0~63> | <dscp> } cos <0-7> dpl <dpl>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: qos
! 2: map
! 3: dscp-cos
! 4: <dscp_num:0~63>
! 5: <dscp_name:dscp>
! 6: cos
! 7: <cos:0-7>
! 8: dpl
! 9: <dpl:dpl>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl

HELP = ##HELP_QOS
HELP = ##HELP_QOS_MAP
HELP = Map for DSCP to COS
HELP = Specific DSCP or range
HELP =
HELP = Specify class of service
HELP = Specific class of service
HELP = Specify drop precedence level
HELP = Specific drop precedence level

BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>
BYWORD =
BYWORD = <Cos : 0-7>
BYWORD =
BYWORD = <Dpl : dpl>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  cnt;
    u32                  dscp_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                c.dscp_map[dscp_val].trust = TRUE;
                c.dscp_map[dscp_val].cos   = cos;
                c.dscp_map[dscp_val].dpl   = dpl;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].trust = TRUE;
        c.dscp_map[dscp_name].cos   = cos;
        c.dscp_map[dscp_name].dpl   = dpl;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map dscp-cos { <0~63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: no
! 2: qos
! 3: map
! 4: dscp-cos
! 5: <dscp_num:0~63>
! 6: <dscp_name:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name

HELP =
HELP = ##HELP_QOS
HELP = ##HELP_QOS_MAP
HELP = Map for DSCP to COS
HELP = Specific DSCP or range
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
    u32                  cnt;
    u32                  dscp_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                c.dscp_map[dscp_val].trust = dc.dscp_map[dscp_val].trust;
                c.dscp_map[dscp_val].cos   = dc.dscp_map[dscp_val].cos;
                c.dscp_map[dscp_val].dpl   = dc.dscp_map[dscp_val].dpl;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].trust = dc.dscp_map[dscp_name].trust;
        c.dscp_map[dscp_name].cos   = dc.dscp_map[dscp_name].cos;
        c.dscp_map[dscp_name].dpl   = dc.dscp_map[dscp_name].dpl;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map dscp-ingress-translation { <0~63> | <dscp> } to { <0-63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: qos
! 2: map
! 3: dscp-ingress-translation
! 4: <dscp_num:0~63>
! 5: <dscp_name:dscp>
! 6: to
! 7: <dscp_num_tr:0-63>
! 8: <dscp_name_tr:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name
CMD_VAR =
CMD_VAR = dscp_num_tr
CMD_VAR = dscp_name_tr

HELP =
HELP =
HELP = Map for DSCP ingress translation
HELP = Specific DSCP or range
HELP =
HELP =
HELP = Translated DSCP value
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>
BYWORD =
BYWORD = <DscpNumTr : 0-63>
BYWORD = <DscpNameTr : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  cnt;
    u32                  dscp_val;
    mesa_dscp_t          dscp;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    dscp = (dscp_name_tr != 0xFF) ? dscp_name_tr : dscp_num_tr & 0xFF;
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                c.dscp_map[dscp_val].dscp = dscp;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].dscp = dscp;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map dscp-ingress-translation { <0~63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: no
! 2: qos
! 3: map
! 4: dscp-ingress-translation
! 5: <dscp_num:0~63>
! 6: <dscp_name:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name

HELP =
HELP =
HELP =
HELP = Map for DSCP ingress translation
HELP = Specific DSCP or range
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
    u32                  cnt;
    u32                  dscp_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                c.dscp_map[dscp_val].dscp = dc.dscp_map[dscp_val].dscp;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].dscp = dc.dscp_map[dscp_name].dscp;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map dscp-classify { <0~63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: qos
! 2: map
! 3: dscp-classify
! 4: <dscp_num:0~63>
! 5: <dscp_name:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name

HELP =
HELP =
HELP = Map for DSCP classify enable
HELP = Specific DSCP or range
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  cnt;
    uint                 dscp;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
    u32                  cnt;
    uint                 dscp;
NO_FORM_VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp = dscp_num->range[cnt].min; dscp <= dscp_num->range[cnt].max; dscp++) {
                c.dscp_map[dscp].remark = TRUE;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].remark = TRUE;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

NO_FORM_CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp = dscp_num->range[cnt].min; dscp <= dscp_num->range[cnt].max; dscp++) {
                c.dscp_map[dscp].remark = dc.dscp_map[dscp].remark;
            }
        }
    } else if (dscp_name != 0xFF) {
        c.dscp_map[dscp_name].remark = dc.dscp_map[dscp_name].remark;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map cos-dscp <0~7> dpl <0~3> dscp { <0-63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = QOS_ICLI_runtime_dpl

! 1: qos
! 2: map
! 3: cos-dscp
! 4: <cos:0~7>
! 5: dpl
! 6: <dpl>
! 7: dscp
! 8: <dscp_num:0-63>
! 9: <dscp_name:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name

HELP =
HELP =
HELP = Map for COS to DSCP
HELP = Specific class of service or range
HELP = Specify drop precedence level
HELP = Specific drop precedence level or range
HELP = Specify DSCP
HELP = Specific DSCP
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD = <Cos : 0~7>
BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0-63>
BYWORD = <DscpName : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  cos_cnt;
    u32                  cos_val;
    mesa_dscp_t          dscp;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    dscp = (dscp_name != 0xFF) ? dscp_name : dscp_num & 0xFF;
    if (cos) {
        for (cos_cnt = 0; cos_cnt < cos->cnt; cos_cnt++) {
            for (cos_val = cos->range[cos_cnt].min; cos_val <= cos->range[cos_cnt].max; cos_val++) {
                u32 dpl_cnt;
                i32 dpl_val;
                if (dpl) {
                    for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                        for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                            if (dpl_val == 0) {
                                c.cos_dscp_map[cos_val].dscp = dscp;
                            } else if (dpl_val == 1) {
                                c.cos_dscp_map[cos_val].dscp_dp1 = dscp;
                            } else if (dpl_val == 2) {
                                c.cos_dscp_map[cos_val].dscp_dp2 = dscp;
                            } else {
                                c.cos_dscp_map[cos_val].dscp_dp3 = dscp;
                            }
                        }
                    }
                }
            }
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map cos-dscp <0~7> dpl <0~3>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = QOS_ICLI_runtime_dpl

! 1: no
! 2: qos
! 3: map
! 4: cos-dscp
! 5: <cos:0~7>
! 6: dpl
! 7: <dpl>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl

HELP =
HELP =
HELP =
HELP = Map for COS to DSCP
HELP = Specific class of service or range
HELP = Specify drop precedence level
HELP = Specific drop precedence level or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Cos : 0~7>
BYWORD =
BYWORD =

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
    u32                  cos_cnt;
    u32                  cos_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (cos) {
        for (cos_cnt = 0; cos_cnt < cos->cnt; cos_cnt++) {
            for (cos_val = cos->range[cos_cnt].min; cos_val <= cos->range[cos_cnt].max; cos_val++) {
                u32 dpl_cnt;
                i32 dpl_val;
                if (dpl) {
                    for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                        for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                            if (dpl_val == 0) {
                                c.cos_dscp_map[cos_val].dscp = dc.cos_dscp_map[cos_val].dscp;
                            } else if (dpl_val == 1) {
                                c.cos_dscp_map[cos_val].dscp_dp1 = dc.cos_dscp_map[cos_val].dscp_dp1;
                            } else if (dpl_val == 2) {
                                c.cos_dscp_map[cos_val].dscp_dp2 = dc.cos_dscp_map[cos_val].dscp_dp2;
                            } else {
                                c.cos_dscp_map[cos_val].dscp_dp3 = dc.cos_dscp_map[cos_val].dscp_dp3;
                            }
                        }
                    }
                }
            }
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map dscp-egress-translation { <0~63> | <dscp> } <0~1> to { <0-63> | <dscp> }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = QOS_ICLI_runtime_dscp_remark_dp_aware

! 1: qos
! 2: map
! 3: dscp-egress-translation
! 4: <dscp_num:0~63>
! 5: <dscp_name:dscp>
! 6: <dpl:0~1>
! 7: to
! 8: <dscp_num_tr:0-63>
! 9: <dscp_name_tr:dscp>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name
CMD_VAR = dpl
CMD_VAR =
CMD_VAR = dscp_num_tr
CMD_VAR = dscp_name_tr

HELP =
HELP =
HELP = Map for DSCP egress translation
HELP = Specific DSCP or range
HELP =
HELP = Specific drop precedence level or range
HELP =
HELP = Translated DSCP value
HELP =

BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>
BYWORD = <Dpl : 0~1>
BYWORD =
BYWORD = <DscpNumTr : 0-63>
BYWORD = <DscpNameTr : dscp>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  cnt;
    u32                  dscp_val;
    mesa_dscp_t          dscp;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    dscp = (dscp_name_tr != 0xFF) ? dscp_name_tr : dscp_num_tr & 0xFF;
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                if (CAPA->has_dscp_dpl_remark) {
                    u32 dpl_cnt;
                    u32 dpl_val;
                    if (dpl) {
                        for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                            for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                                if (dpl_val == 0) {
                                    c.dscp_map[dscp_val].dscp_remap = dscp;
                                } else {
                                    c.dscp_map[dscp_val].dscp_remap_dp1 = dscp;
                                }
                            }
                        }
                    }
                } else {
                    c.dscp_map[dscp_val].dscp_remap = dscp;
                }
            }
        }
    } else if (dscp_name != 0xFF) {
        if (CAPA->has_dscp_dpl_remark) {
            u32 dpl_cnt;
            u32 dpl_val;
            if (dpl) {
                for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                    for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                        if (dpl_val == 0) {
                            c.dscp_map[dscp_name].dscp_remap = dscp;
                        } else {
                            c.dscp_map[dscp_name].dscp_remap_dp1 = dscp;
                        }
                    }
                }
            }
        } else {
            c.dscp_map[dscp_name].dscp_remap = dscp;
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map dscp-egress-translation { <0~63> | <dscp> } <0~1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = QOS_ICLI_runtime_dscp_remark_dp_aware

! 1: no
! 2: qos
! 3: map
! 4: dscp-egress-translation
! 5: <dscp_num:0~63>
! 6: <dscp_name:dscp>
! 7: <dpl:0~1>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = dscp_num
CMD_VAR = dscp_name
CMD_VAR = dpl

HELP =
HELP =
HELP =
HELP = Map for DSCP egress translation
HELP = Specific DSCP or range
HELP =
HELP = Specific drop precedence level or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <DscpNum : 0~63>
BYWORD = <DscpName : dscp>
BYWORD = <Dpl : 0~1>

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
    u32                  cnt;
    u32                  dscp_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (dscp_num) {
        for (cnt = 0; cnt < dscp_num->cnt; cnt++) {
            for (dscp_val = dscp_num->range[cnt].min; dscp_val <= dscp_num->range[cnt].max; dscp_val++) {
                if (CAPA->has_dscp_dpl_remark) {
                    u32 dpl_cnt;
                    u32 dpl_val;
                    if (dpl) {
                        for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                            for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                                if (dpl_val == 0) {
                                    c.dscp_map[dscp_val].dscp_remap = dc.dscp_map[dscp_val].dscp_remap;
                                } else {
                                    c.dscp_map[dscp_val].dscp_remap_dp1 = dc.dscp_map[dscp_val].dscp_remap_dp1;
                                }
                            }
                        }
                    }
                } else {
                    c.dscp_map[dscp_val].dscp_remap = dc.dscp_map[dscp_val].dscp_remap;
               }
            }
        }
    } else if (dscp_name != 0xFF) {
        if (CAPA->has_dscp_dpl_remark) {
            u32 dpl_cnt;
            u32 dpl_val;
            if (dpl) {
                for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                    for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                        if (dpl_val == 0) {
                            c.dscp_map[dscp_name].dscp_remap = dc.dscp_map[dscp_name].dscp_remap;
                        } else {
                            c.dscp_map[dscp_name].dscp_remap_dp1 = dc.dscp_map[dscp_name].dscp_remap_dp1;
                        }
                    }
                }
            }
        } else {
            c.dscp_map[dscp_name].dscp_remap = dc.dscp_map[dscp_name].dscp_remap;
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos wred group <1~3> queue <0~7> dpl <0~3> min-fl <0-100> max <1-100> [ fill-level ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred
HELP    =
BYWORD  =

! wred
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_WRED
BYWORD  =

! group
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    = Specify group
BYWORD  =

! <1~3>
CMD_VAR = group
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    = Specific group or range
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME = QOS_ICLI_runtime_wred_queue
HELP    = Specific queue or range
BYWORD  =

! dpl
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_dpl
HELP    = Specify DPL
BYWORD  =

! <1~3>
CMD_VAR = dpl
RUNTIME = QOS_ICLI_runtime_wred_dpl
HELP    = Specific DPL or range
BYWORD  =

! min-fl
CMD_VAR =
RUNTIME =
HELP    = Specify minimum fill level
BYWORD  =

! <0-100>
CMD_VAR = min_fl
RUNTIME =
HELP    = Specific minimum fill level in percent
BYWORD  = <MinFl : 0-100>

! max
CMD_VAR =
RUNTIME =
HELP    = Specify maximum drop probability or fill level
BYWORD  =

! <1-100>
CMD_VAR = max
RUNTIME =
HELP    = Specific maximum drop probability or fill level in percent (default is drop probability)
BYWORD  = <Max : 1-100>

! fill-level
CMD_VAR = has_fill_level
RUNTIME =
HELP    = Specify fill level
BYWORD  = fill-level : Option

VARIABLE_BEGIN
    CapArray<BOOL, VTSS_APPL_CAP_QOS_WRED_GRP_CNT> groups;
    BOOL                 queues[MESA_QUEUE_ARRAY_SIZE] = {0};
    CapArray<BOOL, VTSS_APPL_CAP_QOS_WRED_DPL_CNT> dpls;
    u32                  cnt;
    int                  g_i, q_i, d_i;
    vtss_appl_qos_conf_t c;
VARIABLE_END

CODE_BEGIN
    if (has_fill_level && (min_fl >= max)) {
        ICLI_PRINTF("%% QOS: <max> (%d) must be greater than <min_fl> (%d) when unit is fill level\n", max, min_fl);
        return ICLI_RC_ERROR;
    }

    IC_RC(vtss_appl_qos_conf_get(&c));

    if (group) {
        for (cnt = 0; cnt < group->cnt; cnt++) {
            for (g_i = group->range[cnt].min; g_i <= group->range[cnt].max; g_i++) {
                groups[g_i - 1] = TRUE;
            }
        }
    } else {
        groups[0] = TRUE; // Select first group as default
    }
    if (queue) {
        for (cnt = 0; cnt < queue->cnt; cnt++) {
            for (q_i = queue->range[cnt].min; q_i <= queue->range[cnt].max; q_i++) {
                queues[q_i] = TRUE;
            }
        }
    } else {
        queues[0] = TRUE; // Select first queue as default
    }
    if (dpl) {
        for (cnt = 0; cnt < dpl->cnt; cnt++) {
            for (d_i = dpl->range[cnt].min; d_i <= dpl->range[cnt].max; d_i++) {
                dpls[d_i - 1] = TRUE;
            }
        }
    } else {
        dpls[0] = TRUE; // Select first dpl as default
    }

    for (g_i = 0; g_i < CAPA->wred_group_max; g_i++) {
        if (groups[g_i]) {
            for (q_i = 0; q_i < VTSS_APPL_QOS_PORT_WEIGHTED_QUEUE_CNT; q_i++) {
                if (queues[q_i]) {
                    for (d_i = 0; d_i < CAPA->wred_dpl_max; d_i++) {
                        if (dpls[d_i]) {
                            vtss_appl_qos_wred_t *wred = &c.wred[q_i][d_i][g_i];
                            wred->enable   = TRUE;
                            wred->min      = min_fl;
                            wred->max      = max;
                            wred->max_unit = (has_fill_level ? VTSS_APPL_QOS_WRED_MAX_FL : VTSS_APPL_QOS_WRED_MAX_DP);
                        }
                    }
                }
            }
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos wred group <1~3> queue <0~7> dpl <1~3>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! wred
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_WRED
BYWORD  =

! group
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    = Specify group
BYWORD  =

! <1~3>
CMD_VAR = group
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    = Specific group or range
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME = QOS_ICLI_runtime_wred_queue
HELP    = Specific queue or range
BYWORD  =

! dpl
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_dpl
HELP    = Specify DPL
BYWORD  =

! <1~3>
CMD_VAR = dpl
RUNTIME = QOS_ICLI_runtime_wred_dpl
HELP    = Specific DPL or range
BYWORD  =

VARIABLE_BEGIN
    CapArray<BOOL, VTSS_APPL_CAP_QOS_WRED_GRP_CNT> groups;
    BOOL                 queues[MESA_QUEUE_ARRAY_SIZE] = {0};
    CapArray<BOOL, VTSS_APPL_CAP_QOS_WRED_DPL_CNT> dpls;
    u32                  cnt;
    int                  g_i, q_i, d_i;
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));

    if (group) {
        for (cnt = 0; cnt < group->cnt; cnt++) {
            for (g_i = group->range[cnt].min; g_i <= group->range[cnt].max; g_i++) {
                groups[g_i - 1] = TRUE;
            }
        }
    } else {
        groups[0] = TRUE; // Select first group as default
    }
    if (queue) {
        for (cnt = 0; cnt < queue->cnt; cnt++) {
            for (q_i = queue->range[cnt].min; q_i <= queue->range[cnt].max; q_i++) {
                queues[q_i] = TRUE;
            }
        }
    } else {
        queues[0] = TRUE; // Select first queue as default
    }
    if (dpl) {
        for (cnt = 0; cnt < dpl->cnt; cnt++) {
            for (d_i = dpl->range[cnt].min; d_i <= dpl->range[cnt].max; d_i++) {
                dpls[d_i - 1] = TRUE;
            }
        }
    } else {
        dpls[0] = TRUE; // Select first dpl as default
    }

    for (g_i = 0; g_i < CAPA->wred_group_max; g_i++) {
        if (groups[g_i]) {
            for (q_i = 0; q_i < VTSS_APPL_QOS_PORT_WEIGHTED_QUEUE_CNT; q_i++) {
                if (queues[q_i]) {
                    for (d_i = 0; d_i < CAPA->wred_dpl_max; d_i++) {
                        if (dpls[d_i]) {
                            c.wred[q_i][d_i][g_i] = dc.wred[q_i][d_i][g_i];
                        }
                    }
                }
            }
        }
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos storm { unicast | multicast | broadcast } <uint> [ fps | kfps | kbps | mbps ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! storm
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_STORM
BYWORD  =

! unicast
CMD_VAR = has_unicast
RUNTIME =
HELP    = Police unicast frames
BYWORD  = unicast : Option

! multicast
CMD_VAR = has_multicast
RUNTIME =
HELP    = Police multicast frames
BYWORD  = multicast : Option

! broadcast
CMD_VAR = has_broadcast
RUNTIME =
HELP    = Police broadcast frames
BYWORD  = broadcast : Option

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_global_storm_rate
HELP    = Policer rate (default fps). Internally rounded up to the nearest value supported by the storm policer.
BYWORD  = <Rate : uint>

! fps
CMD_VAR =
RUNTIME =
HELP    = Unit is frames per second (default)
BYWORD  = fps : Option

! kfps
CMD_VAR = has_kfps
RUNTIME =
HELP    = Unit is kiloframes per second
BYWORD  = kfps : Option

! kbps
CMD_VAR = has_kbps
RUNTIME = QOS_ICLI_runtime_global_storm_has_bitrate
HELP    = Unit is kilobits per second
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME = QOS_ICLI_runtime_global_storm_has_bitrate
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    u32                  min;
    u32                  max;
    BOOL                 frame_rate = TRUE;
VARIABLE_END

CODE_BEGIN
    min = vtss_appl_qos_rate_min(CAPA->global_storm_bit_rate_min, CAPA->global_storm_frame_rate_min);
    max = vtss_appl_qos_rate_max(CAPA->global_storm_bit_rate_max, CAPA->global_storm_frame_rate_max);

    if (has_kfps || has_mbps) {
        rate = rate * 1000;
    }
    if (has_kbps || has_mbps) {
        frame_rate = FALSE;
    }

    if (rate < min) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min, has_kbps ? "kbps" : "fps");
        return ICLI_RC_ERROR;
    }
    if (rate > max) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max / 1000, has_kfps ? "kfps" : "mbps");
        return ICLI_RC_ERROR;
    }
    IC_RC(vtss_appl_qos_conf_get(&c));
    if (has_unicast) {
        c.uc_policer.enable     = TRUE;
        c.uc_policer.rate       = rate;
        c.uc_policer.frame_rate = frame_rate;
    } else if (has_multicast) {
        c.mc_policer.enable     = TRUE;
        c.mc_policer.rate       = rate;
        c.mc_policer.frame_rate = frame_rate;
    } else if (has_broadcast) {
        c.bc_policer.enable     = TRUE;
        c.bc_policer.rate       = rate;
        c.bc_policer.frame_rate = frame_rate;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos storm { unicast | multicast | broadcast }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! no
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! storm
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_STORM
BYWORD  =

! unicast
CMD_VAR = has_unicast
RUNTIME =
HELP    = Police unicast frames
BYWORD  = unicast : Option

! multicast
CMD_VAR = has_multicast
RUNTIME =
HELP    = Police multicast frames
BYWORD  = multicast : Option

! broadcast
CMD_VAR = has_broadcast
RUNTIME =
HELP    = Police broadcast frames
BYWORD  = broadcast : Option

VARIABLE_BEGIN
    vtss_appl_qos_conf_t c;
    vtss_appl_qos_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_conf_get(&c));
    IC_RC(vtss_appl_qos_conf_get_default(&dc));
    if (has_unicast) {
        c.uc_policer = dc.uc_policer;
    } else if (has_multicast) {
        c.mc_policer = dc.mc_policer;
    } else if (has_broadcast) {
        c.bc_policer = dc.bc_policer;
    }
    IC_RC(vtss_appl_qos_conf_set(&c));
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_APPL_QOS_QCL_INCLUDE)

COMMAND = qos qce { [ update ] } <uint> [ { next <uint> } | last ] [ interface <port_type_list> ] [ smac { <mac_addr> | <oui> | any } ] [ dmac { <mac_addr> | unicast | multicast | broadcast | any } ] [ tag { [ type { untagged | tagged | c-tagged | s-tagged | any } ] [ vid { <vcap_vr> | any } ] [ pcp { <pcp> | any } ] [ dei { <0-1> | any } ] }*1 ] [ inner-tag { [ type { untagged | tagged | c-tagged | s-tagged | any } ] [ vid { <vcap_vr> | any } ] [ pcp { <pcp> | any } ] [ dei { <0-1> | any } ] }*1 ] [ frame-type { any | { etype [ { <0x600-0x7ff,0x801-0x86dc,0x86de-0xffff> | any } ] } | { llc [ dsap { <0-0xff> | any } ] [ ssap { <0-0xff> | any } ] [ control { <0-0xff> | any } ] } | { snap [ { <0-0xffff> | any } ] } | { ipv4 [ proto { <0-255> | tcp | udp | any } ] [ sip { <ipv4_subnet> | any } ] [ dip { <ipv4_subnet> | any } ] [ dscp { <vcap_vr> | <dscp> | any } ] [ fragment { yes | no | any } ] [ sport { <vcap_vr> | any } ] [ dport { <vcap_vr> | any } ] } | { ipv6 [ proto { <0-255> | tcp | udp | any } ] [ sip { <ipv4_subnet> | any } ] [ dip { <ipv4_subnet> | any } ] [ dscp { <vcap_vr> | <dscp> | any } ] [ sport { <vcap_vr> | any } ] [ dport { <vcap_vr> | any } ] } } ] [ action { [ cos { <0-7> | default } ] [ dpl { <dpl> | default } ] [ pcp-dei { <0-7> <0-1> | default } ] [ dscp { <0-63> | <dscp> | default } ] [ policy { <uint> | default } ] [ ingress-map { <uint> | default } ] }*1 ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qce
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_QCE
BYWORD  =

! update
CMD_VAR = has_update
RUNTIME =
HELP    = Update an existing QCE
BYWORD  = update : Option

! <uint>
CMD_VAR = qce_id
RUNTIME = QOS_ICLI_runtime_qce_id
HELP    = ##HELP_QOS_QCE_ID
BYWORD  = <QceId : uint>

! next
CMD_VAR = has_next
RUNTIME =
HELP    = Place QCE before the next QCE ID
BYWORD  = next : Option

! <uint>
CMD_VAR = qce_id_next
RUNTIME = QOS_ICLI_runtime_qce_id
HELP    = The next QCE ID
BYWORD  = <QceIdNext : uint>

! last
CMD_VAR = has_last
RUNTIME =
HELP    = Place QCE at the end
BYWORD  = last : Option

! interface
CMD_VAR = has_interface
RUNTIME =
HELP    = Interfaces
BYWORD  = interface : Option

! <port_type_list>
CMD_VAR = port_list
RUNTIME =
HELP    =
BYWORD  = <PortList : port_type_list>

! smac
CMD_VAR = has_smac
RUNTIME = QOS_ICLI_runtime_qce_smac
HELP    = Setup matched SMAC
BYWORD  = smac : Option

! <mac_addr>
CMD_VAR = smac
RUNTIME = QOS_ICLI_runtime_qce_smac48
HELP    = Matched SMAC (XX-XX-XX-XX-XX-XX)
BYWORD  = <Smac : mac_addr>

! <oui>
CMD_VAR = smac_24
RUNTIME = QOS_ICLI_runtime_qce_smac24
HELP    = Matched SMAC OUI (XX-XX-XX)
BYWORD  = <Smac24 : oui>

! any
CMD_VAR = has_smac_any
RUNTIME =
HELP    = Match any SMAC
BYWORD  = any : Option

! dmac
CMD_VAR = has_dmac
RUNTIME =
HELP    = Setup matched DMAC
BYWORD  = dmac : Option

! <mac_addr>
CMD_VAR = dmac
RUNTIME = QOS_ICLI_runtime_qce_dmac
HELP    = Matched DMAC (XX-XX-XX-XX-XX-XX)
BYWORD  = <Dmac : mac_addr>

! unicast
CMD_VAR = has_unicast
RUNTIME =
HELP    = Match unicast DMAC
BYWORD  = unicast : Option

! multicast
CMD_VAR = has_multicast
RUNTIME =
HELP    = Match multicast DMAC
BYWORD  = multicast : Option

! broadcast
CMD_VAR = has_broadcast
RUNTIME =
HELP    = Match broadcast DMAC
BYWORD  = broadcast : Option

! any
CMD_VAR = has_dmac_any
RUNTIME =
HELP    = Match any DMAC
BYWORD  = any : Option

! tag
CMD_VAR = has_tag
RUNTIME =
HELP    = Setup tag options
BYWORD  = tag : Option

! type
CMD_VAR = has_ot_type
RUNTIME =
HELP    = Setup matched tag type
BYWORD  = type : Option

! untagged
CMD_VAR = has_ot_untagged
RUNTIME =
HELP    = Match untagged frames
BYWORD  = untagged : Option

! tagged
CMD_VAR = has_ot_tagged
RUNTIME =
HELP    = Match tagged frames
BYWORD  = tagged : Option

! c-tagged
CMD_VAR = has_ot_c_tagged
RUNTIME =
HELP    = Match C-tagged frames
BYWORD  = c-tagged : Option

! s-tagged
CMD_VAR = has_ot_s_tagged
RUNTIME =
HELP    = Match S-tagged frames
BYWORD  = s-tagged : Option

! any
CMD_VAR = has_ot_type_any
RUNTIME =
HELP    = Match tagged and untagged frames
BYWORD  = any : Option

! vid
CMD_VAR = has_ot_vid
RUNTIME =
HELP    = Setup matched VLAN ID
BYWORD  = vid : Option

! <vcap_vr>
CMD_VAR = ot_vid
RUNTIME = QOS_ICLI_runtime_qce_ot_vid
HELP    = Matched VLAN ID value/range
BYWORD  = <Vid : vcap_vr>

! any
CMD_VAR = has_ot_vid_any
RUNTIME =
HELP    = Match any VLAN ID
BYWORD  = any : Option

! pcp
CMD_VAR = has_ot_pcp
RUNTIME =
HELP    = Setup matched PCP
BYWORD  = pcp : Option

! <pcp>
CMD_VAR = ot_pcp
RUNTIME =
HELP    = Matched PCP value/range
BYWORD  = <Pcp : pcp>

! any
CMD_VAR = has_ot_pcp_any
RUNTIME =
HELP    = Match any PCP
BYWORD  = any : Option

! dei
CMD_VAR = has_ot_dei
RUNTIME =
HELP    = Setup matched DEI
BYWORD  = dei : Option

! <0-1>
CMD_VAR = ot_dei
RUNTIME =
HELP    = Matched DEI
BYWORD  = <Dei : 0-1>

! any
CMD_VAR = has_ot_dei_any
RUNTIME =
HELP    = Match any DEI
BYWORD  = any : Option

! inner-tag
CMD_VAR = has_inner_tag
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Setup inner tag options
BYWORD  = inner-tag : Option

! type
CMD_VAR = has_it_type
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Setup matched tag type
BYWORD  = type : Option

! untagged
CMD_VAR = has_it_untagged
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match untagged frames
BYWORD  = untagged : Option

! tagged
CMD_VAR = has_it_tagged
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match tagged frames
BYWORD  = tagged : Option

! c-tagged
CMD_VAR = has_it_c_tagged
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match C-tagged frames
BYWORD  = c-tagged : Option

! s-tagged
CMD_VAR = has_it_s_tagged
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match S-tagged frames
BYWORD  = s-tagged : Option

! any
CMD_VAR = has_it_type_any
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match tagged and untagged frames
BYWORD  = any : Option

! vid
CMD_VAR = has_it_vid
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Setup matched VLAN ID
BYWORD  = vid : Option

! <vcap_vr>
CMD_VAR = it_vid
RUNTIME = QOS_ICLI_runtime_qce_it_vid
HELP    = Matched VLAN ID value/range
BYWORD  = <Vid : vcap_vr>

! any
CMD_VAR = has_it_vid_any
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match any VLAN ID
BYWORD  = any : Option

! pcp
CMD_VAR = has_it_pcp
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Setup matched PCP
BYWORD  = pcp : Option

! <pcp>
CMD_VAR = it_pcp
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Matched PCP value/range
BYWORD  = <Pcp : pcp>

! any
CMD_VAR = has_it_pcp_any
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match any PCP
BYWORD  = any : Option

! dei
CMD_VAR = has_it_dei
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Setup matched DEI
BYWORD  = dei : Option

! <0-1>
CMD_VAR = it_dei
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Matched DEI
BYWORD  = <Dei : 0-1>

! any
CMD_VAR = has_it_dei_any
RUNTIME = QOS_ICLI_runtime_qce_inner_tag
HELP    = Match any DEI
BYWORD  = any : Option

! frame-type
CMD_VAR = has_frame_type
RUNTIME =
HELP    = Setup matched frame type
BYWORD  = frame-type : Option

! any
CMD_VAR =
RUNTIME =
HELP    = Match any frame type
BYWORD  = any : Option

! etype
CMD_VAR = has_etype
RUNTIME =
HELP    = Match EtherType frames
BYWORD  = etype : Option

! <0x600-0x7ff,0x801-0x86dc,0x86de-0xffff>
CMD_VAR = etype_type
RUNTIME =
HELP    = Matched EtherType
BYWORD  = <EtherType : 0x600-0x7ff,0x801-0x86dc,0x86de-0xffff>

! any
CMD_VAR = has_etype_type_any
RUNTIME =
HELP    = Match any EtherType
BYWORD  = any : Option

! llc
CMD_VAR = has_llc
RUNTIME =
HELP    = Match LLC frames
BYWORD  = llc : Option

! dsap
CMD_VAR = has_llc_dsap
RUNTIME =
HELP    = Setup matched LLC DSAP
BYWORD  = dsap : Option

! <0-0xff>
CMD_VAR = llc_dsap
RUNTIME =
HELP    = Matched LLC DSAP
BYWORD  = <Dsap : 0-0xff>

! any
CMD_VAR = has_llc_dsap_any
RUNTIME =
HELP    = Match any LLC DSAP
BYWORD  = any : Option

! ssap
CMD_VAR = has_llc_ssap
RUNTIME =
HELP    = Setup matched LLC SSAP
BYWORD  = ssap : Option

! <0-0xff>
CMD_VAR = llc_ssap
RUNTIME =
HELP    = Matched LLC SSAP
BYWORD  = <Ssap : 0-0xff>

! any
CMD_VAR = has_llc_ssap_any
RUNTIME =
HELP    = Match any LLC SSAP
BYWORD  = any : Option

! control
CMD_VAR = has_llc_control
RUNTIME =
HELP    = Setup matched LLC Control byte
BYWORD  = control : Option

! <0-0xff>
CMD_VAR = llc_control
RUNTIME =
HELP    = Matched LLC Control byte
BYWORD  = <Control : 0-0xff>

! any
CMD_VAR = has_llc_control_any
RUNTIME =
HELP    = Match any LLC Control byte
BYWORD  = any : Option

! snap
CMD_VAR = has_snap
RUNTIME =
HELP    = Match SNAP frames
BYWORD  = snap : Option

! <0-0xffff>
CMD_VAR = snap_data
RUNTIME =
HELP    = Setup matched SNAP EtherType
BYWORD  = <SnapData : 0-0xffff>

! any
CMD_VAR = has_snap_data_any
RUNTIME =
HELP    = Match any SNAP EtherType
BYWORD  = any : Option

! ipv4
CMD_VAR = has_ipv4
RUNTIME =
HELP    = Match IPv4 frames
BYWORD  = ipv4 : Option

! proto
CMD_VAR = has_pr4
RUNTIME =
HELP    = Setup matched IP protocol
BYWORD  = proto : Option

! <0-255>
CMD_VAR = pr4
RUNTIME =
HELP    = Matched IP protocol
BYWORD  = <Protocol : 0-255>

! tcp
CMD_VAR = has_pr4_tcp
RUNTIME =
HELP    = Match TCP frames
BYWORD  = tcp : Option

! udp
CMD_VAR = has_pr4_udp
RUNTIME =
HELP    = Match UDP frames
BYWORD  = udp : Option

! any
CMD_VAR = has_pr4_any
RUNTIME =
HELP    = Match any IP protocol
BYWORD  = any : Option

! sip
CMD_VAR = has_sip4
RUNTIME = QOS_ICLI_runtime_qce_sip
HELP    = Setup matched source IP address
BYWORD  = sip : Option

! <ipv4_subnet>
CMD_VAR = sip4
RUNTIME =
HELP    = Matched source IP address/mask
BYWORD  = <Sip : ipv4_subnet>

! any
CMD_VAR = has_sip4_any
RUNTIME =
HELP    = Match any source IP address
BYWORD  = any : Option

! dip
CMD_VAR = has_dip4
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Setup matched destination IP address
BYWORD  = dip : Option

! <ipv4_subnet>
CMD_VAR = dip4
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Matched destination IP address/mask
BYWORD  = <Dip : ipv4_subnet>

! any
CMD_VAR = has_dip4_any
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Match any destination IP address
BYWORD  = any : Option

! dscp
CMD_VAR = has_dscp4
RUNTIME =
HELP    = Setup matched DSCP
BYWORD  = dscp : Option

! <vcap_vr>
CMD_VAR = dscp4
RUNTIME = QOS_ICLI_runtime_qce_dscp
HELP    = Matched DSCP value/range
BYWORD  = <Dscp : vcap_vr>

! <dscp>
CMD_VAR = dscp4_name
RUNTIME =
HELP    =
BYWORD  = <Dscp4Name : dscp>

! any
CMD_VAR = has_dscp4_any
RUNTIME =
HELP    = Match any DSCP
BYWORD  = any : Option

! fragment
CMD_VAR = has_fr4
RUNTIME =
HELP    = Setup matched IPv4 fragments
BYWORD  = fragment : Option

! yes
CMD_VAR = has_fr4_yes
RUNTIME =
HELP    = Match IPv4 fragments
BYWORD  = yes : Option

! no
CMD_VAR = has_fr4_no
RUNTIME =
HELP    = Match IPv4 non-fragments
BYWORD  = no : Option

! any
CMD_VAR = has_fr4_any
RUNTIME =
HELP    = Match any IPv4 fragments
BYWORD  = any : Option

! sport
CMD_VAR = has_sp4
RUNTIME =
HELP    = Setup matched UDP/TCP source port
BYWORD  = sport : Option

! <vcap_vr>
CMD_VAR = sp4
RUNTIME = QOS_ICLI_runtime_qce_sport
HELP    = Match UDP/TCP source port value/range
BYWORD  = <Sport : vcap_vr>

! any
CMD_VAR = has_sp4_any
RUNTIME =
HELP    = Match any UDP/TCP source port
BYWORD  = any : Option

! dport
CMD_VAR = has_dp4
RUNTIME =
HELP    = Setup matched UDP/TCP destination port
BYWORD  = dport : Option

! <vcap_vr>
CMD_VAR = dp4
RUNTIME = QOS_ICLI_runtime_qce_dport
HELP    = Match UDP/TCP destination port value/range
BYWORD  = <Dport : vcap_vr>

! any
CMD_VAR = has_dp4_any
RUNTIME =
HELP    = Match any UDP/TCP destination port
BYWORD  = any : Option

! ipv6
CMD_VAR = has_ipv6
RUNTIME =
HELP    = Match IPv6 frames
BYWORD  = ipv6 : Option

! proto
CMD_VAR = has_pr6
RUNTIME =
HELP    = Setup matched IP protocol
BYWORD  = proto : Option

! <0-255>
CMD_VAR = pr6
RUNTIME =
HELP    = Matched IP protocol
BYWORD  = <Protocol : 0-255>

! tcp
CMD_VAR = has_pr6_tcp
RUNTIME =
HELP    = Match TCP frames
BYWORD  = tcp : Option

! udp
CMD_VAR = has_pr6_udp
RUNTIME =
HELP    = Match UDP frames
BYWORD  = udp : Option

! any
CMD_VAR = has_pr6_any
RUNTIME =
HELP    = Match any IP protocol
BYWORD  = any : Option

! sip
CMD_VAR = has_sip6
RUNTIME = QOS_ICLI_runtime_qce_sip
HELP    = Setup matched source IP address
BYWORD  = sip : Option

! <ipv4_subnet>
CMD_VAR = sip6
RUNTIME =
HELP    = Matched source IP address/mask
BYWORD  = <Sip : ipv4_subnet>

! any
CMD_VAR = has_sip6_any
RUNTIME =
HELP    = Match any source IP address
BYWORD  = any : Option

! dip
CMD_VAR = has_dip6
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Setup matched destination IP address
BYWORD  = dip : Option

! <ipv4_subnet>
CMD_VAR = dip6
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Matched destination IP address/mask
BYWORD  = <Dip : ipv4_subnet>

! any
CMD_VAR = has_dip6_any
RUNTIME = QOS_ICLI_runtime_qce_dip
HELP    = Match any destination IP address
BYWORD  = any : Option

! dscp
CMD_VAR = has_dscp6
RUNTIME =
HELP    = Setup matched DSCP
BYWORD  = dscp : Option

! <vcap_vr>
CMD_VAR = dscp6
RUNTIME = QOS_ICLI_runtime_qce_dscp
HELP    = Matched DSCP value/range
BYWORD  = <Dscp : vcap_vr>

! <dscp>
CMD_VAR = dscp6_name
RUNTIME =
HELP    =
BYWORD  = <Dscp6Name : dscp>

! any
CMD_VAR = has_dscp6_any
RUNTIME =
HELP    = Match any DSCP
BYWORD  = any : Option

! sport
CMD_VAR = has_sp6
RUNTIME =
HELP    = Setup matched UDP/TCP source port
BYWORD  = sport : Option

! <vcap_vr>
CMD_VAR = sp6
RUNTIME = QOS_ICLI_runtime_qce_sport
HELP    = Match UDP/TCP source port value/range
BYWORD  = <Sport : vcap_vr>

! any
CMD_VAR = has_sp6_any
RUNTIME =
HELP    = Match any UDP/TCP source port
BYWORD  = any : Option

! dport
CMD_VAR = has_dp6
RUNTIME =
HELP    = Setup matched UDP/TCP destination port
BYWORD  = dport : Option

! <vcap_vr>
CMD_VAR = dp6
RUNTIME = QOS_ICLI_runtime_qce_dport
HELP    = Match UDP/TCP destination port value/range
BYWORD  = <Dport : vcap_vr>

! any
CMD_VAR = has_dp6_any
RUNTIME =
HELP    = Match any UDP/TCP destination port
BYWORD  = any : Option

! action
CMD_VAR = has_action
RUNTIME =
HELP    = Setup action
BYWORD  = action : Option

! cos
CMD_VAR = has_action_cos
RUNTIME =
HELP    = Setup class of service action
BYWORD  = cos : Option

! <0-7>
CMD_VAR = action_cos
RUNTIME =
HELP    = Assign class of service
BYWORD  = <Cos : 0-7>

! default
CMD_VAR = has_action_cos_default
RUNTIME =
HELP    = Keep existing class of service
BYWORD  = default : Option

! dpl
CMD_VAR = has_action_dpl
RUNTIME =
HELP    = Setup drop precedence level action
BYWORD  = dpl : Option

! <0-1>
CMD_VAR = action_dpl
RUNTIME =
HELP    = Assign drop precedence level
BYWORD  = <Dpl : dpl>

! default
CMD_VAR = has_action_dpl_default
RUNTIME =
HELP    = Keep existing drop precedence level
BYWORD  = default : Option

! pcp-dei
CMD_VAR = has_action_pcp_dei
RUNTIME =
HELP    = Setup PCP and DEI action
BYWORD  = tag : Option

! <0-7>
CMD_VAR = action_pcp
RUNTIME =
HELP    = Assign PCP
BYWORD  = <Pcp : 0-7>

! <0-1>
CMD_VAR = action_dei
RUNTIME =
HELP    = Assign DEI
BYWORD  = <Dei : 0-1>

! default
CMD_VAR = has_action_pcp_dei_default
RUNTIME =
HELP    = Keep existing PCP and DEI
BYWORD  = default : Option

! dscp
CMD_VAR = has_action_dscp
RUNTIME =
HELP    = Setup DSCP action
BYWORD  = dscp : Option

! <0-63>
CMD_VAR = action_dscp_dscp
RUNTIME =
HELP    = Assign DSCP
BYWORD  = <Dscp : 0-63>

! <dscp>
CMD_VAR = action_dscp_name
RUNTIME =
HELP    =
BYWORD  = <DscpName : dscp>

! default
CMD_VAR = has_action_dscp_default
RUNTIME =
HELP    = Keep existing DSCP
BYWORD  = default : Option

! policy
CMD_VAR = has_action_policy
RUNTIME =
HELP    = Setup ACL policy action
BYWORD  = policy : Option

! <uint>
CMD_VAR = action_policy
RUNTIME = QOS_ICLI_runtime_policy
HELP    = Assign ACL policy
BYWORD  = <Policy : uint>

! default
CMD_VAR = has_action_policy_default
RUNTIME =
HELP    = Keep existing ACL policy
BYWORD  = default : Option

! ingress-map
CMD_VAR = has_action_ingress_map
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = Setup ingress map action
BYWORD  = ingress-map : Option

! <uint>
CMD_VAR = action_ingress_map
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = Assign ingress map id
BYWORD  = <ActionIngressMap : uint>

! default
CMD_VAR = has_action_ingress_map_default
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = Keep existing ingress map
BYWORD  = default : Option

VARIABLE_BEGIN
    // Initialize the following variables to an out of range value.
    // This enables us to use 'any' for unspecified parameters.
#define QCE_ANY 0xffffffff
    etype_type = snap_data = QCE_ANY;
#define DSCP_ANY 0xff
    dscp4_name = dscp6_name = DSCP_ANY;

    vtss_appl_qos_qce_intern_conf_t conf, conf_next;
    mesa_qce_t                      *const q = &conf.qce;
    mesa_qce_key_t                  *const k = &q->key;
    mesa_qce_action_t               *const a = &q->action;
    mesa_qce_id_t                   id_next = VTSS_APPL_QOS_QCE_ID_NONE; // Defauld 'next' is 'last'
    mesa_qce_type_t                 frametype = MESA_QCE_TYPE_ANY;       // Default frametype
    port_iter_t                     pit;
    int                             i;
VARIABLE_END

CODE_BEGIN
    if (has_next) {
        id_next = qce_id_next;
    }

    frametype = MESA_QCE_TYPE_ANY; // Default frametype
    if (has_frame_type) {
        if (has_etype) {
            frametype = MESA_QCE_TYPE_ETYPE;
        } else if (has_llc) {
            frametype = MESA_QCE_TYPE_LLC;
        } else if (has_snap) {
            frametype = MESA_QCE_TYPE_SNAP;
        } else if (has_ipv4) {
            frametype = MESA_QCE_TYPE_IPV4;
        } else if (has_ipv6) {
            frametype = MESA_QCE_TYPE_IPV6;
        }
    }

    if (has_update) {
        if (vtss_appl_qos_qce_intern_get(VTSS_ISID_GLOBAL, VTSS_APPL_QOS_QCL_USER_STATIC, qce_id, &conf, FALSE) != VTSS_RC_OK) {
            ICLI_PRINTF("%% QOS: qce %u not found\n", qce_id);
            return ICLI_RC_ERROR;
        }
        if (!has_next && !has_last) { // next and last not specified - keep existing position by getting the 'real' next id
            if (vtss_appl_qos_qce_intern_get(VTSS_ISID_GLOBAL, VTSS_APPL_QOS_QCL_USER_STATIC, qce_id, &conf_next, TRUE) == VTSS_RC_OK) {
                id_next = conf_next.qce.id;
            }
        }
        if (has_frame_type && (conf.qce.key.type != frametype)) {
            // Set the frame fields to default if changing frametype, as same space is shared by all frame types
            memset(&k->frame, 0, sizeof(k->frame));
        }
    } else { // This is an 'add'. Start with a new clean and default QCE
        (void)vtss_appl_qos_qce_intern_get_default(&conf);
        q->id = qce_id;
        conf.isid = VTSS_ISID_START;
        port_iter_init_local(&pit);
        while (port_iter_getnext(&pit)) {
            conf.qce.key.port_list[pit.iport] = TRUE; // Default is all ports selected
        }
    }

    if (has_interface) {
        if (port_list) {
            memset(k->port_list, 0, sizeof(k->port_list)); // Clear port list
            conf.isid = VTSS_ISID_START;
            (void)icli_port_iter_init(&pit, conf.isid, PORT_ITER_FLAGS_NORMAL);
            while (icli_port_iter_getnext(&pit, port_list)) {
                conf.qce.key.port_list[pit.iport] = TRUE;
            }
        } else {
            ICLI_PRINTF("%% QOS: no interface(s) specified\n");
            return ICLI_RC_ERROR;
        }
    }

    if (has_tag) {
        if (has_ot_type) {
            mesa_vcap_bit_t s_tag = MESA_VCAP_BIT_ANY;
            if (has_ot_untagged) {
                k->tag.tagged = MESA_VCAP_BIT_0;
            } else if (has_ot_tagged) {
                k->tag.tagged = MESA_VCAP_BIT_1;
            } else if (has_ot_c_tagged) {
                k->tag.tagged = MESA_VCAP_BIT_1;
                s_tag         = MESA_VCAP_BIT_0;
            } else if (has_ot_s_tagged) {
                k->tag.tagged = MESA_VCAP_BIT_1;
                s_tag         = MESA_VCAP_BIT_1;
            } else if (has_ot_type_any) {
                k->tag.tagged = MESA_VCAP_BIT_ANY;
            }
            k->tag.s_tag = s_tag;
        }

        if (has_ot_vid) {
            if (has_ot_vid_any) {
                vtss_appl_qos_qcl_range_set(&k->tag.vid, 0, 0, 0);
            } else {
                vtss_appl_qos_qcl_range_set(&k->tag.vid, ot_vid.low, ot_vid.high, 0xFFF);
            }
        }

        if (has_ot_pcp) {
            if (ot_pcp) {
                k->tag.pcp.value = ot_pcp->range[0].min;
                k->tag.pcp.mask = (7 - (ot_pcp->range[0].max - ot_pcp->range[0].min));
            } else if (has_ot_pcp_any) {
                k->tag.pcp.value = 0;
                k->tag.pcp.mask  = 0;
            }
        }

        if (has_ot_dei) {
            if (has_ot_dei_any) {
                k->tag.dei = MESA_VCAP_BIT_ANY;
            } else {
                k->tag.dei = ot_dei ? MESA_VCAP_BIT_1 : MESA_VCAP_BIT_0;
            }
        }
    }

    if (has_inner_tag) {
        if (has_it_type) {
            k->inner_tag.s_tag = MESA_VCAP_BIT_ANY;
            if (has_it_untagged) {
                k->inner_tag.tagged = MESA_VCAP_BIT_0;
            } else if (has_it_tagged) {
                k->inner_tag.tagged = MESA_VCAP_BIT_1;
            } else if (has_it_c_tagged) {
                k->inner_tag.tagged = MESA_VCAP_BIT_1;
                k->inner_tag.s_tag  = MESA_VCAP_BIT_0;
            } else if (has_it_s_tagged) {
                k->inner_tag.tagged = MESA_VCAP_BIT_1;
                k->inner_tag.s_tag  = MESA_VCAP_BIT_1;
            } else if (has_it_type_any) {
                k->inner_tag.tagged = MESA_VCAP_BIT_ANY;
            }
        }

        if (has_it_vid) {
            if (has_it_vid_any) {
                vtss_appl_qos_qcl_range_set(&k->inner_tag.vid, 0, 0, 0);
            } else {
                vtss_appl_qos_qcl_range_set(&k->inner_tag.vid, it_vid.low, it_vid.high, 0xFFF);
            }
        }

        if (has_it_pcp) {
            if (it_pcp) {
                k->inner_tag.pcp.value = it_pcp->range[0].min;
                k->inner_tag.pcp.mask = (7 - (it_pcp->range[0].max - it_pcp->range[0].min));
            } else if (has_it_pcp_any) {
                k->inner_tag.pcp.value = 0;
                k->inner_tag.pcp.mask  = 0;
            }
        }

        if (has_it_dei) {
            if (has_it_dei_any) {
                k->inner_tag.dei = MESA_VCAP_BIT_ANY;
            } else {
                k->inner_tag.dei = it_dei ? MESA_VCAP_BIT_1 : MESA_VCAP_BIT_0;
            }
        }
    }

    if (has_smac) {
        for (i = 0; i < 6; i++) {
            if (has_smac_any) {
                k->mac.smac.value[i] = 0;
                k->mac.smac.mask[i] = 0;
            } else {
                k->mac.smac.value[i] = smac.addr[i];
                k->mac.smac.mask[i] = 0xFF;
            }
        }
    }

    if (has_dmac) {
        k->mac.dmac_bc = MESA_VCAP_BIT_ANY;
        k->mac.dmac_mc = MESA_VCAP_BIT_ANY;
        for (i = 0; i < 6; i++) {
            k->mac.dmac.value[i] = 0;
            k->mac.dmac.mask[i] = 0;
        }
        if (has_unicast) {
            k->mac.dmac_bc = MESA_VCAP_BIT_0;
            k->mac.dmac_mc = MESA_VCAP_BIT_0;
        } else if (has_multicast) {
            k->mac.dmac_bc = MESA_VCAP_BIT_0;
            k->mac.dmac_mc = MESA_VCAP_BIT_1;
        } else if (has_broadcast) {
            k->mac.dmac_bc = MESA_VCAP_BIT_1;
            k->mac.dmac_mc = MESA_VCAP_BIT_1;
        } else if (has_dmac_any) {
            k->mac.dmac_bc = MESA_VCAP_BIT_ANY;
            k->mac.dmac_mc = MESA_VCAP_BIT_ANY;
        } else if (CAPA->has_qce_dmac) {
            for (i = 0; i < 6; i++) {
                k->mac.dmac.value[i] = dmac.addr[i];
                k->mac.dmac.mask[i] = 0xFF;
            }
        }
    }

    if (has_frame_type) {
        k->type = frametype; // frametype has been discovered earliere
        switch (frametype) {
        case MESA_QCE_TYPE_ETYPE: {
            mesa_qce_frame_etype_t *etype = &k->frame.etype;
            if (has_etype_type_any) {
                etype->etype.value[0] = 0;
                etype->etype.mask[0] =  0;
                etype->etype.value[1] = 0;
                etype->etype.mask[1] =  0;
            } else if (etype_type != QCE_ANY) {
                etype->etype.value[0] = (etype_type >> 8) & 0xFF;
                etype->etype.mask[0] =  0xFF;
                etype->etype.value[1] = etype_type & 0xFF;
                etype->etype.mask[1] =  0xFF;
            }
            break;
        }
        case MESA_QCE_TYPE_LLC: {
            mesa_qce_frame_llc_t *llc = &k->frame.llc;
            if (has_llc_dsap) {
                if (has_llc_dsap_any) {
                    llc->data.value[0] = 0;
                    llc->data.mask[0]  = 0;
                } else {
                    llc->data.value[0] = llc_dsap & 0xFF;
                    llc->data.mask[0]  = 0xFF;
                }
            }
            if (has_llc_ssap) {
                if (has_llc_ssap_any) {
                    llc->data.value[1] = 0;
                    llc->data.mask[1]  = 0;
                } else {
                    llc->data.value[1] = llc_ssap & 0xFF;
                    llc->data.mask[1]  = 0xFF;
                }
            }
            if (has_llc_control) {
                if (has_llc_control_any) {
                    llc->data.value[2] = 0;
                    llc->data.mask[2]  = 0;
                } else {
                    llc->data.value[2] = llc_control & 0xFF;
                    llc->data.mask[2]  = 0xFF;
                }
            }
            break;
        }
        case MESA_QCE_TYPE_SNAP: {
            mesa_qce_frame_snap_t *snap = &k->frame.snap;
            if (has_snap_data_any) {
                snap->data.value[3] = 0;
                snap->data.mask[3]  = 0;
                snap->data.value[4] = 0;
                snap->data.mask[4]  = 0;
            } else if (snap_data != QCE_ANY) {
                snap->data.value[3] = (snap_data >> 8) & 0xFF;
                snap->data.mask[3]  = 0xFF;
                snap->data.value[4] = snap_data & 0xFF;
                snap->data.mask[4]  = 0xFF;
            }
            break;
        }
        case MESA_QCE_TYPE_IPV4: {
            mesa_qce_frame_ipv4_t *i4 = &k->frame.ipv4;
            if (has_pr4) {
                if (has_pr4_any) {
                    i4->proto.value = 0;
                    i4->proto.mask =  0;
                } else if (has_pr4_tcp) {
                    i4->proto.value = 6;
                    i4->proto.mask =  0xFF;
                } else if (has_pr4_udp) {
                    i4->proto.value = 17;
                    i4->proto.mask =  0xFF;
                } else {
                    i4->proto.value = pr4;
                    i4->proto.mask =  0xFF;
                }
            }

            if (has_sip4) {
                if (has_sip4_any) {
                    i4->sip.value = 0;
                    i4->sip.mask  = 0;
                } else {
                    i4->sip.value = sip4.ip;
                    i4->sip.mask  = sip4.netmask;
                }
            }

            if (has_dip4) {
                if (has_dip4_any) {
                    i4->dip.value = 0;
                    i4->dip.mask  = 0;
                } else {
                    i4->dip.value = dip4.ip;
                    i4->dip.mask  = dip4.netmask;
                }
            }

            if (has_dscp4) {
                if (has_dscp4_any) {
                    vtss_appl_qos_qcl_range_set(&i4->dscp, 0, 0, 0);
                } else if (dscp4_name != DSCP_ANY) {
                    vtss_appl_qos_qcl_range_set(&i4->dscp, dscp4_name, dscp4_name, 0x3F);
                } else {
                    vtss_appl_qos_qcl_range_set(&i4->dscp, dscp4.low, dscp4.high, 0x3F);
                }
            }

            if (has_fr4) {
                if (has_fr4_yes) {
                    i4->fragment = MESA_VCAP_BIT_1;
                } else if (has_fr4_no) {
                    i4->fragment = MESA_VCAP_BIT_0;
                } else if (has_fr4_any) {
                    i4->fragment = MESA_VCAP_BIT_ANY;
                }
            }

            if (has_sp4) {
                if (has_sp4_any) {
                    vtss_appl_qos_qcl_range_set(&i4->sport, 0, 0, 0);
                } else {
                    vtss_appl_qos_qcl_range_set(&i4->sport, sp4.low, sp4.high, 0xFFFF);
                }
            }

            if (has_dp4) {
                if (has_dp4_any) {
                    vtss_appl_qos_qcl_range_set(&i4->dport, 0, 0, 0);
                } else {
                    vtss_appl_qos_qcl_range_set(&i4->dport, dp4.low, dp4.high, 0xFFFF);
                }
            }
            break;
        }
        case MESA_QCE_TYPE_IPV6: {
            mesa_qce_frame_ipv6_t *i6 = &k->frame.ipv6;
            if (has_pr6) {
                if (has_pr6_any) {
                    i6->proto.value = 0;
                    i6->proto.mask =  0;
                } else if (has_pr6_tcp) {
                    i6->proto.value = 6;
                    i6->proto.mask =  0xFF;
                } else if (has_pr6_udp) {
                    i6->proto.value = 17;
                    i6->proto.mask =  0xFF;
                } else {
                    i6->proto.value = pr6;
                    i6->proto.mask =  0xFF;
                }
            }

            if (has_sip6) {
                for (i = 0; i < 4; i++) {
                    if (has_sip6_any) {
                        i6->sip.value[i + 12] = 0;
                        i6->sip.mask[i + 12]  = 0;
                    } else {
                        i6->sip.value[i + 12] = (sip6.ip >> ((3 - i) * 8)) & 0xFF;
                        i6->sip.mask[i + 12]  = (sip6.netmask >> ((3 - i) * 8)) & 0xFF;
                    }
                }
            }

            if (has_dip6) {
                for (i = 0; i < 4; i++) {
                    if (has_dip6_any) {
                        i6->dip.value[i + 12] = 0;
                        i6->dip.mask[i + 12]  = 0;
                    } else {
                        i6->dip.value[i + 12] = (dip6.ip >> ((3 - i) * 8)) & 0xFF;
                        i6->dip.mask[i + 12]  = (dip6.netmask >> ((3 - i) * 8)) & 0xFF;
                    }
                }
            }

            if (has_dscp6) {
                if (has_dscp6_any) {
                    vtss_appl_qos_qcl_range_set(&i6->dscp, 0, 0, 0);
                } else if (dscp6_name != DSCP_ANY) {
                    vtss_appl_qos_qcl_range_set(&i6->dscp, dscp6_name, dscp6_name, 0x3F);
                } else {
                    vtss_appl_qos_qcl_range_set(&i6->dscp, dscp6.low, dscp6.high, 0x3F);
                }
            }

            if (has_sp6) {
                if (has_sp6_any) {
                    vtss_appl_qos_qcl_range_set(&i6->sport, 0, 0, 0);
                } else  {
                    vtss_appl_qos_qcl_range_set(&i6->sport, sp6.low, sp6.high, 0xFFFF);
                }
            }

            if (has_dp6) {
                if (has_dp6_any) {
                    vtss_appl_qos_qcl_range_set(&i6->dport, 0, 0, 0);
                } else {
                    vtss_appl_qos_qcl_range_set(&i6->dport, dp6.low, dp6.high, 0xFFFF);
                }
            }
            break;
        }
        default:
            break; // Do nothing
        }
    }

    if (has_action) {
        if (has_action_cos) {
            if (has_action_cos_default) {
                a->prio = 0;
                a->prio_enable = FALSE;
            } else {
                a->prio = action_cos;
                a->prio_enable = TRUE;
            }
        }
        if (has_action_dpl) {
            if (has_action_dpl_default) {
                a->dp = 0;
                a->dp_enable = FALSE;
            } else {
                a->dp = action_dpl;
                a->dp_enable = TRUE;
            }
        }
        if (has_action_dscp) {
            if (has_action_dscp_default) {
                a->dscp = 0;
                a->dscp_enable = FALSE;
            } else {
                a->dscp = (action_dscp_name != DSCP_ANY) ? action_dscp_name : action_dscp_dscp;
                a->dscp_enable = TRUE;
            }
        }
        if (has_action_pcp_dei) {
            if (has_action_pcp_dei_default) {
                a->pcp = 0;
                a->dei = 0;
                a->pcp_dei_enable = FALSE;
            } else {
                a->pcp = action_pcp;
                a->dei = action_dei;
                a->pcp_dei_enable = TRUE ;
            }
        }
        if (has_action_policy) {
            if (has_action_policy_default) {
                a->policy_no = 0;
                a->policy_no_enable = FALSE;
            } else {
                a->policy_no = action_policy;
                a->policy_no_enable = TRUE;
            }
        }
        if (has_action_ingress_map) {
            if (has_action_ingress_map_default) {
                a->map_id = 0;
                a->map_id_enable = FALSE;
            } else {
                a->map_id = action_ingress_map;
                a->map_id_enable = TRUE;
            }
        }
    }
    if (vtss_appl_qos_qce_intern_add(id_next, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: qce add/update failed\n");
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_APPL_QOS_QCL_INCLUDE)

COMMAND = no qos qce <1~2>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! no
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qce
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_QCE
BYWORD  =

! <1~2>
CMD_VAR = qce_id_range
RUNTIME = QOS_ICLI_runtime_qce_id_range
HELP    = ##HELP_QOS_QCE_ID
BYWORD  =

VARIABLE_BEGIN
    uint cnt;
    mesa_qce_id_t qce_id;
VARIABLE_END

CODE_BEGIN
    if (qce_id_range) {
        for (cnt = 0; cnt < qce_id_range->cnt; cnt++) {
            /*lint -e{574} Suppress 'Lint Warning 574: Signed-unsigned mix with relational' */
            for (qce_id = qce_id_range->range[cnt].min; qce_id <= qce_id_range->range[cnt].max; qce_id++) {
                if (vtss_appl_qos_qce_intern_del(VTSS_ISID_GLOBAL, VTSS_APPL_QOS_QCL_USER_STATIC, qce_id) != VTSS_RC_OK) {
                    ICLI_PRINTF("qce %u not found\n", qce_id);
                }
            }
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_APPL_QOS_QCL_INCLUDE)

COMMAND = qos qce refresh

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =

! 1: qos
! 2: qce
! 3: refresh

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Refresh QCE tables in hardware

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    (void)vtss_appl_qos_qce_conflict_resolve();
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos cos <0-7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: cos
! 3: <cos:0-7>

CMD_VAR =
CMD_VAR =
CMD_VAR = cos

HELP = ##HELP_QOS
HELP = Class of service configuration
HELP = Specific class of service

BYWORD =
BYWORD =
BYWORD = <Cos : 0-7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_cos = cos;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos cos

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: cos

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP = ##HELP_QOS
HELP = Class of service configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_cos = dc.port.default_cos;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos dpl <dpl>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: dpl
! 3: <dpl:dpl>

CMD_VAR =
CMD_VAR =
CMD_VAR = dpl

HELP =
HELP = Drop precedence level configuration
HELP = Specific drop precedence level

BYWORD =
BYWORD =
BYWORD = <Dpl : dpl>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_dpl = dpl;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos dpl

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: dpl

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Drop precedence level configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_dpl = dc.port.default_dpl;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos pcp <0-7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: pcp
! 3: <pcp:0-7>

CMD_VAR =
CMD_VAR =
CMD_VAR = pcp

HELP =
HELP = Priority Code Point configuration
HELP = Specific Priority Code Point

BYWORD =
BYWORD =
BYWORD = <Pcp : 0-7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_pcp = pcp;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos pcp

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: pcp

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Priority Code Point configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_pcp = dc.port.default_pcp;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos dei <0-1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: dei
! 3: <dei:0-1>

CMD_VAR =
CMD_VAR =
CMD_VAR = dei

HELP =
HELP = Drop Eligible Indicator configuration
HELP = Specific Drop Eligible Indicator

BYWORD =
BYWORD =
BYWORD = <Dei : 0-1>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_dei = dei;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos dei

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: dei

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Drop Eligible Indicator configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_dei = dc.port.default_dei;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos class <0-7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_cosid_classification
HELP    =
BYWORD  =

! class
CMD_VAR =
RUNTIME =
HELP = Class of service ID configuration
BYWORD  =

! <0-7>
CMD_VAR = cosid
RUNTIME =
HELP = Specific class of service ID
BYWORD  = <Cosid : 0-7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_cosid = cosid;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos class

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_cosid_classification
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! class
CMD_VAR =
RUNTIME =
HELP = Class of service ID configuration
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.default_cosid = dc.port.default_cosid;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos trust tag

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: trust
! 3: tag

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP = Trust configuration
HELP = VLAN tag

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
NO_FORM_VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.trust_tag = TRUE;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

NO_FORM_CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.trust_tag = dc.port.trust_tag;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos trust dscp

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: trust
! 3: dscp

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP = Trust configuration
HELP = DSCP value

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
NO_FORM_VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.trust_dscp = TRUE;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

NO_FORM_CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.trust_dscp = dc.port.trust_dscp;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map tag-cos pcp <0~7> dei <0~1> cos <0-7> dpl <dpl>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: map
! 3: tag-cos
! 4: pcp
! 5: <pcp:0~7>
! 6: dei
! 7: <dei:0~1>
! 8: cos
! 9: <cos:0-7>
! 10: dpl
! 11: <dpl:dpl>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = pcp
CMD_VAR =
CMD_VAR = dei
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl

HELP =
HELP = QoS Map/Table configuration
HELP = Map for tag to cos configuration
HELP = Specify PCP (Priority Code Point)
HELP = Specific PCP or range
HELP = Specify DEI (Drop Eligible Indicator)
HELP = Specific DEI or range
HELP = Specify class of service
HELP = Specific class of service
HELP = Specify drop precedence level
HELP = Specific drop precedence level

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Pcp : 0~7>
BYWORD =
BYWORD = <Dei : 0~1>
BYWORD =
BYWORD = <Cos : 0-7>
BYWORD =
BYWORD = <Dpl : dpl>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       pcp_cnt;
    u32                       pcp_val;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (pcp) {
                for (pcp_cnt = 0; pcp_cnt < pcp->cnt; pcp_cnt++) {
                    for (pcp_val = pcp->range[pcp_cnt].min; pcp_val <= pcp->range[pcp_cnt].max; pcp_val++) {
                        u32 dei_cnt;
                        u32 dei_val;
                        if (dei) {
                            for (dei_cnt = 0; dei_cnt < dei->cnt; dei_cnt++) {
                                for (dei_val = dei->range[dei_cnt].min; dei_val <= dei->range[dei_cnt].max; dei_val++) {
                                    c.tag_cos_map[pcp_val][dei_val].cos = cos;
                                    c.tag_cos_map[pcp_val][dei_val].dpl = dpl;
                                }
                            }
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map tag-cos pcp <0~7> dei <0~1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: map
! 4: tag-cos
! 5: pcp
! 6: <pcp:0~7>
! 7: dei
! 8: <dei:0~1>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = pcp
CMD_VAR =
CMD_VAR = dei

HELP =
HELP =
HELP = QoS Map/Table configuration
HELP = Map for tag to cos configuration
HELP = Specify PCP (Priority Code Point)
HELP = Specific PCP or range
HELP = Specify DEI (Drop Eligible Indicator)
HELP = Specific DEI or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Pcp : 0~7>
BYWORD =
BYWORD = <Dei : 0~1>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       pcp_cnt;
    u32                       pcp_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (pcp) {
                for (pcp_cnt = 0; pcp_cnt < pcp->cnt; pcp_cnt++) {
                    for (pcp_val = pcp->range[pcp_cnt].min; pcp_val <= pcp->range[pcp_cnt].max; pcp_val++) {
                        u32 dei_cnt;
                        u32 dei_val;
                        if (dei) {
                            for (dei_cnt = 0; dei_cnt < dei->cnt; dei_cnt++) {
                                for (dei_val = dei->range[dei_cnt].min; dei_val <= dei->range[dei_cnt].max; dei_val++) {
                                    c.tag_cos_map[pcp_val][dei_val] = dc.tag_cos_map[pcp_val][dei_val];
                                }
                            }
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos policer <uint> [ kbps | mbps | fps | kfps ] [ flowcontrol ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = icli_is_switchport_runtime
HELP    =
BYWORD  =

! policer
CMD_VAR =
RUNTIME =
HELP    = Policer configuration
BYWORD  =

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_port_policer_rate
HELP    = Policer rate (default kbps). Internally rounded up to the nearest value supported by the port policer.
BYWORD  = <Rate : uint>

! kbps
CMD_VAR =
RUNTIME =
HELP    = Unit is kilobits per second (default)
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME =
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

! fps
CMD_VAR = has_fps
RUNTIME =
HELP    = Unit is frames per second
BYWORD  = fps : Option

! kfps
CMD_VAR = has_kfps
RUNTIME =
HELP    = Unit is kiloframes per second
BYWORD  = kfps : Option

! flowcontrol
CMD_VAR = has_flowcontrol
RUNTIME = QOS_ICLI_runtime_flowcontrol
HELP    = Enable flow control
BYWORD  = flowcontrol : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       min;
    u32                       max;
    BOOL                      frame_rate = FALSE;
VARIABLE_END

CODE_BEGIN
    min = vtss_appl_qos_rate_min(CAPA->port_policer_bit_rate_min, CAPA->port_policer_frame_rate_min);
    max = vtss_appl_qos_rate_max(CAPA->port_policer_bit_rate_max, CAPA->port_policer_frame_rate_max);

    if (has_kfps || has_mbps) {
        rate = rate * 1000;
    }
    if (has_fps || has_kfps) {
        frame_rate = TRUE;
    }

    if (rate < min) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min, has_fps ? "fps" : "kbps");
        return ICLI_RC_ERROR;
    }
    if (rate > max) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max / 1000, has_kfps ? "kfps" : "mbps");
        return ICLI_RC_ERROR;
    }
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_policer.enable = TRUE;
            c.port_policer.cir = rate;
            c.port_policer.frame_rate = frame_rate;
            c.port_policer.flow_control = has_flowcontrol;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos policer

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: policer

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Policer configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_policer = dc.port_policer;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos queue-policer queue <0~7> <uint> [ kbps | mbps ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = icli_is_switchport_runtime
HELP    =
BYWORD  =

! queue-policer
CMD_VAR =
RUNTIME =
HELP    = Queue policer configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_queue_policer_rate
HELP    = Policer rate (default kbps). Internally rounded up to the nearest value supported by the queue policer.
BYWORD  = <Rate : uint>

! kbps
CMD_VAR =
RUNTIME =
HELP    = Unit is kilobits per second (default)
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME =
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       queue_cnt;
    u32                       queue_val;
    u32                       min;
    u32                       max;
VARIABLE_END

CODE_BEGIN
    min = vtss_appl_qos_rate_min(CAPA->queue_policer_bit_rate_min, CAPA->queue_policer_frame_rate_min);
    max = vtss_appl_qos_rate_max(CAPA->queue_policer_bit_rate_max, CAPA->queue_policer_frame_rate_max);

    if (has_mbps) {
        rate = rate * 1000;
    }

    if (rate < min) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min, "kbps");
        return ICLI_RC_ERROR;
    }
    if (rate > max) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max / 1000, "mbps");
        return ICLI_RC_ERROR;
    }
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_policer[queue_val].enable = TRUE;
                        c.queue_policer[queue_val].cir = rate;
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos queue-policer queue <0~7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: queue-policer
! 4: queue
! 5: <queue:0~7>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = queue

HELP =
HELP =
HELP = Queue policer configuration
HELP = Specify queue
HELP = Specific queue or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Queue : 0~7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_policer[queue_val] = dc.queue_policer[queue_val];
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos wrr <1-100> <1-100> <1-100> <1-100> <1-100> <1-100>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = QOS_ICLI_runtime_scheduler_not_dwrr_cnt

! 1: qos
! 2: wrr
! 3: <w0:1-100>
! 4: <w1:1-100>
! 5: <w2:1-100>
! 6: <w3:1-100>
! 7: <w4:1-100>
! 8: <w5:1-100>

CMD_VAR =
CMD_VAR =
CMD_VAR = w0
CMD_VAR = w1
CMD_VAR = w2
CMD_VAR = w3
CMD_VAR = w4
CMD_VAR = w5

HELP =
HELP = Weighted round robin configuration
HELP = Weight for queue 0
HELP = Weight for queue 1
HELP = Weight for queue 2
HELP = Weight for queue 3
HELP = Weight for queue 4
HELP = Weight for queue 5

BYWORD =
BYWORD =
BYWORD = <W0 : 1-100>
BYWORD = <W1 : 1-100>
BYWORD = <W2 : 1-100>
BYWORD = <W3 : 1-100>
BYWORD = <W4 : 1-100>
BYWORD = <W5 : 1-100>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dwrr_cnt = 6;
            c.scheduler[0].weight = w0;
            c.scheduler[1].weight = w1;
            c.scheduler[2].weight = w2;
            c.scheduler[3].weight = w3;
            c.scheduler[4].weight = w4;
            c.scheduler[5].weight = w5;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos wrr <1-100> <1-100> [ <1-100> [ <1-100> [ <1-100> [ <1-100> [ <1-100> [ <1-100> ] ] ] ] ] ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_scheduler_dwrr_cnt
HELP    =
BYWORD  =

! wrr
CMD_VAR =
RUNTIME =
HELP    = Weighted round robin configuration
BYWORD  =

! <1-100>
CMD_VAR = w0
RUNTIME =
HELP    = Weight for queue 0
BYWORD  = <W0 : 1-100>

! <1-100>
CMD_VAR = w1
RUNTIME =
HELP    = Weight for queue 1
BYWORD  = <W1 : 1-100>

! <1-100>
CMD_VAR = w2
RUNTIME =
HELP    = Weight for queue 2
BYWORD  = <W2 : 1-100>

! <1-100>
CMD_VAR = w3
RUNTIME =
HELP    = Weight for queue 3
BYWORD  = <W3 : 1-100>

! <1-100>
CMD_VAR = w4
RUNTIME =
HELP    = Weight for queue 4
BYWORD  = <W4 : 1-100>

! <1-100>
CMD_VAR = w5
RUNTIME =
HELP    = Weight for queue 5
BYWORD  = <W5 : 1-100>

! <1-100>
CMD_VAR = w6
RUNTIME =
HELP    = Weight for queue 6
BYWORD  = <W6 : 1-100>

! <1-100>
CMD_VAR = w7
RUNTIME =
HELP    = Weight for queue 7
BYWORD  = <W7 : 1-100>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dwrr_cnt = 2;
            c.scheduler[0].weight = w0;
            c.scheduler[1].weight = w1;

            if (w2) {
                c.port.dwrr_cnt++;
                c.scheduler[2].weight = w2;

                if (w3) {
                    c.port.dwrr_cnt++;
                    c.scheduler[3].weight = w3;

                    if (w4) {
                        c.port.dwrr_cnt++;
                        c.scheduler[4].weight = w4;

                        if (w5) {
                            c.port.dwrr_cnt++;
                            c.scheduler[5].weight = w5;

                            if (w6) {
                                c.port.dwrr_cnt++;
                                c.scheduler[6].weight = w6;

                                if (w7) {
                                    c.port.dwrr_cnt++;
                                    c.scheduler[7].weight = w7;
                                }
                            }
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos wrr

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: wrr

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Weighted round robin configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    int                       i;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dwrr_cnt = dc.port.dwrr_cnt;
            for (i = 0; i < VTSS_APPL_QOS_PORT_QUEUE_CNT; i++) {
                c.scheduler[i].weight = dc.scheduler[i].weight;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos shaper <uint> [ kbps | mbps ] [ rate-type { line | data } ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = icli_is_switchport_runtime
HELP    =
BYWORD  =

! shaper
CMD_VAR =
RUNTIME =
HELP    = Shaper configuration
BYWORD  =

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_port_shaper_rate
HELP    = Shaper rate (default kbps). Internally rounded up to the nearest value supported by the port shaper.
BYWORD  = <Rate : uint>

! kbps
CMD_VAR =
RUNTIME =
HELP    = Unit is kilobits per second (default)
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME =
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

! rate-type
CMD_VAR = has_rate_type
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_RATE_TYPE
BYWORD  = rate-type : Option

! line
CMD_VAR = has_line
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_LINE_RATE
BYWORD  = line : Option

! data
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_DATA_RATE
BYWORD  = data : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       min;
    u32                       max;
VARIABLE_END

CODE_BEGIN
    min = vtss_appl_qos_rate_min(CAPA->port_shaper_bit_rate_min, CAPA->port_shaper_frame_rate_min);
    max = vtss_appl_qos_rate_max(CAPA->port_shaper_bit_rate_max, CAPA->port_shaper_frame_rate_max);

    if (has_mbps) {
        rate = rate * 1000;
    }

    if (rate < min) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min, "kbps");
        return ICLI_RC_ERROR;
    }
    if (rate > max) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max / 1000, "mbps");
        return ICLI_RC_ERROR;
    }
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_shaper.enable = TRUE;
            c.port_shaper.cir = rate;
            if (has_rate_type) {
                if (has_line) {
                    c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                } else {
                    c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_DATA;
                }
            } else {
                c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos shaper

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: shaper

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Shaper configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_shaper = dc.port_shaper;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos queue-shaper queue <0~7> <uint> [ kbps | mbps | fps | kfps ] [ excess | credit] [ rate-type { line | data } ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = icli_is_switchport_runtime
HELP    =
BYWORD  =

! queue-shaper
CMD_VAR =
RUNTIME =
HELP    = Queue shaper configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_queue_shaper_rate
HELP    = Shaper rate (default kbps). Internally rounded up to the nearest value supported by the queue shaper.
BYWORD  = <Rate : uint>

! kbps
CMD_VAR = has_kbps
RUNTIME =
HELP    = Unit is kilobits per second (default)
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME =
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

! fps
CMD_VAR = has_fps
RUNTIME = QOS_ICLI_runtime_frame_based_queue_shaper
HELP    = Unit is frames per second
BYWORD  = fps : Option

! kfps
CMD_VAR = has_kfps
RUNTIME = QOS_ICLI_runtime_frame_based_queue_shaper
HELP    = Unit is kiloframes per second
BYWORD  = kfps : Option

! excess
CMD_VAR = has_excess
RUNTIME = QOS_ICLI_runtime_excess_bandwidth
HELP    = Allow use of excess bandwidth
BYWORD  = excess : Option

! credit
CMD_VAR = has_credit
RUNTIME = QOS_ICLI_runtime_credit_based_shaper
HELP    = Allow use of credit based shaper
BYWORD  = credit : Option

! rate-type
CMD_VAR = has_rate_type
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_RATE_TYPE
BYWORD  = rate-type : Option

! line
CMD_VAR = has_line
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_LINE_RATE
BYWORD  = line : Option

! data
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_DATA_RATE
BYWORD  = data : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       queue_cnt;
    u32                       queue_val;
    u32                       min_bps;
    u32                       max_bps;
    u32                       min_fps;
    u32                       max_fps;
VARIABLE_END

CODE_BEGIN
    min_bps = CAPA->queue_shaper_bit_rate_min;
    max_bps = CAPA->queue_shaper_bit_rate_max;
    min_fps = CAPA->queue_shaper_frame_rate_min;
    max_fps = CAPA->queue_shaper_frame_rate_max;

    if (has_mbps || has_kfps) {
        rate = rate * 1000;
    }

    if ((has_mbps || has_kbps) && rate < min_bps) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min_bps, "kbps");
        return ICLI_RC_ERROR;
    }
    if ((has_mbps || has_kbps) && rate > max_bps) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max_bps / 1000, "mbps");
        return ICLI_RC_ERROR;
    }
    if ((has_fps || has_kfps) && rate < min_fps) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min_fps, "fps");
        return ICLI_RC_ERROR;
    }
    if ((has_fps || has_kfps) && rate > max_fps) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max_fps / 1000, "kfps");
        return ICLI_RC_ERROR;
    }
    if ((has_fps || has_kfps) && has_rate_type) {
        ICLI_PRINTF("%% QOS: rate-type %s not consistent with frame based shaping\n", has_line ? "line" : "data");
        return ICLI_RC_ERROR;
    }
    if ((has_fps || has_kfps) && (has_excess)) {
        ICLI_PRINTF("%% QOS: excess not possible with frame based shaping\n");
        return ICLI_RC_ERROR;
    }
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_shaper[queue_val].enable = TRUE;
                        c.queue_shaper[queue_val].cir    = rate;
                        c.queue_shaper[queue_val].excess = has_excess;
                        c.queue_shaper[queue_val].credit = has_credit;
                        if (has_fps || has_kfps) {
                            c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_FRAME;
                        } else if (has_rate_type) {
                            if (has_line) {
                                c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                            } else {
                                c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_DATA;
                            }
                        } else {
                            c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos queue-shaper queue <0~7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: queue-shaper
! 4: queue
! 5: <queue:0~7>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = queue

HELP =
HELP =
HELP = Queue shaper configuration
HELP = Specify queue
HELP = Specific queue or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Queue : 0~7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_shaper[queue_val] = dc.queue_shaper[queue_val];
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos cut-through queue <0~7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_ct
HELP    =
BYWORD  =

! cut-through
CMD_VAR =
RUNTIME =
HELP    = Cut-through configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN

    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));

            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.scheduler[queue_val].cut_through = TRUE;

                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos cut-through queue <0~7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_ct
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! cut-through
CMD_VAR =
RUNTIME =
HELP    = Cut-through configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <queue:0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.scheduler[queue_val].cut_through = dc.scheduler[queue_val].cut_through;
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos tag-remark { pcp <0-7> dei <0-1> | mapped }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =

! 1: qos
! 2: tag-remark
! 3: pcp
! 4: <pcp:0-7>
! 5: dei
! 6: <dei:0-1>
! 7: mapped

CMD_VAR =
CMD_VAR =
CMD_VAR = has_pcp
CMD_VAR = pcp
CMD_VAR =
CMD_VAR = dei
CMD_VAR = has_mapped

HELP =
HELP = Tag remarking configuration
HELP = Specify default PCP
HELP = Specific PCP
HELP = Specify default DEI
HELP = Specific DEI
HELP = Used mapped values (COS, DPL -> PCP, DEI)

BYWORD =
BYWORD =
BYWORD = <Pcp : option>
BYWORD = <Pcp : 0-7>
BYWORD =
BYWORD = <Dei : 0-1>
BYWORD = <Mapped : option>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_pcp) {
                c.port.tag_remark_mode = VTSS_APPL_QOS_TAG_REMARK_MODE_DEFAULT;
                c.port.tag_default_pcp = pcp;
                c.port.tag_default_dei = dei;
            } else if (has_mapped) {
                c.port.tag_remark_mode = VTSS_APPL_QOS_TAG_REMARK_MODE_MAPPED;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos tag-remark

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: tag-remark

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = Tag remarking configuration

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.tag_remark_mode = dc.port.tag_remark_mode;
            c.port.tag_default_pcp = dc.port.tag_default_pcp;
            c.port.tag_default_dei = dc.port.tag_default_dei;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos map cos-tag cos <0~7> dpl <0~1> pcp <0-7> dei <0-1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: map
! 3: cos-tag
! 4: cos
! 5: <cos:0~7>
! 6: dpl
! 7: <dpl:0~1>
! 8: pcp
! 9: <pcp:0-7>
! 10: dei
! 11: <dei:0-1>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl
CMD_VAR =
CMD_VAR = pcp
CMD_VAR =
CMD_VAR = dei

HELP =
HELP = QoS Map/Table configuration
HELP = Map for cos to tag configuration
HELP = Specify class of service
HELP = Specific class of service or range
HELP = Specify drop precedence level
HELP = Specific drop precedence level or range
HELP = Specify PCP (Priority Code Point)
HELP = Specific PCP
HELP = Specify DEI (Drop Eligible Indicator)
HELP = Specific DEI

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Cos : 0~7>
BYWORD =
BYWORD = <Dpl : 0~1>
BYWORD =
BYWORD = <Pcp : 0-7>
BYWORD =
BYWORD = <Dei : 0-1>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       cos_cnt;
    u32                       cos_val;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (cos) {
                for (cos_cnt = 0; cos_cnt < cos->cnt; cos_cnt++) {
                    for (cos_val = cos->range[cos_cnt].min; cos_val <= cos->range[cos_cnt].max; cos_val++) {
                        u32 dpl_cnt;
                        u32 dpl_val;
                        if (dpl) {
                            for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                                for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                                    c.cos_tag_map[cos_val][dpl_val].pcp = pcp;
                                    c.cos_tag_map[cos_val][dpl_val].dei = dei;
                                }
                            }
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos map cos-tag cos <0~7> dpl <0~1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: map
! 4: cos-tag
! 5: cos
! 6: <cos:0~7>
! 7: dpl
! 8: <dpl:0~1>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = cos
CMD_VAR =
CMD_VAR = dpl

HELP =
HELP =
HELP =
HELP = Map for cos to tag configuration
HELP = Specify class of service
HELP = Specific class of service or range
HELP = Specify drop precedence level
HELP = Specific drop precedence level or range

BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD =
BYWORD = <Cos : 0~7>
BYWORD =
BYWORD = <Dpl : 0~1>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       cos_cnt;
    u32                       cos_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (cos) {
                for (cos_cnt = 0; cos_cnt < cos->cnt; cos_cnt++) {
                    for (cos_val = cos->range[cos_cnt].min; cos_val <= cos->range[cos_cnt].max; cos_val++) {
                        u32 dpl_cnt;
                        u32 dpl_val;
                        if (dpl) {
                            for (dpl_cnt = 0; dpl_cnt < dpl->cnt; dpl_cnt++) {
                                for (dpl_val = dpl->range[dpl_cnt].min; dpl_val <= dpl->range[dpl_cnt].max; dpl_val++) {
                                    c.cos_tag_map[cos_val][dpl_val] = dc.cos_tag_map[cos_val][dpl_val];
                                }
                            }
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos dscp-translate

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

NO_FORM_DOC_CMD_DESC    =
NO_FORM_DOC_CMD_DEFAULT =
NO_FORM_DOC_CMD_USAGE   =
NO_FORM_DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: dscp-translate

CMD_VAR =
CMD_VAR =

HELP =
HELP = DSCP ingress translation

BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
NO_FORM_VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dscp_translate = TRUE;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

NO_FORM_CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dscp_translate = dc.port.dscp_translate;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos dscp-classify { zero | selected | any }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime

! 1: qos
! 2: dscp-classify
! 3: zero
! 4: selected
! 5: any

CMD_VAR =
CMD_VAR =
CMD_VAR = has_zero
CMD_VAR = has_selected
CMD_VAR = has_any

HELP =
HELP = DSCP ingress classification
HELP = Classify to new DSCP if DSCP is 0
HELP = Classify to new DSCP if classify is enabled for specific DSCP value in global DSCP classify map
HELP = Classify to new DSCP always

BYWORD =
BYWORD =
BYWORD = <Zero : option>
BYWORD = <Selected : option>
BYWORD = <Any : option>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_zero) {
                c.port.dscp_imode = VTSS_APPL_QOS_DSCP_MODE_ZERO;
            } else if (has_selected) {
                c.port.dscp_imode = VTSS_APPL_QOS_DSCP_MODE_SEL;
            } else if (has_any) {
                c.port.dscp_imode = VTSS_APPL_QOS_DSCP_MODE_ALL;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos dscp-classify

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: dscp-classify

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = DSCP ingress classification

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t            sit;
    port_iter_t              pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dscp_imode = dc.port.dscp_imode;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = qos dscp-remark { rewrite | remap | remap-dp }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME = icli_is_switchport_runtime
RUNTIME =
RUNTIME =
RUNTIME = QOS_ICLI_runtime_dscp_remark_remap
RUNTIME = QOS_ICLI_runtime_dscp_remark_dp_aware

! 1: qos
! 2: dscp-remark
! 3: rewrite
! 4: remap
! 5: remap-dp

CMD_VAR =
CMD_VAR =
CMD_VAR = has_rewrite
CMD_VAR = has_remap
CMD_VAR = has_remap_dp

HELP =
HELP = DSCP egress remarking
HELP = Rewrite DSCP field with classified DSCP value (no translation)
HELP =
HELP = Rewrite DSCP field using classified DSCP and DPL remapped through global DSCP egress translation map

BYWORD =
BYWORD =
BYWORD = <Rewrite : option>
BYWORD = <Remap : option>
BYWORD = <RemapDp : option>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_rewrite) {
                c.port.dscp_emode = VTSS_APPL_QOS_DSCP_EMODE_REMARK;
            } else if (has_remap) {
                c.port.dscp_emode = VTSS_APPL_QOS_DSCP_EMODE_REMAP;
            } else if (has_remap_dp) {
                c.port.dscp_emode = VTSS_APPL_QOS_DSCP_EMODE_REMAP_DPA;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_SW_OPTION_QOS_ADV)

COMMAND = no qos dscp-remark

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = icli_is_switchport_runtime

! 1: no
! 2: qos
! 3: dscp-remark

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP =
HELP =
HELP = DSCP egress remarking

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.dscp_emode = dc.port.dscp_emode;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos storm { unicast | broadcast | unknown } <uint> [ fps | kfps | kbps | mbps ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_port_storm_pol
HELP    =
BYWORD  =

! storm
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_STORM
BYWORD  =

! unicast
CMD_VAR = has_unicast
RUNTIME =
HELP    = Police unicast frames
BYWORD  = unicast : Option

! broadcast
CMD_VAR = has_broadcast
RUNTIME =
HELP    = Police broadcast frames
BYWORD  = broadcast : Option

! unknown
CMD_VAR = has_unknown
RUNTIME =
HELP    = Police unknown (flooded) frames
BYWORD  = unknown : Option

! <uint>
CMD_VAR = rate
RUNTIME = QOS_ICLI_runtime_port_storm_rate
HELP    = Policer rate (default kbps). Internally rounded up to the nearest value supported by the storm policer.
BYWORD  = <Rate : uint>

! fps
CMD_VAR = has_fps
RUNTIME =
HELP    = Unit is frames per second
BYWORD  = fps : Option

! kfps
CMD_VAR = has_kfps
RUNTIME =
HELP    = Unit is kiloframes per second
BYWORD  = kfps : Option

! kbps
CMD_VAR =
RUNTIME =
HELP    = Unit is kilobits per second (default)
BYWORD  = kbps : Option

! mbps
CMD_VAR = has_mbps
RUNTIME =
HELP    = Unit is Megabits per second
BYWORD  = mbps : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       min;
    u32                       max;
    BOOL                      frame_rate = FALSE;
VARIABLE_END

CODE_BEGIN
    min = vtss_appl_qos_rate_min(CAPA->port_storm_bit_rate_min, CAPA->port_storm_frame_rate_min);
    max = vtss_appl_qos_rate_max(CAPA->port_storm_bit_rate_max, CAPA->port_storm_frame_rate_max);

    if (has_kfps || has_mbps) {
        rate = rate * 1000;
    }
    if (has_fps || has_kfps) {
        frame_rate = TRUE;
    }

    if (rate < min) {
        ICLI_PRINTF("%% QOS: min rate is %u when using %s\n", min, has_fps ? "fps" : "kbps");
        return ICLI_RC_ERROR;
    }
    if (rate > max) {
        ICLI_PRINTF("%% QOS: max rate is %u when using %s\n", max / 1000, has_kfps ? "kfps" : "mbps");
        return ICLI_RC_ERROR;
    }
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_unicast) {
                c.uc_policer.enable = TRUE;
                c.uc_policer.cir = rate;
                c.uc_policer.frame_rate = frame_rate;
            } else if (has_broadcast) {
                c.bc_policer.enable = TRUE;
                c.bc_policer.cir = rate;
                c.bc_policer.frame_rate = frame_rate;
            } else if (has_unknown) {
                c.un_policer.enable = TRUE;
                c.un_policer.cir = rate;
                c.un_policer.frame_rate = frame_rate;
            }

            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos storm { unicast | broadcast | unknown }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_port_storm_pol
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! storm
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_STORM
BYWORD  =

! unicast
CMD_VAR = has_unicast
RUNTIME =
HELP    = Police unicast frames
BYWORD  = unicast : Option

! broadcast
CMD_VAR = has_broadcast
RUNTIME =
HELP    = Police broadcast frames
BYWORD  = broadcast : Option

! unknown
CMD_VAR = has_unknown
RUNTIME =
HELP    = Police unknown (flooded) frames
BYWORD  = unknown : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_unicast) {
                c.uc_policer = dc.uc_policer;
            } else if (has_broadcast) {
                c.bc_policer = dc.bc_policer;
            } else if (has_unknown) {
                c.un_policer = dc.un_policer;
            }

            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos qce { [ addr { source | destination } ] [ key { double-tag | normal | ip-addr | mac-ip-addr } ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_qce_port
HELP    =
BYWORD  =

! qce
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_QCE
BYWORD  =

! addr
CMD_VAR = has_addr
RUNTIME = QOS_ICLI_runtime_dmac_dip
HELP    = Setup address match mode
BYWORD  = addr : Option

! source
CMD_VAR =
RUNTIME =
HELP    = Match SMAC and SIP (default)
BYWORD  = source : Option

! destination
CMD_VAR = has_destination
RUNTIME =
HELP    = Match DMAC and DIP
BYWORD  = destination : Option

! key
CMD_VAR = has_key
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Setup ingress lookup key type
BYWORD  = key : Option

! double-tag
CMD_VAR = has_double_tag
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Match outer tag, inner tag, IP protocol, DSCP and DPORT
BYWORD  = double_tag : Option

! normal
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Match outer tag, SMAC/DMAC, IP protocol, DSCP, SIP/DIP, SPORT and DPORT (default)
BYWORD  = normal : Option

! ip-addr
CMD_VAR = has_ip_addr
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Match outer tag, SMAC/DMAC, IP protocol, DSCP, SIP and DIP
BYWORD  = ip_addr : Option

! mac-ip-addr
CMD_VAR = has_mac_ip_addr
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Match outer tag, inner tag, SMAC, DMAC, IP protocol, DSCP, SIP, DIP, SPORT and DPORT
BYWORD  = mac_ip_addr : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_addr) {
                c.port.dmac_dip = has_destination;
            }
            if (has_key) {
                if (has_double_tag) {
                    c.port.key_type = MESA_VCAP_KEY_TYPE_DOUBLE_TAG;
                } else if (has_ip_addr) {
                    c.port.key_type = MESA_VCAP_KEY_TYPE_IP_ADDR;
                } else if (has_mac_ip_addr) {
                    c.port.key_type = MESA_VCAP_KEY_TYPE_MAC_IP_ADDR;
                } else {
                    c.port.key_type = MESA_VCAP_KEY_TYPE_NORMAL;
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos qce { [ addr ] [ key ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_qce_port
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! qce
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_QCE
BYWORD  =

! addr
CMD_VAR = has_addr
RUNTIME = QOS_ICLI_runtime_dmac_dip
HELP    = Reset address match mode to SMAC and SIP
BYWORD  = addr : Option

! key
CMD_VAR = has_key
RUNTIME = QOS_ICLI_runtime_key_type
HELP    = Reset ingress lookup key type to normal
BYWORD  = key : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (has_addr) {
                c.port.dmac_dip = dc.port.dmac_dip;
            }
            if (has_key) {
                c.port.key_type = dc.port.key_type;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos wred-group <1-3>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    =
BYWORD  =

! wred-group
CMD_VAR =
RUNTIME =
HELP    = WRED group configuration
BYWORD  =

! <1-3>
CMD_VAR = wred_group
RUNTIME =
HELP    = Specific WRED group
BYWORD  = <WredGroup : 1-3>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.wred_group = wred_group;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos wred-group

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_wred_grp
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! wred-group
CMD_VAR =
RUNTIME =
HELP    = WRED group configuration
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.wred_group = dc.port.wred_group;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug qos shaper cir { <100-3300000> [ cbs <4096-258048> ] } { [ eir <100-3300000> [ ebs <4096-258048> ] ] } { [ rate-type { line | data } ] }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! debug
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_shapers_dlb
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS
BYWORD  =

! shaper
CMD_VAR =
RUNTIME =
HELP    = Shaper configuration
BYWORD  =

! cir
CMD_VAR =
RUNTIME =
HELP    = Committed Information Rate
BYWORD  =

! <100-3300000>
CMD_VAR = cir
RUNTIME =
HELP    = Rate in kbps
BYWORD  = <Cir : 100-3300000>

! cbs
CMD_VAR = has_cbs
RUNTIME =
HELP    = Committed Burst Size (Default 4096 bytes)
BYWORD  = cbs : Option

! <4096-258048>
CMD_VAR = cbs
RUNTIME =
HELP    = Burst size in bytes
BYWORD  = <Cbs : 4096-258048>

! eir
CMD_VAR = has_eir
RUNTIME =
HELP    = Excess Information Rate
BYWORD  = eir : Option

! <100-3300000>
CMD_VAR = eir
RUNTIME =
HELP    = Rate in kbps
BYWORD  = <Eir : 100-3300000>

! ebs
CMD_VAR = has_ebs
RUNTIME =
HELP    = Excess Burst Size (Default 4096 bytes)
BYWORD  = ebs : Option

! <4096-258048>
CMD_VAR = ebs
RUNTIME =
HELP    = Burst size in bytes
BYWORD  = <Ebs : 4096-258048>

! rate-type
CMD_VAR = has_rate_type
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_RATE_TYPE
BYWORD  = rate-type : Option

! line
CMD_VAR = has_line
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_LINE_RATE
BYWORD  = line : Option

! data
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_DATA_RATE
BYWORD  = data : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_shaper.enable = TRUE;
            c.port_shaper.cir = cir;
            c.port_shaper.cbs = has_cbs ? cbs : VTSS_APPL_QOS_BURSTSIZE_DEF;
            if (has_eir) {
                c.port_shaper.dlb = TRUE;
                c.port_shaper.eir = eir;
                c.port_shaper.ebs = has_ebs ? ebs : VTSS_APPL_QOS_BURSTSIZE_DEF;
            } else {
                c.port_shaper.dlb = FALSE;
            }
            if (has_rate_type) {
                if (has_line) {
                    c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                } else {
                    c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_DATA;
                }
            } else {
                c.port_shaper.mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug no qos shaper

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! debug
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_shapers_dlb
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! no
CMD_VAR =
RUNTIME =
HELP    = ##ICLI_HELP_NO
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS
BYWORD  =

! shaper
CMD_VAR =
RUNTIME =
HELP    = Shaper configuration
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port_shaper = dc.port_shaper;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug qos queue-shaper queue <0~7> { cir <100-3300000> [ cbs <4096-258048> ] } { [ eir <100-3300000> [ ebs <4096-258048> ] ] } [ excess | credit] [ rate-type { line | data } ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! debug
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_shapers_dlb
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! queue-shaper
CMD_VAR =
RUNTIME =
HELP    = Queue shaper configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

! cir
CMD_VAR =
RUNTIME =
HELP    = Committed Information Rate
BYWORD  =

! <100-3300000>
CMD_VAR = cir
RUNTIME =
HELP    = Rate in kbps
BYWORD  = <Cir : 100-3300000>

! cbs
CMD_VAR = has_cbs
RUNTIME =
HELP    = Committed Burst Size
BYWORD  = cbs : Option

! <4096-258048>
CMD_VAR = cbs
RUNTIME =
HELP    = Burst size in bytes (Default 4096 bytes)
BYWORD  = <Cbs : 4096-258048>

! eir
CMD_VAR = has_eir
RUNTIME =
HELP    = Excess Information Rate
BYWORD  = eir : Option

! <100-3300000>
CMD_VAR = eir
RUNTIME =
HELP    = Rate in kbps
BYWORD  = <Eir : 100-3300000>

! ebs
CMD_VAR = has_ebs
RUNTIME =
HELP    = Excess Burst Size (Default 4096 bytes)
BYWORD  = ebs : Option

! <4096-258048>
CMD_VAR = ebs
RUNTIME =
HELP    = Burst size in bytes
BYWORD  = <Ebs : 4096-258048>

! excess
CMD_VAR = has_excess
RUNTIME = QOS_ICLI_runtime_excess_bandwidth
HELP    = Allow use of excess bandwidth
BYWORD  = excess : Option

! credit
CMD_VAR = has_credit
RUNTIME = QOS_ICLI_runtime_credit_based_shaper
HELP    = Allow use of credit based shaper
BYWORD  = credit : Option

! rate-type
CMD_VAR = has_rate_type
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_RATE_TYPE
BYWORD  = rate-type : Option

! line
CMD_VAR = has_line
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_LINE_RATE
BYWORD  = line : Option

! data
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_shaper_rate_type
HELP    = ##HELP_QOS_HAS_SHAPER_DATA_RATE
BYWORD  = data : Option

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_shaper[queue_val].enable = TRUE;
                        c.queue_shaper[queue_val].excess = has_excess;
                        c.queue_shaper[queue_val].credit = has_credit;
                        c.queue_shaper[queue_val].cir = cir;
                        c.queue_shaper[queue_val].cbs = has_cbs ? cbs : VTSS_APPL_QOS_BURSTSIZE_DEF;
                        if (has_eir) {
                            c.queue_shaper[queue_val].dlb = TRUE;
                            c.queue_shaper[queue_val].eir = eir;
                            c.queue_shaper[queue_val].ebs = has_ebs ? ebs : VTSS_APPL_QOS_BURSTSIZE_DEF;
                        } else {
                            c.queue_shaper[queue_val].dlb = FALSE;
                        }
                        if (has_rate_type) {
                            if (has_line) {
                                c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                            } else {
                                c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_DATA;
                            }
                        } else {
                            c.queue_shaper[queue_val].mode = VTSS_APPL_QOS_SHAPER_MODE_LINE;
                        }
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug no qos queue-shaper queue <0~7>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! debug
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_shapers_dlb
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! no
CMD_VAR =
RUNTIME =
HELP    = ##ICLI_HELP_NO
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! queue-shaper
CMD_VAR =
RUNTIME =
HELP    = Queue shaper configuration
BYWORD  =

! queue
CMD_VAR =
RUNTIME =
HELP    = Specify queue
BYWORD  =

! <0~7>
CMD_VAR = queue
RUNTIME =
HELP    = Specific queue or range
BYWORD  = <Queue : 0~7>

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
    vtss_appl_qos_port_conf_t dc;
    u32                       queue_cnt;
    u32                       queue_val;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            if (queue) {
                for (queue_cnt = 0; queue_cnt < queue->cnt; queue_cnt++) {
                    for (queue_val = queue->range[queue_cnt].min; queue_val <= queue->range[queue_cnt].max; queue_val++) {
                        c.queue_shaper[queue_val] = dc.queue_shaper[queue_val];
                    }
                }
            }
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug show qos shapers

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

! debug
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_shapers_dlb
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! show
CMD_VAR =
RUNTIME =
HELP    = Show running system information
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS
BYWORD  =

! shapers
CMD_VAR =
RUNTIME =
HELP    = Shaper configuration
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    char                      buf[128];
    vtss_appl_qos_port_conf_t c;
    int                       i;
VARIABLE_END

CODE_BEGIN

    (void)icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, NULL)) {
        (void)icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, NULL)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            ICLI_PRINTF("interface %s\n", icli_port_info_txt(sit.usid, pit.uport, buf));
            ICLI_PRINTF(" qos shaper: %s, cir: %u, cbs: %u", icli_bool_txt(c.port_shaper.enable), c.port_shaper.cir, c.port_shaper.cbs);
            if (c.port_shaper.dlb) {
                ICLI_PRINTF(", eir: %u, ebs: %u", c.port_shaper.eir, c.port_shaper.ebs);
            }
            ICLI_PRINTF("\n");

            for (i = 0; i < VTSS_APPL_QOS_PORT_QUEUE_CNT; i++) {
                ICLI_PRINTF(" qos queue-shaper queue %d: %s, cir: %u, cbs: %u", i, icli_bool_txt(c.queue_shaper[i].enable), c.queue_shaper[i].cir, c.queue_shaper[i].cbs);
                if (c.queue_shaper[i].dlb) {
                    ICLI_PRINTF(", eir: %u, ebs: %u", c.queue_shaper[i].eir, c.queue_shaper[i].ebs);
                }
                if (CAPA->has_queue_shapers_eb) {
                    ICLI_PRINTF(", excess: %s", icli_bool_txt(c.queue_shaper[i].excess));
                }
                if (CAPA->has_queue_shapers_crb) {
                    ICLI_PRINTF(", credit: %s", icli_bool_txt(c.queue_shaper[i].credit));
                }
                ICLI_PRINTF("\n");
            }
        }
    }
    ICLI_PRINTF("\n");

CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug qos registrations [ clear ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

! debug
CMD_VAR =
RUNTIME =
HELP    = ##ICLI_HELP_DEBUG
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS
BYWORD  =

! registrations
CMD_VAR =
RUNTIME =
HELP    = Show or clear QoS module registrations
BYWORD  =

! clear
CMD_VAR = has_clear
RUNTIME =
HELP    = Clear max callback time
BYWORD  = clear : Option

VARIABLE_BEGIN
    qos_port_conf_change_reg_t reg;
    BOOL                       first = TRUE;
VARIABLE_END

CODE_BEGIN
    reg.module_id = VTSS_MODULE_ID_NONE;
    while (qos_port_conf_change_reg_get(&reg, has_clear) == VTSS_RC_OK) {
        if (first) {
            first = FALSE;
            icli_header(session_id, "QoS Port Conficuration Change Registrations", 1);
            icli_table_header(session_id, "Type    Module           Max Callback [msec]");
        }
        ICLI_PRINTF("%-6s  %-15.15s  " VPRI64u"\n", reg.global ? "Global" : "Local", vtss_module_names[reg.module_id], VTSS_OS_TICK2MSEC(reg.max_ticks));
    }
    if (!has_clear && first) {
        ICLI_PRINTF("No registrations found!\n");
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos map ingress <0~1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! map
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! ingress
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_MAP_INGRESS
BYWORD  =

! <0~1>
CMD_VAR = id
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  =

VARIABLE_BEGIN
    u32  id_cnt;
    u32  id_val;
    int  count;
VARIABLE_END

CODE_BEGIN
    if (id) {
        for (id_cnt = 0; id_cnt < id->cnt; id_cnt++) {
            count = 0;
            for (id_val = id->range[id_cnt].min; id_val <= id->range[id_cnt].max; id_val++) {
                if (vtss_appl_qos_ingress_map_conf_del(id_val) == VTSS_RC_OK) {
                    count++;
                }
            }
            if (!count) {
                if (id->range[id_cnt].min == id->range[id_cnt].max) {
                    ICLI_PRINTF("%% QOS: ingress map %u not found\n", id->range[id_cnt].min);
                } else {
                    ICLI_PRINTF("%% QOS: no ingress maps found in range %u to %u\n", id->range[id_cnt].min, id->range[id_cnt].max);
                }
            }
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = preset classes <1-8> [ color-aware ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_INGRESS_MAP
MODE_VAR = id

! preset
CMD_VAR =
RUNTIME =
HELP    = Preset the map to a specific number of traffic classes
BYWORD  =

! classes
CMD_VAR =
RUNTIME =
HELP    = Number of traffic classes
BYWORD  =

! <1-8>
CMD_VAR = classes
RUNTIME =
HELP    = Number of traffic classes
BYWORD  = <Classes : 1-8>

! color-aware
CMD_VAR = has_color_aware
RUNTIME =
HELP    = Set to color aware. Default is color unaware
BYWORD  = color-aware : Option

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    return vtss_appl_qos_ingress_map_preset(id, classes, has_color_aware);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = key { pcp | pcp-dei | dscp | dscp-pcp-dei }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_INGRESS_MAP
MODE_VAR = id

! key
CMD_VAR =
RUNTIME =
HELP    = Key configuration
BYWORD  =

! pcp
CMD_VAR = has_pcp
RUNTIME =
HELP    = Use classified PCP value as key (default).
BYWORD  = pcp : Option

! pcp-dei
CMD_VAR = has_pcp_dei
RUNTIME =
HELP    = Use classified PCP and DEI values as key.
BYWORD  = pcp-dei : Option

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Use the frame's DSCP value as key. For non-IP frames, no mapping is done.
BYWORD  = dscp : Option

! dscp-pcp-dei
CMD_VAR = has_dscp_pcp_dei
RUNTIME =
HELP    = Use the frame's DSCP value as key. For non-IP frames, use classified PCP and DEI values as key.
BYWORD  = dscp-pcp-dei : Option

VARIABLE_BEGIN
    vtss_appl_qos_ingress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_ingress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    if (has_pcp) {
        conf.key = VTSS_APPL_QOS_INGRESS_MAP_KEY_PCP;
    } else if (has_pcp_dei) {
        conf.key = VTSS_APPL_QOS_INGRESS_MAP_KEY_PCP_DEI;
    } else if (has_dscp) {
        conf.key = VTSS_APPL_QOS_INGRESS_MAP_KEY_DSCP;
    } else if (has_dscp_pcp_dei) {
        conf.key = VTSS_APPL_QOS_INGRESS_MAP_KEY_DSCP_PCP_DEI;
    }

    if (vtss_appl_qos_ingress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to assign key\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = action { [ class ] [ cos ] [ dpl ] [ pcp ] [ dei ] [ dscp ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_INGRESS_MAP
MODE_VAR = id

! action
CMD_VAR =
RUNTIME =
HELP    = Enable classification actions
BYWORD  =

! class
CMD_VAR = has_cosid
RUNTIME =
HELP    = Enable classification of COSID
BYWORD  = cosid : Option

! cos
CMD_VAR = has_cos
RUNTIME =
HELP    = Enable classification of COS
BYWORD  = cos : Option

! dpl
CMD_VAR = has_dpl
RUNTIME =
HELP    = Enable classification of DPL
BYWORD  = dpl : Option

! pcp
CMD_VAR = has_pcp
RUNTIME =
HELP    = Enable classification of PCP
BYWORD  = pcp : Option

! dei
CMD_VAR = has_dei
RUNTIME =
HELP    = Enable classification of DEI
BYWORD  = dei : Option

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Enable classification of DSCP
BYWORD  = dscp : Option

VARIABLE_BEGIN
    vtss_appl_qos_ingress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_ingress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    memset(&conf.action, 0, sizeof(conf.action));

    if (has_cosid) {
        conf.action.cosid = TRUE;
    }
    if (has_cos) {
        conf.action.cos = TRUE;
    }
    if (has_dpl) {
        conf.action.dpl = TRUE;
    }
    if (has_pcp) {
        conf.action.pcp = TRUE;
    }
    if (has_dei) {
        conf.action.dei = TRUE;
    }
    if (has_dscp) {
        conf.action.dscp = TRUE;
    }

    if (vtss_appl_qos_ingress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to assign actions\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no action

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_QOS_INGRESS_MAP
MODE_VAR = id

! no
CMD_VAR =
RUNTIME =
HELP    = Negate a command or set its defaults
BYWORD  =

! action
CMD_VAR =
RUNTIME =
HELP    = Disable all actions
BYWORD  =

VARIABLE_BEGIN
    vtss_appl_qos_ingress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_ingress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    memset(&conf.action, 0, sizeof(conf.action));

    if (vtss_appl_qos_ingress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to disable actions\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = map { { dscp { <0~63> | <dscp> } } | { pcp <0~7> [ dei <0~1> ] } } to\
              { [ class <0-7> ] [ cos <0-7> ] [ dpl <0-3> ] [ pcp <0-7> ] [ dei <0-1> ] [ dscp <0-63> ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_INGRESS_MAP
MODE_VAR = id

! map
CMD_VAR =
RUNTIME =
HELP    = Configure the mapping between keys and values
BYWORD  =

! dscp
CMD_VAR = key_dscp
RUNTIME =
HELP    = Configure DSCP mapping
BYWORD  = dscp : Option

! <0~63>
CMD_VAR = dscp_num
RUNTIME =
HELP    = Specific DSCP or range
BYWORD  = <DscpNum : 0~63>

! <dscp>
CMD_VAR = dscp_name
RUNTIME =
HELP    =
BYWORD  = <DscpName : dscp>

! pcp
CMD_VAR = key_pcp
RUNTIME =
HELP    = Configure PCP mapping
BYWORD  = pcp : Option

! <0~7>
CMD_VAR = pcp_num
RUNTIME =
HELP    = Specific PCP or range
BYWORD  = <PcpNum : 0~7>

! dei
CMD_VAR = key_dei
RUNTIME =
HELP    = Configure DEI mapping. If left out, only mapping for DEI 0 is configured.
BYWORD  = dei : Option

! <0~1>
CMD_VAR = dei_num
RUNTIME =
HELP    = Specific DEI or range
BYWORD  = <DeiNum : 0~1>

! to
CMD_VAR =
RUNTIME =
HELP    = Specify the classified values that will be assigned when the key is matched and the action is enabled.
BYWORD  =

! class
CMD_VAR = has_cosid
RUNTIME =
HELP    = Setup COSID value
BYWORD  = cosid : Option

! <0-7>
CMD_VAR = cosid
RUNTIME =
HELP    = Assign COSID value
BYWORD  = <Cosid : 0-7>

! cos
CMD_VAR = has_cos
RUNTIME =
HELP    = Setup COS value
BYWORD  = cos : Option

! <0-7>
CMD_VAR = cos
RUNTIME =
HELP    = Assign COS value
BYWORD  = <Cos : 0-7>

! dpl
CMD_VAR = has_dpl
RUNTIME =
HELP    = Setup DPL value
BYWORD  = dpl : Option

! <0-3>
CMD_VAR = dpl
RUNTIME =
HELP    = Assign DPL value
BYWORD  = <Dpl : 0-3>

! pcp
CMD_VAR = has_pcp
RUNTIME =
HELP    = Setup PCP value
BYWORD  = pcp : Option

! <0-7>
CMD_VAR = pcp
RUNTIME =
HELP    = Assign PCP value
BYWORD  = <Pcp : 0-7>

! dei
CMD_VAR = has_dei
RUNTIME =
HELP    = Setup DEI value
BYWORD  = dei : Option

! <0-1>
CMD_VAR = dei
RUNTIME =
HELP    = Assign DEI value
BYWORD  = <Dei : 0-1>

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Setup DSCP value
BYWORD  = dscp : Option

! <0-63>
CMD_VAR = dscp
RUNTIME =
HELP    = Assign DSCP value
BYWORD  = <Dscp : 0-63>

VARIABLE_BEGIN
    vtss_appl_qos_ingress_map_values_t conf;
VARIABLE_END

CODE_BEGIN
    if (key_dscp) {
        if (dscp_num) { /* dscp_num may contain multiple DSCP values */
            u32 dscp_cnt, dscp_val;
            for (dscp_cnt = 0; dscp_cnt < dscp_num->cnt; dscp_cnt++) {
                for (dscp_val = dscp_num->range[dscp_cnt].min; dscp_val <= dscp_num->range[dscp_cnt].max; dscp_val++) {
                    if (vtss_appl_qos_ingress_map_dscp_conf_get(id, dscp_val, &conf) != VTSS_RC_OK) {
                        ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
                        return ICLI_RC_ERROR;
                    }
                    if (has_cosid) {
                        conf.cosid = cosid;
                    }
                    if (has_cos) {
                        conf.cos = cos;
                    }
                    if (has_dpl) {
                        conf.dpl = dpl;
                    }
                    if (has_pcp) {
                        conf.pcp = pcp;
                    }
                    if (has_dei) {
                        conf.dei = dei;
                    }
                    if (has_dscp) {
                        conf.dscp= dscp;
                    }
                    if (vtss_appl_qos_ingress_map_dscp_conf_set(id, dscp_val, &conf) != VTSS_RC_OK) {
                        ICLI_PRINTF("%% QOS: unable to assign mappings\n");
                        return ICLI_RC_ERROR;
                    }
                }
            }
        } else if (dscp_name != 0xff) { /* dscp_name contains a single DSCP value */
            if (vtss_appl_qos_ingress_map_dscp_conf_get(id, dscp_name, &conf) != VTSS_RC_OK) {
                ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
                return ICLI_RC_ERROR;
            }
            if (has_cosid) {
                conf.cosid = cosid;
            }
            if (has_cos) {
                conf.cos = cos;
            }
            if (has_dpl) {
                conf.dpl = dpl;
            }
            if (has_pcp) {
                conf.pcp = pcp;
            }
            if (has_dei) {
                conf.dei = dei;
            }
            if (has_dscp) {
                conf.dscp= dscp;
            }
            if (vtss_appl_qos_ingress_map_dscp_conf_set(id, dscp_name, &conf) != VTSS_RC_OK) {
                ICLI_PRINTF("%% QOS: unable to assign mappings\n");
                return ICLI_RC_ERROR;
            }
        } else {
            ICLI_PRINTF("%% QOS: unable to parse dscp\n");
            return ICLI_RC_ERROR;
        }
    } else if (key_pcp) {
        if (pcp_num) { /* pcp_num may contain multiple PCP values */
            u32 pcp_cnt, pcp_val;
            for (pcp_cnt = 0; pcp_cnt < pcp_num->cnt; pcp_cnt++) {
                for (pcp_val = pcp_num->range[pcp_cnt].min; pcp_val <= pcp_num->range[pcp_cnt].max; pcp_val++) {
                    if (key_dei && dei_num) { /* dei_num may contain multiple PCP values */
                        u32 dei_cnt, dei_val;
                        for (dei_cnt = 0; dei_cnt < dei_num->cnt; dei_cnt++) {
                            for (dei_val = dei_num->range[dei_cnt].min; dei_val <= dei_num->range[dei_cnt].max; dei_val++) {
                                if (vtss_appl_qos_ingress_map_pcp_dei_conf_get(id, pcp_val, dei_val, &conf) != VTSS_RC_OK) {
                                    ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
                                    return ICLI_RC_ERROR;
                                }
                                if (has_cosid) {
                                    conf.cosid = cosid;
                                }
                                if (has_cos) {
                                    conf.cos = cos;
                                }
                                if (has_dpl) {
                                    conf.dpl = dpl;
                                }
                                if (has_pcp) {
                                    conf.pcp = pcp;
                                }
                                if (has_dei) {
                                    conf.dei = dei;
                                }
                                if (has_dscp) {
                                    conf.dscp= dscp;
                                }
                                if (vtss_appl_qos_ingress_map_pcp_dei_conf_set(id, pcp_val, dei_val, &conf) != VTSS_RC_OK) {
                                    ICLI_PRINTF("%% QOS: unable to assign mappings\n");
                                    return ICLI_RC_ERROR;
                                }
                            }
                        }
                    } else { /* dei not specified -> use dei = 0 */
                        if (vtss_appl_qos_ingress_map_pcp_dei_conf_get(id, pcp_val, 0, &conf) != VTSS_RC_OK) {
                            ICLI_PRINTF("%% QOS: ingress map %u not found\n", id);
                            return ICLI_RC_ERROR;
                        }
                        if (has_cosid) {
                            conf.cosid = cosid;
                        }
                        if (has_cos) {
                            conf.cos = cos;
                        }
                        if (has_dpl) {
                            conf.dpl = dpl;
                        }
                        if (has_pcp) {
                            conf.pcp = pcp;
                        }
                        if (has_dei) {
                            conf.dei = dei;
                        }
                        if (has_dscp) {
                            conf.dscp= dscp;
                        }
                        if (vtss_appl_qos_ingress_map_pcp_dei_conf_set(id, pcp_val, 0, &conf) != VTSS_RC_OK) {
                            ICLI_PRINTF("%% QOS: unable to assign mappings\n");
                            return ICLI_RC_ERROR;
                        }
                    }
                }
            }
        } else {
            ICLI_PRINTF("%% QOS: unable to parse pcp\n");
            return ICLI_RC_ERROR;
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos ingress-map <0-1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    =
BYWORD  =

! ingress-map
CMD_VAR =
RUNTIME =
HELP    = Ingress map association
BYWORD  =

! <0-1>
CMD_VAR = id
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.ingress_map = id;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos ingress-map

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_ingress_map
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! ingress-map
CMD_VAR =
RUNTIME =
HELP    = Ingress map association
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.ingress_map = dc.port.ingress_map;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos map egress <0~1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! map
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! egress
CMD_VAR =
RUNTIME =
HELP    = ##HELP_QOS_MAP_EGRESS
BYWORD  =

! <0~1>
CMD_VAR = id
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  =

VARIABLE_BEGIN
    u32  id_cnt;
    u32  id_val;
    int  count;
VARIABLE_END

CODE_BEGIN
    if (id) {
        for (id_cnt = 0; id_cnt < id->cnt; id_cnt++) {
            count = 0;
            for (id_val = id->range[id_cnt].min; id_val <= id->range[id_cnt].max; id_val++) {
                if (vtss_appl_qos_egress_map_conf_del(id_val) == VTSS_RC_OK) {
                    count++;
                }
            }
            if (!count) {
                if (id->range[id_cnt].min == id->range[id_cnt].max) {
                    ICLI_PRINTF("%% QOS: egress map %u not found\n", id->range[id_cnt].min);
                } else {
                    ICLI_PRINTF("%% QOS: no egress maps found in range %u to %u\n", id->range[id_cnt].min, id->range[id_cnt].max);
                }
            }
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = preset classes <1-8> [ color-aware ]

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_EGRESS_MAP
MODE_VAR = id

! preset
CMD_VAR =
RUNTIME =
HELP    = Preset the map to a specific number of traffic classes
BYWORD  =

! classes
CMD_VAR =
RUNTIME =
HELP    = Number of traffic classes
BYWORD  =

! <1-8>
CMD_VAR = classes
RUNTIME =
HELP    = Number of traffic classes
BYWORD  = <Classes : 1-8>

! color-aware
CMD_VAR = has_color_aware
RUNTIME =
HELP    = Set to color aware. Default is color unaware
BYWORD  = color-aware : Option

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    return vtss_appl_qos_egress_map_preset(id, classes, has_color_aware);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = key { class | class-dpl | dscp | dscp-dpl }

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_EGRESS_MAP
MODE_VAR = id

! key
CMD_VAR =
RUNTIME =
HELP    = Key configuration
BYWORD  =

! class
CMD_VAR = has_class
RUNTIME =
HELP    = Use classified COSID value as key (default).
BYWORD  = class : Option

! class-dpl
CMD_VAR = has_class_dpl
RUNTIME =
HELP    = Use classified COSID and DPL value as key.
BYWORD  = class-dpl : Option

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Use classified DSCP value as key.
BYWORD  = dscp : Option

! dscp-dpl
CMD_VAR = has_dscp_dpl
RUNTIME =
HELP    = Use classified DSCP and DPL values as key.
BYWORD  = dscp-dpl : Option

VARIABLE_BEGIN
    vtss_appl_qos_egress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_egress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    if (has_class) {
        conf.key = VTSS_APPL_QOS_EGRESS_MAP_KEY_COSID;
    } else if (has_class_dpl) {
        conf.key = VTSS_APPL_QOS_EGRESS_MAP_KEY_COSID_DPL;
    } else if (has_dscp) {
        conf.key = VTSS_APPL_QOS_EGRESS_MAP_KEY_DSCP;
    } else if (has_dscp_dpl) {
        conf.key = VTSS_APPL_QOS_EGRESS_MAP_KEY_DSCP_DPL;
    }

    if (vtss_appl_qos_egress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to assign key\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = action { [ pcp ] [ dei ] [ dscp ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_EGRESS_MAP
MODE_VAR = id

! action
CMD_VAR =
RUNTIME =
HELP    = Enable rewriting actions
BYWORD  =

! pcp
CMD_VAR = has_pcp
RUNTIME =
HELP    = Enable rewriting of PCP
BYWORD  = pcp : Option

! dei
CMD_VAR = has_dei
RUNTIME =
HELP    = Enable rewriting of DEI
BYWORD  = dei : Option

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Enable rewriting of DSCP
BYWORD  = dscp : Option

VARIABLE_BEGIN
    vtss_appl_qos_egress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_egress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    memset(&conf.action, 0, sizeof(conf.action));

    if (has_pcp) {
        conf.action.pcp = TRUE;
    }
    if (has_dei) {
        conf.action.dei = TRUE;
    }
    if (has_dscp) {
        conf.action.dscp = TRUE;
    }

    if (vtss_appl_qos_egress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to assign actions\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no action

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_QOS_EGRESS_MAP
MODE_VAR = id

! no
CMD_VAR =
RUNTIME =
HELP    = Negate a command or set its defaults
BYWORD  =

! action
CMD_VAR =
RUNTIME =
HELP    = Disable all actions
BYWORD  =

VARIABLE_BEGIN
    vtss_appl_qos_egress_map_conf_t conf;
VARIABLE_END

CODE_BEGIN
    if (vtss_appl_qos_egress_map_conf_get(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);
        return ICLI_RC_ERROR;
    }

    memset(&conf.action, 0, sizeof(conf.action));

    if (vtss_appl_qos_egress_map_conf_set(id, &conf) != VTSS_RC_OK) {
        ICLI_PRINTF("%% QOS: unable to disable actions\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = map { { { dscp { <0~63> | <dscp> } } | { class <0~7> } } [ dpl <0~3> ] } to { [ pcp <0-7> ] [ dei <0-1> ] [ dscp <0-63> ] }*1

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_QOS_EGRESS_MAP
MODE_VAR = id

! map
CMD_VAR =
RUNTIME =
HELP    = Configure the mapping between keys and values
BYWORD  =

! dscp
CMD_VAR = key_dscp
RUNTIME =
HELP    = Configure DSCP mapping
BYWORD  = dscp : Option

! <0~63>
CMD_VAR = dscp_num
RUNTIME =
HELP    = Specific DSCP or range
BYWORD  = <DscpNum : 0~63>

! <dscp>
CMD_VAR = dscp_name
RUNTIME =
HELP    =
BYWORD  = <DscpName : dscp>

! class
CMD_VAR = key_cosid
RUNTIME =
HELP    = Configure COSID mapping
BYWORD  = class : Option

! <0~7>
CMD_VAR = cosid_num
RUNTIME =
HELP    = Specific COSID or range
BYWORD  = <ClassNum : 0~7>

! dpl
CMD_VAR = key_dpl
RUNTIME =
HELP    = Configure DPL mapping. If left out, only mapping for DPL 0 is configured.
BYWORD  = dei : Option

! <0~3>
CMD_VAR = dpl_num
RUNTIME =
HELP    = Specific DPL or range
BYWORD  = <DplNum : 0~3>

! to
CMD_VAR =
RUNTIME =
HELP    = Specify the values that will be written to the frame when the key is matched and the action is enabled.
BYWORD  =

! pcp
CMD_VAR = has_pcp
RUNTIME =
HELP    = Setup PCP value
BYWORD  = pcp : Option

! <0-7>
CMD_VAR = pcp
RUNTIME =
HELP    = Assign PCP value
BYWORD  = <Pcp : 0-7>

! dei
CMD_VAR = has_dei
RUNTIME =
HELP    = Setup DEI value
BYWORD  = dei : Option

! <0-1>
CMD_VAR = dei
RUNTIME =
HELP    = Assign DEI value
BYWORD  = <Dei : 0-1>

! dscp
CMD_VAR = has_dscp
RUNTIME =
HELP    = Setup DSCP value
BYWORD  = dscp : Option

! <0-63>
CMD_VAR = dscp
RUNTIME =
HELP    = Assign DSCP value
BYWORD  = <Dscp : 0-63>

VARIABLE_BEGIN
    vtss_appl_qos_egress_map_values_t conf;
VARIABLE_END

CODE_BEGIN
// A few helper macros:
#define QOS_EGRESS_DSCP_DPL_CONF(dscp_val, dpl_val) do {                                          \
    if (vtss_appl_qos_egress_map_dscp_dpl_conf_get(id, dscp_val, dpl_val, &conf) != VTSS_RC_OK) { \
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);                                     \
        return ICLI_RC_ERROR;                                                                     \
    }                                                                                             \
    if (has_pcp) {                                                                                \
        conf.pcp = pcp;                                                                           \
    }                                                                                             \
    if (has_dei) {                                                                                \
        conf.dei = dei;                                                                           \
    }                                                                                             \
    if (has_dscp) {                                                                               \
        conf.dscp = dscp;                                                                         \
    }                                                                                             \
    if (vtss_appl_qos_egress_map_dscp_dpl_conf_set(id, dscp_val, dpl_val, &conf) != VTSS_RC_OK) { \
        ICLI_PRINTF("%% QOS: unable to assign mappings\n");                                       \
        return ICLI_RC_ERROR;                                                                     \
    }                                                                                             \
} while (0)

#define QOS_EGRESS_COSID_DPL_CONF(cosid_val, dpl_val) do {                                          \
    if (vtss_appl_qos_egress_map_cosid_dpl_conf_get(id, cosid_val, dpl_val, &conf) != VTSS_RC_OK) { \
        ICLI_PRINTF("%% QOS: egress map %u not found\n", id);                                       \
        return ICLI_RC_ERROR;                                                                       \
    }                                                                                               \
    if (has_pcp) {                                                                                  \
        conf.pcp = pcp;                                                                             \
    }                                                                                               \
    if (has_dei) {                                                                                  \
        conf.dei = dei;                                                                             \
    }                                                                                               \
    if (has_dscp) {                                                                                 \
        conf.dscp = dscp;                                                                           \
    }                                                                                               \
    if (vtss_appl_qos_egress_map_cosid_dpl_conf_set(id, cosid_val, dpl_val, &conf) != VTSS_RC_OK) { \
        ICLI_PRINTF("%% QOS: unable to assign mappings\n");                                         \
        return ICLI_RC_ERROR;                                                                       \
    }                                                                                               \
} while (0)

    if (key_dscp) {
        if (dscp_num) { /* dscp_num may contain multiple DSCP values */
            u32 dscp_cnt, dscp_val;
            for (dscp_cnt = 0; dscp_cnt < dscp_num->cnt; dscp_cnt++) {
                for (dscp_val = dscp_num->range[dscp_cnt].min; dscp_val <= dscp_num->range[dscp_cnt].max; dscp_val++) {
                    if (key_dpl && dpl_num) { /* dpl_num may contain multiple dpl values */
                        u32 dpl_cnt, dpl_val;
                        for (dpl_cnt = 0; dpl_cnt < dpl_num->cnt; dpl_cnt++) {
                            for (dpl_val = dpl_num->range[dpl_cnt].min; dpl_val <= dpl_num->range[dpl_cnt].max; dpl_val++) {
                                QOS_EGRESS_DSCP_DPL_CONF(dscp_val, dpl_val);
                            }
                        }
                    } else { /* dpl not specified -> use dpl = 0 */
                        QOS_EGRESS_DSCP_DPL_CONF(dscp_val, 0);
                    }
                }
            }
        } else if (dscp_name != 0xff) { /* dscp_name contains a single DSCP value */
            if (key_dpl && dpl_num) { /* dpl_num may contain multiple dpl values */
                u32 dpl_cnt, dpl_val;
                for (dpl_cnt = 0; dpl_cnt < dpl_num->cnt; dpl_cnt++) {
                    for (dpl_val = dpl_num->range[dpl_cnt].min; dpl_val <= dpl_num->range[dpl_cnt].max; dpl_val++) {
                        QOS_EGRESS_DSCP_DPL_CONF(dscp_name, dpl_val);
                    }
                }
            } else { /* dpl not specified -> use dpl = 0 */
                QOS_EGRESS_DSCP_DPL_CONF(dscp_name, 0);
            }
        } else {
            ICLI_PRINTF("%% QOS: unable to parse dscp\n");
            return ICLI_RC_ERROR;
        }
    } else if (key_cosid) {
        u32 cosid_cnt, cosid_val;
        for (cosid_cnt = 0; cosid_cnt < cosid_num->cnt; cosid_cnt++) {
            for (cosid_val = cosid_num->range[cosid_cnt].min; cosid_val <= cosid_num->range[cosid_cnt].max; cosid_val++) {
                if (key_dpl && dpl_num) { /* dpl_num may contain multiple dpl values */
                    u32 dpl_cnt, dpl_val;
                    for (dpl_cnt = 0; dpl_cnt < dpl_num->cnt; dpl_cnt++) {
                        for (dpl_val = dpl_num->range[dpl_cnt].min; dpl_val <= dpl_num->range[dpl_cnt].max; dpl_val++) {
                            QOS_EGRESS_COSID_DPL_CONF(cosid_val, dpl_val);
                        }
                    }
                } else { /* dpl not specified -> use dpl = 0 */
                    QOS_EGRESS_COSID_DPL_CONF(cosid_val, 0);
                }
            }
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = qos egress-map <0-1>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! qos
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    =
BYWORD  =

! egress-map
CMD_VAR =
RUNTIME =
HELP    = Egress map association
BYWORD  =

! <0-1>
CMD_VAR = id
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    = ##HELP_QOS_MAP_ID
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.egress_map = id;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no qos egress-map

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

! no
CMD_VAR =
RUNTIME = QOS_ICLI_runtime_egress_map
HELP    =
BYWORD  =

! qos
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! egress-map
CMD_VAR =
RUNTIME =
HELP    = Egress map association
BYWORD  =

VARIABLE_BEGIN
    switch_iter_t             sit;
    port_iter_t               pit;
    vtss_appl_qos_port_conf_t dc;
    vtss_appl_qos_port_conf_t c;
VARIABLE_END

CODE_BEGIN
    IC_RC(vtss_appl_qos_port_conf_get_default(&dc));
    (void) icli_switch_iter_init(&sit);
    while (icli_switch_iter_getnext(&sit, plist)) {
        (void) icli_port_iter_init(&pit, sit.isid, PORT_ITER_FLAGS_NORMAL);
        while (icli_port_iter_getnext(&pit, plist)) {
            IC_RC(vtss_appl_qos_port_conf_get(sit.isid, pit.iport, &c));
            c.port.egress_map = dc.port.egress_map;
            IC_RC(vtss_appl_qos_port_conf_set(sit.isid, pit.iport, &c));
        }
    }
CODE_END

CMD_END

