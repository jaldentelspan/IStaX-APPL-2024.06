# Copyright (c) 2006-2020 Microsemi Corporation "Microsemi". All Rights Reserved.
#
# Unpublished rights reserved under the copyright laws of the United States of
# America, other countries and international treaties. Permission to use, copy,
# store and modify, the software and its source code is granted but only in
# connection with products utilizing the Microsemi switch and PHY products.
# Permission is also granted for you to integrate into other products, disclose,
# transmit and distribute the software only in an absolute machine readable
# format (e.g. HEX file) and only in or with products utilizing the Microsemi
# switch and PHY products.  The source code of the software may not be
# disclosed, transmitted or distributed without the prior written permission of
# Microsemi.
#
# This copyright notice must appear in any copy, modification, disclosure,
# transmission or distribution of the software.  Microsemi retains all
# ownership, copyright, trade secret and proprietary rights in the software and
# its source code, including all modifications thereto.
#
# THIS SOFTWARE HAS BEEN PROVIDED "AS IS". MICROSEMI HEREBY DISCLAIMS ALL
# WARRANTIES OF ANY KIND WITH RESPECT TO THE SOFTWARE, WHETHER SUCH WARRANTIES
# ARE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE INCLUDING, WITHOUT LIMITATION,
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR USE OR PURPOSE AND
# NON-INFRINGEMENT.

// Module Segment
//   This tag value is used to decide whether all commands of this module are
//   registered or not and the generated C/H file is compiled or not.
//
MODULE_IF_FLAG =

//
// Include Segment
//   The segment contains the include files. These include files are needed
//   for the code body, that is, all other segments.
//   "icli_api.h" is the default include file that will be auto-generated
//   in C file.
//   The content will be exactly pasted to the generated C file.
//
INCLUDE_BEGIN
#include <stdlib.h>
#include "icli_cmd_func.h"
#include <vtss/basics/vector.hxx>
#include <string>
#ifdef USE_VARMAP
// Define USE_VARMAP if more advanced variable support is needed in the expression parser
#include <vtss/basics/map.hxx>
#endif

/* for debug */
extern
#ifdef __cplusplus
"C"
#endif
i32 vtss_icli_exec_para_cnt_get(
    void
);

extern
#ifdef __cplusplus
"C"
#endif
i32 vtss_icli_register_cmd_cnt_get(
    void
);
INCLUDE_END

//
// Function Segment
//   The segment allows the designer writes the local functions that will be
//   used in the command Segment and also the global functions that can be
//   shared with other C files.
//   The content will be exactly pasted to the generated C file.
//
FUNCTION_BEGIN
static void _icli_line_show(
    IN u32  session_id,
    IN u32  config_session_id,
    IN BOOL b_alive
)
{
    icli_session_data_t     *session_data;
    BOOL                    b_self = (session_id == config_session_id);
    i32                     day, hour, min, sec;

    // allocate memory
    session_data = (icli_session_data_t *)icli_malloc(sizeof(icli_session_data_t));
    if ( session_data == NULL ) {
        T_E("memory insufficient\n");
        return;
    }

    session_data->session_id = config_session_id;
    if ( icli_session_data_get(session_data) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to get session data of session %u.\n", config_session_id);
        icli_free(session_data);
        return;
    }

    /* display alive line only */
    if ( b_alive ) {
        if ( session_data->alive == FALSE ) {
            icli_free(session_data);
            return;
        }
    }

    ICLI_PRINTF("Line is ");
    if ( config_session_id ) {
        ICLI_PRINTF("vty %d.\n", config_session_id - 1);
    } else {
        ICLI_PRINTF("con 0.\n");
    }
    ICLI_PRINTF("---------------\n");

    if ( b_self ) {
        ICLI_PRINTF("    * You are at this line now.\n");
    }

    if ( session_data->location[0] != 0 ) {
        ICLI_PRINTF("    Location is at %s.\n", session_data->location);
    }

    if ( session_data->alive ) {
        ICLI_PRINTF("    Alive from ");
        switch( session_data->way ) {
            case ICLI_SESSION_WAY_CONSOLE:
                ICLI_PRINTF("CONSOLE.\n");
                break;

            case ICLI_SESSION_WAY_THREAD_CONSOLE:
                ICLI_PRINTF("Console.\n");
                break;

            case ICLI_SESSION_WAY_TELNET:
                ICLI_PRINTF("TELNET.\n");
                break;

            case ICLI_SESSION_WAY_THREAD_TELNET:
                ICLI_PRINTF("Telnet.\n");
                break;

            case ICLI_SESSION_WAY_SSH:
                ICLI_PRINTF("SSH.\n");
                break;

            case ICLI_SESSION_WAY_THREAD_SSH:
                ICLI_PRINTF("Ssh.\n");
                break;

            case ICLI_SESSION_WAY_APP_EXEC:
                ICLI_PRINTF("Application.\n");
                break;

            default:
                ICLI_PRINTF("unknown.\n");
                break;
        }
    } else {
        ICLI_PRINTF("    Not alive.\n");
    }

    ICLI_PRINTF("    Default privileged level is %d.\n", session_data->privileged_level);

    ICLI_PRINTF("    Command line editing is %s\n",
        (session_data->input_style == ICLI_INPUT_STYLE_SINGLE_LINE)?"enabled":"disabled");

    ICLI_PRINTF("    Display EXEC banner is %s.\n", session_data->b_exec_banner?"enabled":"disabled");
    ICLI_PRINTF("    Display Day banner is %s.\n", session_data->b_motd_banner?"enabled":"disabled");

    ICLI_PRINTF("    Terminal width is %d.\n", session_data->width);
    ICLI_PRINTF("             length is %d.\n", session_data->lines);
    ICLI_PRINTF("             history size is %d.\n", session_data->history_size);

    sec = (session_data->wait_time <= 0) ? 0 : session_data->wait_time;
    min = sec / 60;
    sec = sec % 60;
    ICLI_PRINTF("             exec-timeout is %d min %d second.\n", min, sec);
    ICLI_PRINTF("\n");

    ICLI_PRINTF("    Current session privilege is %d.\n", session_data->privilege);

    sec  = session_data->elapsed_time % 60;
    min  = (session_data->elapsed_time / 60) % 60;
    hour = (session_data->elapsed_time / (60 * 60)) % 24;
    day  = session_data->elapsed_time / (24 * 60 * 60);
    ICLI_PRINTF("    Elapsed time is %d day %d hour %d min %d sec.\n", day, hour, min, sec);

    sec  = session_data->idle_time % 60;
    min  = (session_data->idle_time / 60) % 60;
    hour = (session_data->idle_time / (60 * 60)) % 24;
    day  = session_data->idle_time / (24 * 60 * 60);
    ICLI_PRINTF("    Idle time is %d day %d hour %d min %d sec.\n", day, hour, min, sec);

    icli_free(session_data);

    ICLI_PRINTF("\n");
}

static void _icli_user_show(IN u32 session_id, IN u32 config_session_id)
{
    icli_session_data_t     *session_data;
    BOOL                    b_self = (session_id == config_session_id);
    i32                     day, hour, min, sec;
    char                    str[64];

    // allocate memory
    session_data = (icli_session_data_t *)icli_malloc(sizeof(icli_session_data_t));
    if ( session_data == NULL ) {
        T_E("memory insufficient\n");
        return;
    }

    session_data->session_id = config_session_id;
    if ( icli_session_data_get(session_data) != ICLI_RC_OK ) {
        ICLI_SELF_PRINTF("%% Fail to get session data of session %u.\n", config_session_id);
        icli_free(session_data);
        return;
    }

    /* if session not alive, display nothing */
    if ( session_data->alive == FALSE ) {
        icli_free(session_data);
        return;
    }

    ICLI_SELF_PRINTF("Line is ");
    if ( config_session_id ) {
        ICLI_SELF_PRINTF("vty %d.\n", config_session_id - 1);
    } else {
        ICLI_SELF_PRINTF("con 0.\n");
    }

    if ( b_self ) {
        ICLI_SELF_PRINTF("    * You are at this line now.\n");
    }

    switch( session_data->way ) {
        case ICLI_SESSION_WAY_CONSOLE:
        case ICLI_SESSION_WAY_THREAD_CONSOLE:
            ICLI_SELF_PRINTF("    Connection is from Console.\n");
            break;

        case ICLI_SESSION_WAY_TELNET:
        case ICLI_SESSION_WAY_THREAD_TELNET:
            if ( session_data->client_ip.type == MESA_IP_TYPE_IPV4 ) {
                (void)vtss_icli_ipv4_to_str(session_data->client_ip.addr.ipv4, str);
            } else {
                (void)vtss_icli_ipv6_to_str(session_data->client_ip.addr.ipv6, str);
            }
            ICLI_SELF_PRINTF("    Connection is from %s:%u by Telnet.\n", str, session_data->client_port);
            break;

        case ICLI_SESSION_WAY_SSH:
        case ICLI_SESSION_WAY_THREAD_SSH:
            if ( session_data->client_ip.type == MESA_IP_TYPE_IPV4 ) {
                (void)vtss_icli_ipv4_to_str(session_data->client_ip.addr.ipv4, str);
            } else {
                (void)vtss_icli_ipv6_to_str(session_data->client_ip.addr.ipv6, str);
            }
            ICLI_SELF_PRINTF("    Connection is from %s:%u by SSH.\n", str, session_data->client_port);
            break;

        case ICLI_SESSION_WAY_APP_EXEC:
            ICLI_SELF_PRINTF("    Connection is from application.\n");
            break;

        default:
            ICLI_SELF_PRINTF("    Connection is unknown.\n");
            break;
    }

    if ( session_data->user_name[0] != 0 ) {
        ICLI_SELF_PRINTF("    User name is %s.\n", session_data->user_name);
    } else {
#if defined(VTSS_SYS_ADMIN_NAME_DEFAULT_NULL_STR)
        ICLI_SELF_PRINTF("    Login user is the default administrator.\n");
#else
        ICLI_SELF_PRINTF("    Not login by user name.\n");
#endif /* VTSS_SYS_ADMIN_NAME_DEFAULT_NULL_STR */
    }
    ICLI_SELF_PRINTF("    Privilege is %d.\n", session_data->privilege);

    sec  = session_data->elapsed_time % 60;
    min  = (session_data->elapsed_time / 60) % 60;
    hour = (session_data->elapsed_time / (60 * 60)) % 24;
    day  = session_data->elapsed_time / (24 * 60 * 60);
    ICLI_SELF_PRINTF("    Elapsed time is %d day %d hour %d min %d sec.\n", day, hour, min, sec);

    sec  = session_data->idle_time % 60;
    min  = (session_data->idle_time / 60) % 60;
    hour = (session_data->idle_time / (60 * 60)) % 24;
    day  = session_data->idle_time / (24 * 60 * 60);
    ICLI_SELF_PRINTF("    Idle time is %d day %d hour %d min %d sec.\n", day, hour, min, sec);

    icli_free(session_data);

    ICLI_SELF_PRINTF("\n");
}

// Integer expression evaluator with variable support.
//
// No detailed error reporting, as this is intended for debug use.
// Would be simple to add, though.
//
// Precedence is really, really simple and doesn't follow C fully. Use
// parenthesis.
//
// Fails division by zero. Doesn't worry about overrun/underrun.
//
// Language
// --------
// expr       ::= simpleterm { ('<<' | '>>' | '|' | '&') simpleterm } .
// simpleterm ::= term { ('+' | '-') term } .
// term       ::= factor { ('*' | '/') factor } .
// factor     ::= '(' expr ')' | '-' factor | variable | number .
//
// variable   ::= 'a'..'z' { 'a..'z' | '_' | '0'..'9' } .     // Lower-case only
// number     ::= base10 | base16 .
// base10     ::= '0'..'9' { '0'..'9' } .
// base16     ::= '0x' hexdigit .
// hexdigit   ::= '0'..'9' | 'a'..'f' .                       // Lower-case hex digits only
//
// NOTE: <space> is a terminator! This in order to make the evaluator usable in ICLI commands where
//       spaces separate keywords/parameters.
//
class ExprEval {
public:
#ifdef USE_VARMAP
    // Use variable map: 'name' => integer.
    // Optional to save space, plus usecase in this file is currently more simple: Single loop var, 'i'

    using VarMap = vtss::Map<std::string, int>;

    ExprEval(const VarMap &vm) : fail_text(nullptr), varmap(vm) { }
#else
    // So this is when we have no variable map, but only the loop var 'i'
    ExprEval() : idx(0) { }

    // Set the loop variable before next call to @eval()
    void set_idx(int n)
    {
        idx = n;
    }
#endif

    // Is result returned by @eval() valid? true if yes, false if there was a parsing error
    bool is_valid() const              { return fail_text.length() == 0; }
    std::string error_message() const  { return fail_text; }

    // Length of evaluated expression in characters. Used when parsing multiple expressions in a string separated by other text
    size_t length() const { return tok_idx; }     // Only reliable if is_valid()

    // Evaluate expression, return resulting value. Call @is_valid() before using
    // result
    int eval(const std::string &expression)
    {
        int result = 0;

        fail_text = "";
        input     = expression;
        tok_idx   = 0;
        tok       = "";

        if (get_next()) {
            result  = expr();
            tok_idx = tok_idx - tok.length();   // If we have a tok here it's because the expression parsing ended with a valid token that wasn't processed, e.g. "1+i)" -- tok is then ")". So push it back
        } else {
            fail_text = "Invalid expression: " + expression;
        }

        return result;
    }

private:

    int expr()
    {
        int res = simpleterm();
        while (is_valid()) {
            if (tok == "<<") {
                get_next();
                res = res << simpleterm();
            } else if (tok == ">>") {
                get_next();
                res = res >> simpleterm();
            } else if (tok == "|") {
                get_next();
                res = res | simpleterm();
            } else if (tok == "&") {
                get_next();
                res = res & simpleterm();
            } else {
                break;
            }
        }
        return res;
    }

    int simpleterm()
    {
        int res = term();
        while (is_valid()) {
            if (tok == "+") {
                get_next();
                res = res + term();
            } else if (tok == "-") {
                get_next();
                res = res - term();
            } else {
                break;
            }
        }
        return res;
    }

    int term()
    {
        int res = factor();
        while (is_valid()) {
            if (tok == "*") {
                get_next();
                res = res * factor();
            } else if (tok == "/") {
                get_next();
                int divisor = factor();
                if (divisor == 0) {
                    fail("Divide by zero");
                } else {
                    res = res / divisor;
                }
            } else {
                break;
            }
        }
        return res;
    }

    int factor()
    {
        int res = 0;
        if (!is_valid()) {
            return 0;
        }
        if (tok == "(") {
            get_next();
            res = expr();
            if (tok != ")") {
                fail("Missing ')'");
            }
            get_next();
        } else if (tok == "-") {
            get_next();
            res = -factor();
        } else if (tok_type == VAR) {
#ifdef USE_VARMAP
            auto var = varmap.find(tok);
            if (var != varmap.end()) {
                res = var->second;
#else
            if (tok == "i") {
                res = idx;
#endif
            } else {
                fail("Unknown variable");
            }
            get_next();
        } else if (tok_type == NUM) {
            res = tok_numval;
            get_next();
        } else {
            fail("Not a factor");
        }
        return res;
    }

    bool get_next()
    {
        tok_numval = 0;

        size_t start = tok_idx;

        switch (input[tok_idx]) {
        case '<':
        case '>':
            if (input[tok_idx] != input[tok_idx + 1]) { // Not '<<' or '>>'
                fail("Expected '<<' or '>>");
                return false;
            }
            tok_type = SYM;
            tok_idx += 2;
            break;
        case '+':
        case '-':
        case '*':
        case '/':
        case '&':
        case '|':
        case '(':
        case ')':
            tok_type = SYM;
            tok_idx++;
            break;

        case 'a' ... 'z':
            tok_type = VAR;
            while (
                (input[tok_idx] == '_')                          ||
                (input[tok_idx] >= 'a' && input[tok_idx] <= 'z') ||
                (input[tok_idx] >= '0' && input[tok_idx] <= '9') ) {
                tok_idx++;
            }
            break;

        case '0' ... '9':
            {
                tok_type        = NUM;
                tok_numval      = 0;
                bool hex        = input[tok_idx] == '0' && input[tok_idx+1] == 'x';
                int fact        = 10;
                bool got_digits = false;    // In order to catch '0x' without any more digits
                if (hex) {
                    tok_idx += 2;
                    fact = 16;
                }
                while ((input[tok_idx] >= '0' && input[tok_idx] <= '9') || (hex && input[tok_idx] >= 'a' && input[tok_idx] <= 'f')) {
                    got_digits = true;
                    if (input[tok_idx] >= '0' && input[tok_idx] <= '9') {
                        tok_numval = tok_numval * fact + (input[tok_idx] - '0');
                    } else {
                        tok_numval = tok_numval * fact + (input[tok_idx] - 'a' + 10);
                    }
                    tok_idx++;
                }
                if (!got_digits) {
                    fail("Invalid number");
                }
            }
            break;
        default:
            // End-of-input, or not a token
            break;
        }

        tok = std::string(input.c_str() + start, tok_idx - start);

        return tok_idx != start;        // true == we got a token; false == no token or end-of-input
    }

    void fail(const std::string &text)
    {
        fail_text = text;
    }

    std::string            input;       // Copy of param to @eval()
    std::string            tok;         // Current token (most recently returned by @get_next())
    std::string            fail_text;   // Non-empty string when there's been a parsing/evaluation error
    enum { SYM, NUM, VAR } tok_type;    // Type of current token: Symbol, number, variable identifier
    int                    tok_numval;  // Numerical value of token iff tok_type == NUM
    size_t                 tok_idx;     // Current index into input, used by @get_next()
#ifdef USE_VARMAP
    const VarMap           &varmap;     // Variable map: 'name' => integer
#else
    int                    idx;         // Current value of pseudo-variable 'i'
#endif
};

FUNCTION_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = configure terminal
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =

RUNTIME   =

BYWORD    =

HELP      = Enter configuration mode
HELP      = Configure from the terminal

CMD_MODE  = ICLI_CMD_MODE_EXEC
GOTO_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG

VARIABLE_BEGIN
    i32     level;

#if 1 /* Bugzilla#14275 - "do config term" at interface mode */
    i32     exit_level;
#endif
VARIABLE_END

CODE_BEGIN
#if 1 /* Bugzilla#14275 - "do config term" at interface mode */
    exit_level = ICLI_MODE_EXIT();
    if ( exit_level ) {
        if ( icli_config_go_to_exec_mode(session_id) == FALSE ) {
            ICLI_PRINTF("%% Fail to go back to EXEC mode.\n\n");
            return ICLI_RC_ERROR;
        }
    }
#endif

    level = ICLI_MODE_ENTER( ICLI_CMD_MODE_GLOBAL_CONFIG );
    if ( level != 1 ) {
        ICLI_PRINTF("%% Fail to enter Configuration mode.\n\n");
        return ICLI_RC_ERROR;
    }

#if 1 /* Bugzilla#14275 - "do config term" at interface mode */
    if ( exit_level ) {
        /*
            this enter is a dummy enter because this is "do config term"
            in interface mode and it will EXIT later in do command in
            icli_config.icli
        */
        level = ICLI_MODE_ENTER( ICLI_CMD_MODE_STP_AGGR );
        if ( level != 2 ) {
            ICLI_PRINTF("%% Fail to enter STP AGGR mode.\n\n");
            return ICLI_RC_ERROR;
        }
    }
#endif
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = help
FUNC_NAME = _help_display
PRIVILEGE = ICLI_PRIVILEGE_0
HELP      = Description of the interactive help system
CMD_MODE  = ICLI_CMD_MODE_EXEC

CODE_BEGIN
    ICLI_PRINTF("Help may be requested at any point in a command by entering\n");
    ICLI_PRINTF("a question mark '?'.  If nothing matches, the help list will\n");
    ICLI_PRINTF("be empty and you must backup until entering a '?' shows the\n");
    ICLI_PRINTF("available options.\n");
    ICLI_PRINTF("Two styles of help are provided:\n");
    ICLI_PRINTF("1. Full help is available when you are ready to enter a\n");
    ICLI_PRINTF("   command argument (e.g. 'show ?') and describes each possible\n");
    ICLI_PRINTF("   argument.\n");
    ICLI_PRINTF("2. Partial help is provided when an abbreviated argument is entered\n");
    ICLI_PRINTF("   and you want to know what arguments match the input\n");
    ICLI_PRINTF("   (e.g. 'show pr?'.)\n");
    ICLI_PRINTF("\n");
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = exit
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =
FUNC_NAME = _exec_exit

HELP      = Exit from EXEC mode

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_CLOSE() != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to close session.\n\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND    = logout
FUNC_REUSE = _exec_exit
PRIVILEGE  = ICLI_PRIVILEGE_0
CMD_MODE   = ICLI_CMD_MODE_EXEC
HELP       = Exit from EXEC mode
CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = disable [<0-15>]
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   = new_priv

RUNTIME   =

BYWORD    =

HELP      = Turn off privileged commands

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    icli_privilege_t    current_priv;

    new_priv = 0;
VARIABLE_END

CODE_BEGIN
    if ( ICLI_PRIVILEGE_GET(&current_priv) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to get privilege\n");
        return ICLI_RC_ERROR;
    }

    if ( (icli_privilege_t)new_priv > current_priv ) {
        ICLI_PRINTF("%% New privilege level must be less than current privilege level\n");
        return ICLI_RC_OK;
    }

    if ( ICLI_PRIVILEGE_SET((icli_privilege_t)new_priv) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to turn off privilege level.\n\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = enable [ <0-15> ]
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   = new_priv

RUNTIME   =

BYWORD    =

HELP      = Turn on privileged commands
HELP      = Choose privileged level

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    icli_privilege_t    current_priv;
    char                priv_passwd[ICLI_PASSWORD_MAX_LEN + 1];
    char                usr_passwd[ICLI_PASSWORD_MAX_LEN + 1];
    i32                 passwd_len;
    i32                 retry;
    icli_rc_t           rc;
    BOOL                b_auth;
    icli_line_mode_t    old_line_mode;

    /* initial values */
    new_priv = ICLI_PRIVILEGE_15;
VARIABLE_END

CODE_BEGIN
    if ( ICLI_PRIVILEGE_GET(&current_priv) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to get privilege\n");
        return ICLI_RC_ERROR;
    }

    if ( new_priv > 0 && (icli_privilege_t)new_priv > current_priv ) {
        if ( icli_enable_password_get((icli_privilege_t)new_priv, priv_passwd) == FALSE ) {
            ICLI_PRINTF("%% No password set\n\n");
            return ICLI_RC_OK;
        }
        if ( vtss_icli_str_len(priv_passwd) == 0 ) {
            ICLI_PRINTF("%% No password set\n\n");
            return ICLI_RC_OK;
        }
        /* get old line mode and then set to be FLOOD */
        if ( ICLI_LINE_MODE_GET(&old_line_mode) != ICLI_RC_OK ) {
            ICLI_PRINTF("%% Fail to get current line mode\n");
            return ICLI_RC_ERROR;
        }
        if ( ICLI_LINE_MODE_SET(ICLI_LINE_MODE_FLOOD) != ICLI_RC_OK ) {
            ICLI_PRINTF("%% Fail to set current line mode to be FLOOD\n");
            return ICLI_RC_ERROR;
        }
        /* get password from user input */
        b_auth = FALSE;
        for ( retry=0, b_auth=FALSE; b_auth==FALSE && retry<ICLI_ENABLE_PASSWORD_RETRY; ++retry ) {
            ICLI_PRINTF("Password: ");
            passwd_len = ICLI_PASSWORD_MAX_LEN;
            rc = (icli_rc_t)ICLI_USR_STR_GET(ICLI_USR_INPUT_TYPE_PASSWORD, usr_passwd, &passwd_len, NULL);
            switch( rc ) {
                case ICLI_RC_ERR_EXPIRED:
                    ICLI_PRINTF("%% Password:  timeout expired!\n");
                    continue;

                case ICLI_RC_OK:
                    /* compare */
                    if ( icli_enable_password_verify((icli_privilege_t)new_priv, usr_passwd) ) {
                        b_auth = TRUE;
                    }
                    break;

                default:
                    if ( ICLI_LINE_MODE_SET(old_line_mode) != ICLI_RC_OK ) {
                        ICLI_PRINTF("%% Fail to set back to current line mode\n");
                        return ICLI_RC_ERROR;
                    }
                    ICLI_PRINTF("%% Fail to get password from user input\n");
                    return ICLI_RC_ERROR;
            }
        }
        if ( ICLI_LINE_MODE_SET(old_line_mode) != ICLI_RC_OK ) {
            ICLI_PRINTF("%% Fail to set back to current line mode\n");
            return ICLI_RC_ERROR;
        }
        if ( b_auth == FALSE ) {
            ICLI_PRINTF("%% Bad password\n\n");
            return ICLI_RC_OK;
        }
    }

    if ( ICLI_PRIVILEGE_SET((icli_privilege_t)new_priv) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to turn on privilege level.\n\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = send { * | <0~16> | console 0 | vty <0~15> } <line128>
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =
CMD_VAR   = b_all
CMD_VAR   = session_list
CMD_VAR   = b_console
CMD_VAR   =
CMD_VAR   = b_vty
CMD_VAR   = vty_list
CMD_VAR   = message

RUNTIME   =

BYWORD    =
BYWORD    =
BYWORD    =
BYWORD    =
BYWORD    =
BYWORD    =
BYWORD    =
BYWORD    = LINE

HELP      = Send a message to other tty lines
HELP      = All tty lines
HELP      = Send a message to multiple lines
HELP      = Primary terminal line
HELP      = Send a message to a specific line
HELP      = Virtual terminal
HELP      = Send a message to multiple lines
HELP      = Message to be sent to lines, in 128 characters

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    u32     sid;
    u32     i;
VARIABLE_END

CODE_BEGIN
    if ( icli_config_user_str_get(session_id, 128, message) == FALSE) {
        ICLI_PRINTF("%% Fail to get message.\n\n");
        return ICLI_RC_ERROR;
    }

    // ++ to skip the start delimiter
    ++message;

    if ( b_all ) {
        for ( sid = 0; sid < ICLI_SESSION_CNT; ++sid ) {
            (void)icli_session_printf(sid, "\n");
            (void)icli_session_printf(sid, "-----------------------------------------\n");
            (void)icli_session_printf(sid, "*** Message from line %u:\n", session_id);
            (void)icli_session_printf(sid, "%s", message);
            (void)icli_session_printf(sid, "\n");
            (void)icli_session_printf(sid, "-----------------------------------------\n");
        }
        return ICLI_RC_OK;
    }

    if ( session_list ) {
        for ( i = 0; i < session_list->cnt; ++i ) {
            for ( sid = session_list->range[i].min; sid <= session_list->range[i].max; ++sid ) {
                (void)icli_session_printf(sid, "\n");
                (void)icli_session_printf(sid, "-----------------------------------------\n");
                (void)icli_session_printf(sid, "*** Message from line %u:\n", session_id);
                (void)icli_session_printf(sid, "%s", message);
                (void)icli_session_printf(sid, "\n");
                (void)icli_session_printf(sid, "-----------------------------------------\n");
            }
        }
        return ICLI_RC_OK;
    }

    if ( b_console ) {
        sid = 0;
        (void)icli_session_printf(sid, "\n");
        (void)icli_session_printf(sid, "-----------------------------------------\n");
        (void)icli_session_printf(sid, "*** Message from line %u:\n", session_id);
        (void)icli_session_printf(sid, "%s", message);
        (void)icli_session_printf(sid, "\n");
        (void)icli_session_printf(sid, "-----------------------------------------\n");
        return ICLI_RC_OK;
    }

    if ( b_vty ) {
        for ( i = 0; i < vty_list->cnt; ++i ) {
            for ( sid = vty_list->range[i].min; sid <= vty_list->range[i].max; ++sid ) {
                (void)icli_session_printf(sid+1, "\n");
                (void)icli_session_printf(sid+1, "-----------------------------------------\n");
                (void)icli_session_printf(sid+1, "*** Message from line %u:\n", session_id);
                (void)icli_session_printf(sid+1, "%s", message);
                (void)icli_session_printf(sid+1, "\n");
                (void)icli_session_printf(sid+1, "-----------------------------------------\n");
            }
        }
        return ICLI_RC_OK;
    }
CODE_END

CMD_END

HELP_TERMINAL = Set terminal line parameters

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND    = terminal help
FUNC_REUSE = _help_display
PRIVILEGE  = ICLI_PRIVILEGE_13
CMD_MODE   = ICLI_CMD_MODE_EXEC

HELP       = ##HELP_TERMINAL
HELP       = Description of the interactive help system
CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = terminal editing
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_13
IF_FLAG   =

HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_EDITING

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    i32     rc;
VARIABLE_END

CODE_BEGIN
    rc = ICLI_INPUT_STYLE_SET(ICLI_INPUT_STYLE_SINGLE_LINE);
    if ( rc != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to enable line editing\n");
        return ICLI_RC_ERROR;
    }
CODE_END

NO_FORM_VARIABLE_BEGIN
    i32     rc;
NO_FORM_VARIABLE_END

NO_FORM_CODE_BEGIN
    rc = ICLI_INPUT_STYLE_SET(ICLI_INPUT_STYLE_MULTIPLE_LINE);
    if ( rc != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to disable line editing\n");
        return ICLI_RC_ERROR;
    }
NO_FORM_CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = terminal length <0,3-512>
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = lines

RUNTIME   =

BYWORD    =
BYWORD    =
BYWORD    = 0 or 3-512

HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_LENGTH
HELP      = ##ICLI_HELP_LENGTH_NUM

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_LINES_SET( lines ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set length.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = no terminal length
PROPERTY  = ICLI_CMD_PROP_LOOSELY
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

HELP      = ##ICLI_HELP_NO
HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_LENGTH

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_LINES_SET( ICLI_DEFAULT_LINES ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set default length.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = terminal width <0,40-512>
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = width

RUNTIME   =

BYWORD    =
BYWORD    =
BYWORD    = 0 or 40-512

HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_WIDTH
HELP      = ##ICLI_HELP_WIDTH_NUM

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_WIDTH_SET( width ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set width.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = no terminal width
PROPERTY  = ICLI_CMD_PROP_LOOSELY
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

HELP      = ##ICLI_HELP_NO
HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_WIDTH

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_WIDTH_SET( ICLI_DEFAULT_WIDTH ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set default width.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = terminal exec-timeout <0-1440> [<0-3600>]
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =
HELP      = ##HELP_TERMINAL
RUNTIME   =
BYWORD    =

CMD_VAR   =
HELP      = ##ICLI_HELP_EXEC_TIMEOUT
RUNTIME   =
BYWORD    =

CMD_VAR   = min
HELP      = ##ICLI_HELP_EXEC_MIN
RUNTIME   =
BYWORD    =

CMD_VAR   = sec
HELP      = ##ICLI_HELP_EXEC_SEC
RUNTIME   =
BYWORD    =

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    i32     timeout;

    /* init sec */
    sec = 0;
VARIABLE_END

CODE_BEGIN
    timeout = min * 60 + sec;
    if ( ICLI_TIMEOUT_SET( timeout ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set timeout.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = no terminal exec-timeout
PROPERTY  = ICLI_CMD_PROP_LOOSELY
PRIVILEGE = ICLI_PRIVILEGE_15

HELP      = ##ICLI_HELP_NO
HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_EXEC_TIMEOUT

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_TIMEOUT_SET( ICLI_DEFAULT_WAIT_TIME ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set default timeout.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

HELP_HISTORY      = Control the command history function
HELP_HISTORY_SIZE = Set history buffer size

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = terminal history size <0-32>
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = history_size

RUNTIME   =

BYWORD    =

HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_HISTORY
HELP      = ##ICLI_HELP_HISTORY_SIZE
HELP      = ##ICLI_HELP_HISTORY_NUM

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_HISTORY_SIZE_SET( history_size ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set history size.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = no terminal history size
PROPERTY  = ICLI_CMD_PROP_LOOSELY
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

HELP      = ##ICLI_HELP_NO
HELP      = ##HELP_TERMINAL
HELP      = ##ICLI_HELP_HISTORY
HELP      = ##ICLI_HELP_HISTORY_SIZE

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( ICLI_HISTORY_SIZE_SET( ICLI_HISTORY_CMD_CNT ) != ICLI_RC_OK ) {
        ICLI_PRINTF("%% Fail to set default history size.\n");
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = do <line>
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   = command

BYWORD    =
BYWORD    = LINE

HELP      = ##ICLI_HELP_DO
HELP      = ##ICLI_HELP_DO_LINE

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if (ICLI_CMD_EXEC(command, TRUE) != ICLI_RC_OK) {
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show terminal
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =

RUNTIME   =

BYWORD    =

HELP      = ##ICLI_HELP_SHOW
HELP      = Display terminal configuration parameters

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    _icli_line_show(session_id, session_id, TRUE);
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show line [alive]
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = b_alive

RUNTIME   =

BYWORD    =

HELP      = ##ICLI_HELP_SHOW
HELP      = TTY line information
HELP      = Display information about alive lines

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    u32     i;
VARIABLE_END

CODE_BEGIN
    for ( i = 0; i < ICLI_SESSION_CNT; ++i ) {
        _icli_line_show(session_id, i, b_alive);
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show history
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =

RUNTIME   =

BYWORD    =

HELP      = ##ICLI_HELP_SHOW
HELP      = Display the session command history

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    icli_session_history_cmd_t      history;
VARIABLE_END

CODE_BEGIN
    if ( icli_session_history_cmd_get_first(session_id, &history) == ICLI_RC_OK ) {
        ICLI_PRINTF("  %s\n", history.history_cmd);
        while ( icli_session_history_cmd_get_next(session_id, &history) == ICLI_RC_OK ) {
            ICLI_PRINTF("  %s\n", history.history_cmd);
        }
    }
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show users [myself]
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_0
IF_FLAG   =

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = b_myself

RUNTIME   =

BYWORD    =

HELP      = ##ICLI_HELP_SHOW
HELP      = Display information about terminal lines
HELP      = Display information about mine

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    u32     i;
VARIABLE_END

CODE_BEGIN
    if ( b_myself ) {
        _icli_user_show(session_id, session_id);
    } else {
        for ( i = 0; i < ICLI_SESSION_CNT; ++i ) {
            _icli_user_show(session_id, i);
        }
    }
CODE_END

CMD_END

HELP_DEBUG_ICLI = ICLI debug function

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli banner
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_ICLI
HELP      = All current ICLI banners

VARIABLE_BEGIN
    char    *banner;
VARIABLE_END

CODE_BEGIN
    banner = (char *)icli_malloc(ICLI_BANNER_MAX_LEN + 1);
    if ( banner == NULL ) {
        T_E("memory insufficient for banner\n");
        return ICLI_RC_ERROR;
    }

    if ( icli_banner_motd_get(banner) == ICLI_RC_OK ) {
        if ( *banner == 0 ) {
            ICLI_PRINTF("  The Day banner is not set.\n");
        } else {
            ICLI_PRINTF("  The Day banner is \"%s\".\n", banner);
        }
    }

    if ( icli_banner_login_get(banner) == ICLI_RC_OK ) {
        if ( *banner == 0 ) {
            ICLI_PRINTF("  The Login banner is not set.\n");
        } else {
            ICLI_PRINTF("  The Login banner is \"%s\".\n", banner);
        }
    }

    if ( icli_banner_exec_get(banner) == ICLI_RC_OK ) {
        if ( *banner == 0 ) {
            ICLI_PRINTF("  The Exec banner is not set.\n");
        } else {
            ICLI_PRINTF("  The Exec banner is \"%s\".\n", banner);
        }
    }

    icli_free(banner);
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli port configuration
PROPERTY  =
PRIVILEGE = ICLI_PRIVILEGE_15
IF_FLAG   =

HELP      = ##ICLI_HELP_DEBUG
HELP      = ICLI engine
HELP      = Port configuration
HELP      = Current configuration

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    icli_stack_port_range_t  *r;
    u32                      i;
VARIABLE_END

CODE_BEGIN
    r = (icli_stack_port_range_t *)icli_malloc(sizeof(icli_stack_port_range_t));
    if ( r == NULL ) {
        ICLI_PRINTF("%% Fail to allocate memory\n");
        return ICLI_RC_ERROR;
    }

    if ( icli_port_range_get(r) == FALSE ) {
        ICLI_PRINTF("%% Fail to retrieve port range from ICLI\n");
        icli_free(r);
        return ICLI_RC_ERROR;
    }

    ICLI_PRINTF("Type                Switch ID  Port ID  Port Cnt  Usid  Uport  Isid  Iport\n");
    ICLI_PRINTF("==================  =========  =======  ========  ====  =====  ====  =====\n");

    for ( i = 0; i < r->cnt; ++i ) {
        ICLI_PRINTF("%-18s %9u  %7u  %8u  %4u  %5u  %4u  %5u\n",
            icli_port_type_get_name((icli_port_type_t)(r->switch_range[i].port_type)),
            r->switch_range[i].switch_id,
            r->switch_range[i].begin_port,
            r->switch_range[i].port_cnt,
            r->switch_range[i].usid,
            r->switch_range[i].begin_uport,
            r->switch_range[i].isid,
            r->switch_range[i].begin_iport);
    }

    icli_free(r);
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli struct size
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

IF_FLAG   = 0

CODE_BEGIN
    ICLI_PRINTF("icli_runtime_t          = %u\n", sizeof(icli_runtime_t));
    ICLI_PRINTF("icli_signed_range_t     = %u\n", sizeof(icli_signed_range_t));
    ICLI_PRINTF("icli_unsigned_range_t   = %u\n", sizeof(icli_unsigned_range_t));
    ICLI_PRINTF("icli_stack_port_range_t = %u\n", sizeof(icli_stack_port_range_t));
    ICLI_PRINTF("icli_range_t            = %u\n", sizeof(icli_range_t));
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show privilege
PROPERTY  = ICLI_CMD_PROP_GREP
PRIVILEGE = ICLI_PRIVILEGE_0

HELP      = ##ICLI_HELP_SHOW
HELP      = Display command privilege

CMD_MODE  = ICLI_CMD_MODE_EXEC

VARIABLE_BEGIN
    icli_priv_cmd_conf_t    conf;
VARIABLE_END

CODE_BEGIN
    if ( icli_priv_get_first(&conf) != ICLI_RC_OK ) {
        return ICLI_RC_OK;
    }

    ICLI_PRINTF("\n");
    ICLI_PRINTF(" -------------------------------------------- \n");
    ICLI_PRINTF("|   The order is as the input sequence and   |\n");
    ICLI_PRINTF("|   the last one has the highest priority.   |\n");
    ICLI_PRINTF(" -------------------------------------------- \n");
    ICLI_PRINTF("\n");

    ICLI_PRINTF("  privilege %s level %u %s\n", icli_mode_name_get(conf.mode), conf.privilege, conf.cmd);

    while ( icli_priv_get_next(&conf) == ICLI_RC_OK ) {
        ICLI_PRINTF("  privilege %s level %u %s\n", icli_mode_name_get(conf.mode), conf.privilege, conf.cmd);
    }
    ICLI_PRINTF("\n");
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli count
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_ICLI
HELP      = Free parameters
HELP      = Count of Free parameters

CODE_BEGIN
    ICLI_PRINTF("Number of free parameters     = %d\n", vtss_icli_exec_para_cnt_get());
    ICLI_PRINTF("Number of commands registered = %d\n", vtss_icli_register_cmd_cnt_get());
CODE_END
CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli cls [ <1-100000> ]
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = n

HELP      = ##ICLI_HELP_DEBUG
HELP      = ##HELP_DEBUG_ICLI
HELP      = Clean screen
HELP      = Number of new lines

VARIABLE_BEGIN
    n = 200;
VARIABLE_END

CODE_BEGIN
    for ( ; n > 0; --n ) {
        ICLI_PRINTF("\n");
    }
CODE_END
CMD_END

HELP_PLATFORM = Platform configuration
HELP_DEUBG    = Debug command setting

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = platform debug { allow | deny }
CMD_MODE  = ICLI_CMD_MODE_EXEC
PRIVILEGE = ICLI_PRIVILEGE_15

HELP      = ##HELP_PLATFORM
HELP      = ##HELP_DEUBG
HELP      = Allow debug commands
HELP      = Deny debug commands

CMD_VAR   =
CMD_VAR   =
CMD_VAR   = b_allow
CMD_VAR   =

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if ( b_allow == FALSE ) {
        ICLI_DEBUG_CMD_ALLOW_SET( b_allow );
        return ICLI_RC_OK;
    }

    if ( ICLI_DEBUG_CMD_ALLOW_FIRST_TIME_GET() ) {
        ICLI_PRINTF("\n");
        ICLI_PRINTF("WARNING: The use of 'debug' commands may negatively impact system behavior.\n");
        ICLI_PRINTF("Do not enable unless instructed to. (Use 'platform debug deny' to disable\n");
        ICLI_PRINTF("debug commands.)\n");
        ICLI_PRINTF("\n");
        ICLI_PRINTF("NOTE: 'debug' command syntax, semantics and behavior are subject to change\n");
        ICLI_PRINTF("without notice.\n");
        ICLI_PRINTF("\n");
    }

    ICLI_DEBUG_CMD_ALLOW_SET( b_allow );
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = show platform debug
CMD_MODE  = ICLI_CMD_MODE_EXEC
PRIVILEGE = ICLI_PRIVILEGE_15

HELP      = ##ICLI_HELP_SHOW
HELP      = ##HELP_PLATFORM
HELP      = ##HELP_DEUBG

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_PRINTF("\n");
    ICLI_PRINTF("Platform debug command function is %s.\n", ICLI_DEBUG_CMD_ALLOW_GET() ? "allowed" : "denied");
    ICLI_PRINTF("\n");
CODE_END

CMD_END

//
// Command Segment
//   This segment is the implementation of the command,
//   one segment for one command.
//
CMD_BEGIN
COMMAND   = debug icli session close name <word>
PRIVILEGE = ICLI_PRIVILEGE_15
CMD_MODE  = ICLI_CMD_MODE_EXEC

IF_FLAG   = 0

HELP      = ##ICLI_HELP_DEBUG
HELP      = ICLI engine
HELP      = Session configuration
HELP      = Close session
HELP      = Close session by user name
HELP      = User name

CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   =
CMD_VAR   = username

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    icli_session_close_by_username( username );
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = debug icli loop <range_list> <line>

DOC_CMD_DESC    =
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   =
DOC_CMD_EXAMPLE =

FUNC_NAME =
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_0
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

! debug
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! icli
CMD_VAR =
RUNTIME =
HELP    =
BYWORD  =

! loop
CMD_VAR =
RUNTIME =
HELP    = Loop set of ICLI command lines
BYWORD  =

! <range_list>
CMD_VAR = range
RUNTIME =
HELP    = Unsigned integer range
BYWORD  =

! <line>
CMD_VAR = line
RUNTIME =
HELP    = Input multiple lines as single line, use ';' as line separator. \
Structure: [ <preamble> ;; ] <looped lines> [ ;; <postamble> ]. Use '$...' \
for expression wherein 'i' expands to loop index. No spaces allowed in expr. \
Always starts out in global exec mode. Example: \
'debug icli loop 1-4 conf t;;int g 1/$i*2; no lldp transmit;;end'
BYWORD  =

VARIABLE_BEGIN
    vtss::Vector<std::string> preamble_lines;
    vtss::Vector<std::string> loop_lines;
    vtss::Vector<std::string> postamble_lines;
    vtss::Vector<std::string> *current = &preamble_lines;
VARIABLE_END

CODE_BEGIN
    // Split into lines at ';'. ';;' will mean either end-of-preamble or end-of-looped-lines
    for (const char *pstart = line, *pend = line; *pend; ) {
        for (; *pend && *pend != ';'; pend++) {}        // Find next ';' or end-of-input
        std::string new_line(pstart, pend - pstart);    // Build line from substring
        if (new_line.length() == 0) {                   // Empty line: Change line set (preamble => looped or looped => postamble)
            if (current == &preamble_lines) {
                current = &loop_lines;
            } else if (current == &loop_lines) {
                current = &postamble_lines;
            }
        } else {
            current->push_back(new_line);
        }
        if (*pend) {
            pend++;
        }
        pstart = pend;
    }

    // If no loop lines, assume preamble is actually loop.
    // Then people won't have to write ';lines-that-loop-here'
    if (loop_lines.size() == 0) {
        loop_lines = preamble_lines;
        preamble_lines.clear();
    }

    // Exec preamble
    for (auto ln: preamble_lines) {
        ICLI_PRINTF("%s\n", ln.c_str());
        ICLI_CMD_EXEC(ln.c_str(), TRUE);
    }

#ifdef USE_VARMAP
    ExprEval::VarMap vars;
    ExprEval expr(vars);
#else
    ExprEval expr;
#endif

    // Exec loop lines, evaluating expression starting with '$'
    for (auto i = 0; i < range->u.sr.cnt; i++) {
        for (auto val = range->u.sr.range[i].min; val <= range->u.sr.range[i].max; val++) {
#ifdef USE_VARMAP
            vars["i"] = val;
#else
            expr.set_idx(val);
#endif
            for(auto ln: loop_lines) {
                bool all_evals_ok = true;
                std::string errs;
                size_t pos;
                while ((pos = ln.find("$")) != std::string::npos) {
                    int val = expr.eval(std::string(ln, pos + 1, std::string::npos));       // +1: Skip over '$' for eval
                    if (!expr.is_valid()) {
                        if (!all_evals_ok) {
                            errs += "; ";
                        }
                        errs        += expr.error_message();
                        all_evals_ok = false;
                        break;
                    }
                    ln.replace(pos, expr.length() + 1, std::to_string(val));                          // +1: Include '$' in text being replaced
                }
                if (all_evals_ok) {
                    ICLI_PRINTF("%s\n", ln.c_str());
                    ICLI_CMD_EXEC(ln.c_str(), TRUE);
                } else {
                    ICLI_PRINTF("%s ! EXPRESSION EVALUATION FAILED, not excuting. Err=%s\n", ln.c_str(), errs.c_str());
                }
            }
        }
    }

    // Exec postamble
    for (auto ln: postamble_lines) {
        ICLI_PRINTF("%s\n", ln.c_str());
        ICLI_CMD_EXEC(ln.c_str(), TRUE);
    }
CODE_END

CMD_END

